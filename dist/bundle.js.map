{"version":3,"sources":["webpack:///bundle.js","webpack:///webpack/bootstrap d3852852b6569872b94d","webpack:///./~/@polymer/polymer/lib/utils/boot.html","webpack:///./~/@polymer/polymer/lib/utils/mixin.html","webpack:///./~/@polymer/polymer/lib/utils/case-map.html","webpack:///./~/@polymer/polymer/lib/utils/resolve-url.html","webpack:///./~/@polymer/polymer/polymer-element.html","webpack:///./components/store.js","webpack:///./~/lodash-es/_Symbol.js","webpack:///./~/lodash-es/isPlainObject.js","webpack:///./~/redux/es/compose.js","webpack:///./~/redux/es/createStore.js","webpack:///./~/@polymer/polymer/lib/mixins/mutable-data.html","webpack:///./~/@polymer/polymer/lib/mixins/property-effects.html","webpack:///./~/@polymer/polymer/lib/utils/async.html","webpack:///(webpack)/buildin/global.js","webpack:///./components/fake-app/index.js","webpack:///./components/list-data/index.js","webpack:///./~/lodash-es/_baseGetTag.js","webpack:///./~/lodash-es/_freeGlobal.js","webpack:///./~/lodash-es/_getPrototype.js","webpack:///./~/lodash-es/_getRawTag.js","webpack:///./~/lodash-es/_objectToString.js","webpack:///./~/lodash-es/_overArg.js","webpack:///./~/lodash-es/_root.js","webpack:///./~/lodash-es/isObjectLike.js","webpack:///./~/redux/es/applyMiddleware.js","webpack:///./~/symbol-observable/index.js","webpack:///./~/symbol-observable/lib/index.js","webpack:///./~/symbol-observable/lib/ponyfill.js","webpack:///./components/fake-app/template.html","webpack:///./components/list-data/template.html","webpack:///./~/@polymer/polymer/lib/elements/dom-module.html","webpack:///./~/@polymer/polymer/lib/elements/dom-repeat.html","webpack:///./~/@polymer/polymer/lib/mixins/element-mixin.html","webpack:///./~/@polymer/polymer/lib/mixins/property-accessors.html","webpack:///./~/@polymer/polymer/lib/mixins/template-stamp.html","webpack:///./~/@polymer/polymer/lib/utils/debounce.html","webpack:///./~/@polymer/polymer/lib/utils/flush.html","webpack:///./~/@polymer/polymer/lib/utils/path.html","webpack:///./~/@polymer/polymer/lib/utils/style-gather.html","webpack:///./~/@polymer/polymer/lib/utils/templatize.html","webpack:///(webpack)/buildin/module.js"],"names":["modules","__webpack_require__","moduleId","installedModules","exports","module","i","l","call","m","c","value","d","name","getter","o","Object","defineProperty","configurable","enumerable","get","n","__esModule","object","property","prototype","hasOwnProperty","p","s","userPolymer","window","Polymer","info","_polymerFn","assign","Error","version","JSCompiler_renameProperty","prop","obj","cachingMixin","mixin","base","__mixinApplications","WeakMap","map","application","set","dedupeId","dedupingMixin","__dedupeId","baseSet","__mixinSet","extended","create","caseMap","DASH_TO_CAMEL","CAMEL_TO_DASH","CaseMap","dashToCamelCase","dash","indexOf","replace","toUpperCase","camelToDashCase","camel","toLowerCase","resolveUrl","url","baseURI","ABS_URL","test","undefined","workingURL","u","URL","pathname","href","e","document","location","resolveDoc","implementation","createHTMLDocument","createElement","head","appendChild","anchor","body","resolveCss","cssText","CSS_URL_RX","pre","post","pathFromUrl","substring","lastIndexOf","ResolveUrl","Element","ElementMixin","HTMLElement","__webpack_exports__","__WEBPACK_IMPORTED_MODULE_0_redux__","appReducer","state","action","type","items","data","selected","store","__REDUX_DEVTOOLS_EXTENSION__","Symbol","isPlainObject","__WEBPACK_IMPORTED_MODULE_2__isObjectLike_js__","__WEBPACK_IMPORTED_MODULE_0__baseGetTag_js__","objectTag","proto","__WEBPACK_IMPORTED_MODULE_1__getPrototype_js__","Ctor","constructor","funcToString","objectCtorString","funcProto","Function","objectProto","toString","compose","_len","arguments","length","funcs","Array","_key","arg","last","rest","slice","reduceRight","composed","f","apply","createStore","reducer","preloadedState","enhancer","ensureCanMutateNextListeners","nextListeners","currentListeners","getState","currentState","subscribe","listener","isSubscribed","push","index","splice","dispatch","__WEBPACK_IMPORTED_MODULE_0_lodash_es_isPlainObject__","isDispatching","currentReducer","listeners","replaceReducer","nextReducer","ActionTypes","INIT","observable","_ref","outerSubscribe","observer","observeState","next","TypeError","unsubscribe","__WEBPACK_IMPORTED_MODULE_1_symbol_observable___default","a","this","_ref2","__WEBPACK_IMPORTED_MODULE_1_symbol_observable__","mutablePropertyChange","inst","old","mutableData","isObject","__dataTemp","shouldChange","MutableData","superClass","_shouldPropertyChange","OptionalMutableData","properties","Boolean","_mutablePropertyChange","ensureOwnEffectMap","model","effects","protoFx","instFx","runEffects","props","oldProps","hasPaths","extraArgs","ran","id","runEffectsForProperty","fxs","Path","root","fx","lastRun","pathMatchesTrigger","trigger","fn","path","triggerPath","structured","isAncestor","wildcard","isDescendant","runObserverEffect","methodName","changedProp","__data","dynamicFn","console","warn","runNotifyEffects","notifyProps","notified","__notifyEffects","notifyPath","host","__dataHost","_invalidateProperties","rootProperty","eventName","dispatchNotifyEvent","detail","queueProperty","dispatchEvent","CustomEvent","runNotifyEffect","handleNotification","event","fromProp","toPath","negate","fromPath","translate","target","__readOnly","_setPendingPropertyOrPath","runReflectEffect","sanitizeDOMValue","attrName","_propertyToAttribute","runComputedEffects","changedProps","computeEffects","__computeEffects","inputProps","__dataOld","__dataPending","runComputedEffect","result","runMethodEffect","computedProp","methodInfo","__dataHasAccessor","_setPendingProperty","computeLinkedPaths","links","__dataLinkedPaths","link","b","addBinding","templateInfo","nodeInfo","kind","parts","literal","bindings","binding","isCompound","shouldAddListener","listenerEvent","listenerNegate","nodeInfoList","part","compoundIndex","addEffectForBindingPart","dependencies","evaluator","j","parseArg","_addTemplatePropertyEffect","runBindingEffect","nodeList","node","source","_enqueueClient","_evaluateBinding","applyBindingValue","computeBindingValue","_valueToNodeAttribute","_setUnmanagedPropertyToNode","storage","__dataCompoundStorage","join","localName","mode","setupBindings","setupCompoundStorage","addNotifyListener","literals","addEventListener","createMethodEffect","sig","effectFn","static","args","_addPropertyEffect","context","_methodHost","marshalArgs","literalFromParts","parseMethod","expression","match","trim","split","parseArgs","emptyArray","argList","rawArg","fc","Number","isPath","values","v","baseChanged","matches","notifySplices","array","splices","splicesPath","indexSplices","notifySplice","addedCount","removed","upper","TYPES","COMPUTE","REFLECT","NOTIFY","PROPAGATE","OBSERVE","READ_ONLY","bindingRegex","RegExp","OPEN_BRACKET","PropertyEffects","propertyEffectsBase","TemplateStamp","PropertyAccessors","PROPERTY_EFFECT_TYPES","_initializeProperties","super","hostStack","registerHost","__dataClientsReady","__dataPendingClients","__dataToNotify","__dataHasPaths","_initializeProtoProperties","_initializeInstanceProperties","readOnly","effect","_createPropertyAccessor","_removePropertyEffect","idx","_hasPropertyEffect","_hasReadOnlyEffect","_hasNotifyEffect","_hasReflectEffect","_hasComputedEffect","shouldNotify","isPathNotification","isArray","prevProps","_setProperty","__dataReady","_flushProperties","client","_flushClients","__enableOrFlushClients","_readyClients","clients","__dataEnabled","_enableProperties","setProperties","setReadOnly","ready","_propertiesChanged","currentProps","_propagatePropertyChanges","__reflectEffects","__observeEffects","__dataCounter","__propagateEffects","__templateInfo","propertyEffects","nextTemplateInfo","linkPaths","to","from","normalize","unlinkPaths","len","ret","pop","hadLength","start","deleteCount","Math","floor","shift","unshift","propPath","_createReadOnlyProperty","protectedSetter","_createPropertyObserver","_createMethodObserver","_createNotifyingProperty","_createReflectedProperty","attr","_createComputedProperty","[object Object]","template","_bindTemplate","instanceBinding","_parseTemplate","wasPreBound","__templateInfoLast","previousTemplateInfo","hostProps","_stampTemplate","beginHosting","dom","endHosting","nodes","childNodes","firstChild","nextSibling","_removeBoundDom","parentNode","removeChild","noted","_parseTemplateNode","nodeType","Node","TEXT_NODE","_parseBindings","textContent","origName","setAttribute","removeAttribute","_parseTemplateNodeAttribute","_parseTemplateNestedTemplate","text","lastIndex","exec","customEvent","notifyEvent","colon","signature","dynamicFns","stack","stackLen","microtaskFlush","microtaskCallbacks","cb","setTimeout","microtaskLastHandle","microtaskCurrHandle","microtaskNodeContent","microtaskNode","createTextNode","MutationObserver","observe","characterData","Async","timeOut","after","delay","run","cancel","clearTimeout","bind","animationFrame","requestAnimationFrame","cancelAnimationFrame","idlePeriod","requestIdleCallback","handle","cancelIdleCallback","microTask","callback","g","eval","__WEBPACK_IMPORTED_MODULE_0__polymer_polymer_polymer_element_html__","__WEBPACK_IMPORTED_MODULE_1__template_html__","FakeApp","is","String","customElements","define","__WEBPACK_IMPORTED_MODULE_1__polymer_polymer_lib_elements_dom_repeat_html__","__WEBPACK_IMPORTED_MODULE_2__template_html__","__WEBPACK_IMPORTED_MODULE_3__store__","ListData","connectedCallback","fetch","then","resp","json","filtered","filter","baseGetTag","undefinedTag","nullTag","symToStringTag","__WEBPACK_IMPORTED_MODULE_1__getRawTag_js__","__WEBPACK_IMPORTED_MODULE_2__objectToString_js__","__WEBPACK_IMPORTED_MODULE_0__Symbol_js__","toStringTag","global","freeGlobal","__WEBPACK_IMPORTED_MODULE_0__overArg_js__","getPrototype","getPrototypeOf","getRawTag","isOwn","tag","unmasked","nativeObjectToString","objectToString","overArg","func","transform","__WEBPACK_IMPORTED_MODULE_0__freeGlobal_js__","freeSelf","self","isObjectLike","__WEBPACK_IMPORTED_MODULE_0__createStore__","_ponyfill2","default","symbolObservablePonyfill","_Symbol","innerHTML","children","write","findModule","lcModules","styleOutsideTemplateCheck","querySelector","DomModule","observedAttributes","selector","attributeChangedCallback","register","assetpath","__assetpath","owner","HTMLImports","importForElement","ownerDocument","getAttribute","domRepeatBase","DomRepeat","as","indexAs","itemsIndexAs","sort","renderedItemCount","notify","initialCount","targetFramerate","_targetFrameTime","computed","observers","__instances","__limit","Infinity","__pool","__renderDebouncer","__itemsIdxToInstIdx","__chunkCount","__lastChunkTime","__needFullRefresh","__sortFn","__filterFn","__observePaths","__ctor","disconnectedCallback","__isDetached","__detachInstance","parent","__attachInstance","__ensureTemplatized","disconnect","__render","childList","instanceProps","Templatize","templatize","parentModel","forwardHostProp","i$","notifyInstanceProp","__getMethodHost","__sortChanged","methodHost","__debounceRender","__filterChanged","__computeFrameTime","rate","ceil","__initializeChunking","performance","now","__tryRenderChunk","__requestRenderChunk","__renderChunk","currChunkTime","ratio","round","__observeChanged","__itemsChanged","change","__handleItemPath","__handleObservedPaths","paths","Debouncer","debounce","enqueueDebouncer","render","flush","__applyFullRefresh","_setRenderedItemCount","bubbles","isntIdxToItemsIdx","itemsIdxToInstIdx","instIdx","limit","min","itemIdx","item","__insertInstance","__detachAndRemoveInstance","el","insertBefore","__stampInstance","beforeRow","beforeNode","_showHideChildren","hidden","itemsPath","dot","itemsIdx","parseInt","itemSubPath","itemPath","itemForElement","instance","modelForElement","indexForElement","ownPropertiesForClass","klass","__ownProperties","ownObserversForClass","__ownObservers","flattenProperties","flattenedProps","propertiesForClass","__classProperties","superCtor","PolymerElement","propertyDefaultsForClass","__classPropertyDefaults","hasClassFinalized","finalizeClassAndSuper","finalize","finalizeClass","__finalized","telemetry","finalizeProperties","finalizeObservers","t","cloneNode","_template","createPropertyFromConfig","allProps","reflectToAttribute","finalizeTemplate","ext","StyleGather","cssFromTemplate","cssFromModuleImports","style","content","ShadyCSS","prepareTemplate","polymerElementBase","list","__observedAttributes","import","importPath","_importPath","instanceCount","__polymerFinalized","__proto__","rootPath","p$","_hasAccessor","styleElement","$","_attachDom","attachShadow","shadowRoot","_attributeToProperty","updateStyles","styleSubtree","_parseTemplateContent","registrations","_regLog","log","dumpRegistrations","forEach","styleDocument","saveAccessorValue","nativeProperties","__dataProto","microtask","getOwnPropertyNames","a$","__serializing","__dataInvalid","__dataInstanceProps","_ensureAttribute","attribute","hasAttribute","_deserializeValue","str","_serializeValue","Date","JSON","stringify","x","outValue","parse","_isPropertyPending","wrapTemplateExtension","templateExtensions","replaceChild","attributes","findTemplateNode","parentInfo","parentIndex","applyIdToMap","applyEventListener","events","e$","_addMethodEventListenerToNode","applyTemplateContent","_templateInfo","createNodeEventHandler","dom-if","dom-repeat","outerTemplateInfo","stripWhiteSpace","hasInsertionPoint","_parseTemplateChildNodes","hasAttributes","_parseTemplateNodeAttributes","childInfo","infoIndex","createDocumentFragment","attrs","HTMLTemplateElement","decorate","importNode","__noInsertionPoint","handler","_addEventListenerToNode","_removeEventListenerFromNode","removeEventListener","_asyncModule","_callback","_timer","setConfig","asyncModule","isActive","debouncer","flushDebouncers","didFlush","debouncerQueue","shadyDOM","debouncers","ShadyDOM","ScopingShim","dotIndex","newBase","isDeep","importModule","MODULE_STYLE_LINK_SELECTOR","INCLUDE_ATTR","cssFromModules","moduleIds","cssFromModule","_cssText","querySelectorAll","include","importDoc","container","HTMLTemplateElementExtension","newInstance","upgradeTemplate","setPrototypeOf","findMethodHost","templateHost","createTemplatizerClass","options","MutableTemplateInstanceBase","TemplateInstanceBase","__templatizeOptions","addNotifyEffects","addPropagateEffects","userForwardHostProp","templatizeTemplateClass","MutableDataTemplate","DataTemplate","createForwardHostPropEffect","hostProp","__templatizeOwner","iprop","userNotifyInstanceProp","createNotifyInstancePropEffect","hprop","createNotifyHostPropEffect","instProp","writable","_configureProperties","__templatizeInstance","__hideTemplateChildren__","__hostProps","hide","__polymerTextContent__","__polymerDisplay__","display","__parentModel","baseClass","templatizeInstanceClass","webpackPolyfill","deprecate"],"mappings":"CAAS,SAAUA,GCInB,SAAAC,EAAAC,GAGA,GAAAC,EAAAD,GACA,OAAAC,EAAAD,GAAAE,QAGA,IAAAC,EAAAF,EAAAD,IACAI,EAAAJ,EACAK,GAAA,EACAH,YAUA,OANAJ,EAAAE,GAAAM,KAAAH,EAAAD,QAAAC,IAAAD,QAAAH,GAGAI,EAAAE,GAAA,EAGAF,EAAAD,QAvBA,IAAAD,KA4BAF,EAAAQ,EAAAT,EAGAC,EAAAS,EAAAP,EAGAF,EAAAK,EAAA,SAAAK,GAA2C,OAAAA,GAG3CV,EAAAW,EAAA,SAAAR,EAAAS,EAAAC,GACAb,EAAAc,EAAAX,EAAAS,IACAG,OAAAC,eAAAb,EAAAS,GACAK,cAAA,EACAC,YAAA,EACAC,IAAAN,KAMAb,EAAAoB,EAAA,SAAAhB,GACA,IAAAS,EAAAT,KAAAiB,WACA,WAA2B,OAAAjB,EAAA,SAC3B,WAAiC,OAAAA,GAEjC,OADAJ,EAAAW,EAAAE,EAAA,IAAAA,GACAA,GAIAb,EAAAc,EAAA,SAAAQ,EAAAC,GAAsD,OAAAR,OAAAS,UAAAC,eAAAlB,KAAAe,EAAAC,IAGtDvB,EAAA0B,EAAA,GAGA1B,IAAA2B,EAAA,MDMM,SAAUvB,EAAQD,IEpExB,WACE,aAEA,MAAMyB,EAAcC,OAAOC,QAc3BD,OAAOC,QAAU,SAASC,GACxB,OAAOF,OAAOC,QAAQE,WAAWD,IAI/BH,GACFb,OAAOkB,OAAOH,QAASF,GAUzBC,OAAOC,QAAQE,WAAa,SAASD,GACnC,MAAM,IAAIG,MAAM,qDAElBL,OAAOC,QAAQK,QAAU,QAOzBN,OAAOO,0BAA4B,SAASC,EAAMC,GAChD,OAAOD,OFgFL,SAAUjC,EAAQD,EAASH,GG7HjCA,EAAQ,GAIR,WAEE,aAYA,SAASuC,EAAaC,GACpB,OAAO,SAASC,GACTD,EAAME,sBACTF,EAAME,oBAAsB,IAAIC,SAElC,IAAIC,EAAMJ,EAAME,oBACZG,EAAcD,EAAIzB,IAAIsB,GAK1B,OAJKI,IACHA,EAAcL,EAAMC,GACpBG,EAAIE,IAAIL,EAAMI,IAETA,GApBX,IAAIE,EAAW,EAkCfjB,QAAQkB,cAAgB,SAASR,GAI/B,OAHAA,EAAQD,EAAaC,GAErBA,EAAMS,aAAeF,EACd,SAASN,GACd,IAAIS,EAAUT,EAAKU,WACnB,GAAID,GAAWA,EAAQV,EAAMS,YAC3B,OAAOR,EAET,IAAIW,EAAWZ,EAAMC,GAOrB,OAHAW,EAASD,WACPpC,OAAOsC,OAAOD,EAASD,YAAcD,GAAW,MAClDE,EAASD,WAAWX,EAAMS,aAAc,EACjCG,QHqIP,SAAUhD,EAAQD,EAASH,GIhMjCA,EAAQ,GAGR,WACE,aAEA,MAAMsD,KACAC,EAAgB,UAChBC,EAAgB,WAWhBC,GAUJC,gBAAgBC,GACd,OAAOL,EAAQK,KACbL,EAAQK,GAAQA,EAAKC,QAAQ,KAAO,EAAID,EAAOA,EAAKE,QAAQN,EACzD/C,GAAMA,EAAE,GAAGsD,iBAalBC,gBAAgBC,GACd,OAAOV,EAAQU,KACbV,EAAQU,GAASA,EAAMH,QAAQL,EAAe,OAAOS,iBAM3DnC,QAAQ2B,QAAUA,MJiMd,SAAUrD,EAAQD,EAASH,GKtPjCA,EAAQ,GAIN,WACE,aAcA,SAASkE,EAAWC,EAAKC,GACvB,GAAID,GAAOE,EAAQC,KAAKH,GACtB,OAAOA,EAGT,QAAmBI,IAAfC,EAA0B,CAC5BA,GAAa,EACb,IACE,MAAMC,EAAI,IAAIC,IAAI,IAAK,YACvBD,EAAEE,SAAW,QACbH,EAAyB,mBAAXC,EAAEG,KAChB,MAAOC,KAOX,OAHKT,IACHA,EAAUU,SAASV,SAAWvC,OAAOkD,SAASH,MAE5CJ,EACM,IAAIE,IAAIP,EAAKC,GAAUQ,MAG5BI,KACHA,EAAaF,SAASG,eAAeC,mBAAmB,SAC7CzC,KAAOuC,EAAWG,cAAc,QAC3CH,EAAWI,KAAKC,YAAYL,EAAWvC,MACvCuC,EAAWM,OAASN,EAAWG,cAAc,KAC7CH,EAAWO,KAAKF,YAAYL,EAAWM,SAEzCN,EAAWvC,KAAKmC,KAAOR,EACvBY,EAAWM,OAAOV,KAAOT,EAClBa,EAAWM,OAAOV,MAAQT,GAanC,SAASqB,EAAWC,EAASrB,GAC3B,OAAOqB,EAAQ5B,QAAQ6B,EAAY,SAASlF,EAAGmF,EAAKxB,EAAKyB,GACvD,OAAOD,EAAM,IACXzB,EAAWC,EAAIN,QAAQ,QAAS,IAAKO,GACrC,IAAOwB,IAYb,SAASC,EAAY1B,GACnB,OAAOA,EAAI2B,UAAU,EAAG3B,EAAI4B,YAAY,KAAO,GAzEjD,IAEIvB,EACAQ,EAHAU,EAAa,sBACbrB,EAAU,0BAkFdvC,QAAQkE,YACNR,WAAYA,EACZtB,WAAYA,EACZ2B,YAAaA,OL0Pb,SAAUzF,EAAQD,EAASH,GMvVjCA,EAAQ,IAGR,WACE,aAiBA,MAAMiG,EAAUnE,QAAQoE,aAAaC,aACrCrE,QAAQmE,QAAUA,MN+Vd,SAAU7F,EAAQgG,EAAqBpG,GAE7C,aACqB,IAAIqG,EAAsCrG,EAAoB,IOrXnF,MAKMsG,EAAa,CAACC,EAAQ,EAAGC,KAC7B,OAAQA,EAAOC,MACb,IAAK,YACH,OAAO1F,OAAOkB,UAAWsE,GAAQG,MAAOF,EAAOG,OACjD,IAAK,WACH,OAAO5F,OAAOkB,UAAWsE,GAAQK,SAAUJ,EAAOG,OACpD,QACE,OAAOJ,IAIAM,EAAQ7G,EAAAK,EAAAgG,EAAA,GACnBC,EACAzE,OAAOiF,8BAAgCjF,OAAOiF,gCPyXfV,EAAuB,EAAIS,GAKtD,SAAUzG,EAAQgG,EAAqBpG,GAE7C,aACqB,IQpZjB+G,ERoZ8D/G,EAAoB,IQpZzE,EAAK+G,OAElBX,EAAA,KR4ZM,SAAUhG,EAAQgG,EAAqBpG,GAE7C,aSnXA,SAASgH,EAActG,GACrB,IAAKV,EAAAK,EAAA4G,EAAA,GAAavG,IAAUV,EAAAK,EAAA6G,EAAA,GAAWxG,IAAUyG,EAC/C,OAAO,EAET,IAAIC,EAAQpH,EAAAK,EAAAgH,EAAA,GAAa3G,GACzB,GAAc,OAAV0G,EACF,OAAO,EAET,IAAIE,EAAO7F,EAAelB,KAAK6G,EAAO,gBAAkBA,EAAMG,YAC9D,MAAsB,mBAARD,GAAsBA,aAAgBA,GAClDE,EAAajH,KAAK+G,IAASG,ET0WV,IAAIP,EAA+ClH,EAAoB,IACnEqH,EAAiDrH,EAAoB,IACrEiH,EAAiDjH,EAAoB,ISja1FmH,EAAY,kBAGZO,EAAYC,SAASnG,UACrBoG,EAAc7G,OAAOS,UAGrBgG,EAAeE,EAAUG,SAGzBpG,EAAiBmG,EAAYnG,eAG7BgG,EAAmBD,EAAajH,KAAKQ,QA2CzCqF,EAAA,KT0aM,SAAUhG,EAAQgG,EAAqBpG,GAE7C,aU9de,SAAS8H,IACtB,IAAK,IAAIC,EAAOC,UAAUC,OAAQC,EAAQC,MAAMJ,GAAOK,EAAO,EAAGA,EAAOL,EAAMK,IAC5EF,EAAME,GAAQJ,UAAUI,GAG1B,GAAqB,IAAjBF,EAAMD,OACR,OAAO,SAAUI,GACf,OAAOA,GAIX,GAAqB,IAAjBH,EAAMD,OACR,OAAOC,EAAM,GAGf,IAAII,EAAOJ,EAAMA,EAAMD,OAAS,GAC5BM,EAAOL,EAAMM,MAAM,GAAI,GAC3B,OAAO,WACL,OAAOD,EAAKE,YAAY,SAAUC,EAAUC,GAC1C,OAAOA,EAAED,IACRJ,EAAKM,WAAMrE,EAAWyD,aA/B7B5B,EAAA,EAAA0B,GVghBM,SAAU1H,EAAQgG,EAAqBpG,GAE7C,aW5ee,SAAS6I,EAAYC,EAASC,EAAgBC,GA0B3D,SAASC,IACHC,IAAkBC,IACpBD,EAAgBC,EAAiBX,SASrC,SAASY,IACP,OAAOC,EA0BT,SAASC,EAAUC,GACjB,GAAwB,mBAAbA,EACT,MAAM,IAAIrH,MAAM,uCAGlB,IAAIsH,GAAe,EAKnB,OAHAP,IACAC,EAAcO,KAAKF,GAEZ,WACL,GAAKC,EAAL,CAIAA,GAAe,EAEfP,IACA,IAAIS,EAAQR,EAActF,QAAQ2F,GAClCL,EAAcS,OAAOD,EAAO,KA6BhC,SAASE,EAASpD,GAChB,IAAKxG,EAAAK,EAAAwJ,EAAA,GAAcrD,GACjB,MAAM,IAAItE,MAAM,2EAGlB,QAA2B,IAAhBsE,EAAOC,KAChB,MAAM,IAAIvE,MAAM,sFAGlB,GAAI4H,EACF,MAAM,IAAI5H,MAAM,sCAGlB,IACE4H,GAAgB,EAChBT,EAAeU,EAAeV,EAAc7C,GAF9C,QAIEsD,GAAgB,EAIlB,IAAK,IADDE,EAAYb,EAAmBD,EAC1B7I,EAAI,EAAGA,EAAI2J,EAAU/B,OAAQ5H,IACpC2J,EAAU3J,KAGZ,OAAOmG,EAaT,SAASyD,EAAeC,GACtB,GAA2B,mBAAhBA,EACT,MAAM,IAAIhI,MAAM,8CAGlB6H,EAAiBG,EACjBN,GAAWnD,KAAM0D,EAAYC,OAS/B,SAASC,IACP,IAAIC,EAEAC,EAAiBjB,EACrB,OAAOgB,GASLhB,UAAW,SAAmBkB,GAK5B,SAASC,IACHD,EAASE,MACXF,EAASE,KAAKtB,KANlB,GAAwB,iBAAboB,EACT,MAAM,IAAIG,UAAU,0CAWtB,OAFAF,KAESG,YADSL,EAAeE,MAGlCH,EAAKO,EAAAC,GAAgB,WACtB,OAAOC,MACNT,EAlML,IAAIU,EAOJ,GAL8B,mBAAnBjC,QAAqD,IAAbC,IACjDA,EAAWD,EACXA,OAAiBxE,QAGK,IAAbyE,EAA0B,CACnC,GAAwB,mBAAbA,EACT,MAAM,IAAI9G,MAAM,2CAGlB,OAAO8G,EAASH,GAAaC,EAASC,GAGxC,GAAuB,mBAAZD,EACT,MAAM,IAAI5G,MAAM,0CAGlB,IAAI6H,EAAiBjB,EACjBO,EAAeN,EACfI,KACAD,EAAgBC,EAChBW,GAAgB,EAmLpB,OAFAF,GAAWnD,KAAM0D,EAAYC,OAEtBY,GACLpB,SAAUA,EACVN,UAAWA,EACXF,SAAUA,EACVa,eAAgBA,GACfe,EAAMH,EAAAC,GAAgBT,EAAYW,EX6RRhL,EAAoBW,EAAEyF,EAAqB,IAAK,WAAa,OAAO+D,IAClE/D,EAAuB,EAAIyC,EACvC,IAAIgB,EAAwD7J,EAAoB,GAC5EiL,EAAkDjL,EAAoB,IACtE6K,EAA0D7K,EAAoBoB,EAAE6J,GW9gB9Fd,GACTC,KAAM,iBXywBF,SAAUhK,EAAQgG,EAAqBpG,GAE7C,cA0BM,SAAUI,EAAQD,EAASH,GY9yBjCA,EAAQ,GAGR,WACE,aAGA,SAASkL,EAAsBC,EAAM5J,EAAUb,EAAO0K,EAAKC,GACzD,IAAIC,EACAD,IACFC,EAA6B,iBAAV5K,GAAgC,OAAVA,KAGvC0K,EAAMD,EAAKI,WAAWhK,IAI1B,IAAIiK,EAAgBJ,IAAQ1K,IAAU0K,IAAQA,GAAO1K,IAAUA,GAM/D,OAHI4K,GAAYE,IACdL,EAAKI,WAAWhK,GAAYb,GAEvB8K,EAuCT1J,QAAQ2J,YAAc3J,QAAQkB,cAAc0I,UAMpCD,UAAoBC,EAkBxBC,sBAAsBpK,EAAUb,EAAO0K,GACrC,OAAOF,EAAsBH,KAAMxJ,EAAUb,EAAO0K,GAAK,IAK7D,OAAOK,IAyCT3J,QAAQ8J,oBAAsB9J,QAAQkB,cAAc0I,UAM5CE,UAA4BF,EAEhCG,wBACE,OAMER,YAAaS,SAsBjBH,sBAAsBpK,EAAUb,EAAO0K,GACrC,OAAOF,EAAsBH,KAAMxJ,EAAUb,EAAO0K,EAAKL,KAAKM,cAIlE,OAAOO,IAKT9J,QAAQ2J,YAAYM,uBAAyBb,MZozBzC,SAAU9K,EAAQD,EAASH,Gax+BjCA,EAAQ,GAERA,EAAQ,GAERA,EAAQ,IAERA,EAAQ,GAERA,EAAQ,IAERA,EAAQ,IAGR,WAEE,aAyCA,SAASgM,EAAmBC,EAAOxF,GACjC,IAAIyF,EAAUD,EAAMxF,GACpB,GAAKyF,GAEE,IAAKD,EAAMxK,eAAegF,GAAO,CACtCyF,EAAUD,EAAMxF,GAAQ1F,OAAOsC,OAAO4I,EAAMxF,IAC5C,IAAK,IAAI/E,KAAKwK,EAAS,CACrB,IAAIC,EAAUD,EAAQxK,GAClB0K,EAASF,EAAQxK,GAAKyG,MAAMgE,EAAQlE,QACxC,IAAK,IAAI5H,EAAE,EAAGA,EAAE8L,EAAQlE,OAAQ5H,IAC9B+L,EAAO/L,GAAK8L,EAAQ9L,UAPxB6L,EAAUD,EAAMxF,MAWlB,OAAOyF,EAkBT,SAASG,EAAWlB,EAAMe,EAASI,EAAOC,EAAUC,EAAUC,GAC5D,GAAIP,EAAS,CACX,IAAIQ,GAAM,EACNC,EAAK5J,IACT,IAAK,IAAIV,KAAQiK,EACXM,EAAsBzB,EAAMe,EAASS,EAAItK,EAAMiK,EAAOC,EAAUC,EAAUC,KAC5EC,GAAM,GAGV,OAAOA,EAET,OAAO,EAiBT,SAASE,EAAsBzB,EAAMe,EAASnJ,EAAUV,EAAMiK,EAAOC,EAAUC,EAAUC,GACvF,IAAIC,GAAM,EAENG,EAAMX,EADSM,EAAW1K,QAAQgL,KAAKC,KAAK1K,GAAQA,GAExD,GAAIwK,EACF,IAAK,IAAuBG,EAAnB3M,EAAE,EAAGC,EAAEuM,EAAI5E,OAAa5H,EAAEC,IAAO0M,EAAGH,EAAIxM,IAAKA,IAC9C2M,EAAGjL,MAAQiL,EAAGjL,KAAKkL,UAAYlK,GAC/ByJ,IAAYU,EAAmB7K,EAAM2K,EAAGG,WACxCH,EAAGjL,OACLiL,EAAGjL,KAAKkL,QAAUlK,GAEpBiK,EAAGI,GAAGjC,EAAM9I,EAAMiK,EAAOC,EAAUS,EAAGjL,KAAMyK,EAAUC,GACtDC,GAAM,GAIZ,OAAOA,EAqBT,SAASQ,EAAmBG,EAAMF,GAChC,GAAIA,EAAS,CACX,IAAIG,EAAcH,EAAQvM,KAC1B,OAAQ0M,GAAeD,GACpBF,EAAQI,YAAczL,QAAQgL,KAAKU,WAAWF,EAAaD,IAC3DF,EAAQM,UAAY3L,QAAQgL,KAAKY,aAAaJ,EAAaD,GAE9D,OAAO,EAiBX,SAASM,EAAkBxC,EAAM5J,EAAU+K,EAAOC,EAAUxK,GAC1D,IAAIqL,EAAKjC,EAAKpJ,EAAK6L,YACfC,EAAc9L,EAAKR,SACnB6L,EACFA,EAAG7M,KAAK4K,EAAMA,EAAK2C,OAAOD,GAActB,EAASsB,IACvC9L,EAAKgM,WACfC,QAAQC,KAAK,oBAAsBlM,EAAK6L,WAAa,iBAqBzD,SAASM,EAAiB/C,EAAMgD,EAAa7B,EAAOC,EAAUC,GAE5D,IACI4B,EADAvB,EAAM1B,EAAKkD,gBAEX1B,EAAK5J,IAET,IAAK,IAAIV,KAAQ8L,EACXA,EAAY9L,KACVwK,GAAOD,EAAsBzB,EAAM0B,EAAKF,EAAItK,EAAMiK,EAAOC,EAAUC,GACrE4B,GAAW,EACF5B,GAAY8B,EAAWnD,EAAM9I,EAAMiK,KAC5C8B,GAAW,IAOjB,IAAIG,EACAH,IAAaG,EAAOpD,EAAKqD,aAAeD,EAAKE,uBAC/CF,EAAKE,wBAcT,SAASH,EAAWnD,EAAMkC,EAAMf,GAC9B,IAAIoC,EAAe5M,QAAQgL,KAAKC,KAAKM,GACrC,GAAIqB,IAAiBrB,EAAM,CACzB,IAAIsB,EAAY7M,QAAQ2B,QAAQM,gBAAgB2K,GAAgB,WAEhE,OADAE,EAAoBzD,EAAMwD,EAAWrC,EAAMe,GAAOA,IAC3C,GAeX,SAASuB,EAAoBzD,EAAMwD,EAAWjO,EAAO2M,GACnD,IAAIwB,GACFnO,MAAOA,EACPoO,eAAe,GAEbzB,IACFwB,EAAOxB,KAAOA,GAEhBlC,EAAK4D,cAAc,IAAIC,YAAYL,GAAaE,YAiBlD,SAASI,EAAgB9D,EAAM5J,EAAU+K,EAAOC,EAAUxK,EAAMyK,GAC9D,IACIa,GADeb,EAAW1K,QAAQgL,KAAKC,KAAKxL,GAAYA,IACjCA,EAAWA,EAAW,KAC7Cb,EAAQ2M,EAAOvL,QAAQgL,KAAK3L,IAAIgK,EAAMkC,GAAQlC,EAAK2C,OAAOvM,GAC1D8L,QAAkB9I,IAAV7D,IACVA,EAAQ4L,EAAM/K,IAEhBqN,EAAoBzD,EAAMpJ,EAAK4M,UAAWjO,EAAO2M,GAmBnD,SAAS6B,EAAmBC,EAAOhE,EAAMiE,EAAUC,EAAQC,GACzD,IAAI5O,EACAmO,EAASM,EAAMN,OACfU,EAAWV,GAAUA,EAAOxB,KAC5BkC,GACFF,EAASvN,QAAQgL,KAAK0C,UAAUJ,EAAUC,EAAQE,GAClD7O,EAAQmO,GAAUA,EAAOnO,OAEzBA,EAAQyO,EAAMM,OAAOL,GAEvB1O,EAAQ4O,GAAU5O,EAAQA,EACrByK,EAAKuE,YAAevE,EAAKuE,WAAWL,KACnClE,EAAKwE,0BAA0BN,EAAQ3O,GAAO,EAAMoL,QAAQyD,KACzDV,GAAWA,EAAOC,eACvB3D,EAAKsD,wBAiBX,SAASmB,EAAiBzE,EAAM5J,EAAU+K,EAAOC,EAAUxK,GACzD,IAAIrB,EAAQyK,EAAK2C,OAAOvM,GACpBO,QAAQ+N,mBACVnP,EAAQoB,QAAQ+N,iBAAiBnP,EAAOqB,EAAK+N,SAAU,YAAa3E,IAEtEA,EAAK4E,qBAAqBxO,EAAUQ,EAAK+N,SAAUpP,GAmBrD,SAASsP,EAAmB7E,EAAM8E,EAAc1D,EAAUC,GACxD,IAAI0D,EAAiB/E,EAAKgF,iBAC1B,GAAID,EAAgB,CAClB,IAAIE,EAAaH,EACjB,KAAO5D,EAAWlB,EAAM+E,EAAgBE,EAAY7D,EAAUC,IAC5DzL,OAAOkB,OAAOsK,EAAUpB,EAAKkF,WAC7BtP,OAAOkB,OAAOgO,EAAc9E,EAAKmF,eACjCF,EAAajF,EAAKmF,cAClBnF,EAAKmF,cAAgB,MAiB3B,SAASC,EAAkBpF,EAAM5J,EAAU+K,EAAOC,EAAUxK,GAC1D,IAAIyO,EAASC,EAAgBtF,EAAM5J,EAAU+K,EAAOC,EAAUxK,GAC1D2O,EAAe3O,EAAK4O,WACpBxF,EAAKyF,mBAAqBzF,EAAKyF,kBAAkBF,GACnDvF,EAAK0F,oBAAoBH,EAAcF,GAAQ,GAE/CrF,EAAKuF,GAAgBF,EAazB,SAASM,EAAmB3F,EAAMkC,EAAM3M,GACtC,IAAIqQ,EAAQ5F,EAAK6F,kBACjB,GAAID,EAAO,CACT,IAAIE,EACJ,IAAK,IAAInG,KAAKiG,EAAO,CACnB,IAAIG,EAAIH,EAAMjG,GACVhJ,QAAQgL,KAAKY,aAAa5C,EAAGuC,IAC/B4D,EAAOnP,QAAQgL,KAAK0C,UAAU1E,EAAGoG,EAAG7D,GACpClC,EAAKwE,0BAA0BsB,EAAMvQ,GAAO,GAAM,IACzCoB,QAAQgL,KAAKY,aAAawD,EAAG7D,KACtC4D,EAAOnP,QAAQgL,KAAK0C,UAAU0B,EAAGpG,EAAGuC,GACpClC,EAAKwE,0BAA0BsB,EAAMvQ,GAAO,GAAM,MAwB1D,SAASyQ,EAAW5J,EAAa6J,EAAcC,EAAUC,EAAM7B,EAAQ8B,EAAOC,GAE5EH,EAASI,SAAWJ,EAASI,aAC7B,IAAIC,GAAYJ,OAAM7B,SAAQ8B,QAAOC,UAASG,WAA8B,IAAjBJ,EAAMtJ,QAGjE,GAFAoJ,EAASI,SAAShI,KAAKiI,GAEnBE,EAAkBF,GAAU,CAC9B,IAAIvC,MAACA,EAADG,OAAQA,GAAUoC,EAAQH,MAAM,GACpCG,EAAQG,cAAgB1C,GAAU1L,EAAQM,gBAAgB0L,GAAU,WACpEiC,EAAQI,eAAiBxC,EAG3B,IAAI5F,EAAQ0H,EAAaW,aAAa9J,OACtC,IAAK,IAAI5H,EAAE,EAAGA,EAAEqR,EAAQH,MAAMtJ,OAAQ5H,IAAK,CACzC,IAAI2R,EAAON,EAAQH,MAAMlR,GACzB2R,EAAKC,cAAgB5R,EACrB6R,EAAwB3K,EAAa6J,EAAcM,EAASM,EAAMtI,IAetE,SAASwI,EAAwB3K,EAAa6J,EAAcM,EAASM,EAAMtI,GACzE,IAAKsI,EAAKR,QACR,GAAqB,cAAjBE,EAAQJ,MAA8C,MAAtBI,EAAQjC,OAAO,GACjDzB,QAAQC,KAAK,wBAA0ByD,EAAQjC,OAC7C,gEACG,CACL,IAAI0C,EAAeH,EAAKG,aACpBpQ,GAAS2H,QAAOgI,UAASM,OAAMI,UAAW7K,GAC9C,IAAK,IAAI8K,EAAE,EAAGA,EAAEF,EAAalK,OAAQoK,IAAK,CACxC,IAAIlF,EAAUgF,EAAaE,GACL,iBAAXlF,KACTA,EAAUmF,EAASnF,IACXM,UAAW,GAErBlG,EAAYgL,2BAA2BnB,EAAcjE,EAAQuB,cAC3DtB,GAAIoF,EACJzQ,OAAMoL,cA0BhB,SAASqF,EAAiBrH,EAAMkC,EAAMf,EAAOC,EAAUxK,EAAMyK,EAAUiG,GACrE,IAAIC,EAAOD,EAAS1Q,EAAK2H,OACrBgI,EAAU3P,EAAK2P,QACfM,EAAOjQ,EAAKiQ,KAGhB,GAAIxF,GAAYwF,EAAKW,QAAWtF,EAAKpF,OAAS+J,EAAKW,OAAO1K,QACrC,YAAhByJ,EAAQJ,OAAwBI,EAAQC,YACzCe,EAAK9B,mBAAqB8B,EAAK9B,kBAAkBc,EAAQjC,QAAS,CACpE,IAAI/O,EAAQ4L,EAAMe,GAClBA,EAAOvL,QAAQgL,KAAK0C,UAAUwC,EAAKW,OAAQjB,EAAQjC,OAAQpC,GACvDqF,EAAK/C,0BAA0BtC,EAAM3M,GAAO,GAAO,IACrDyK,EAAKyH,eAAeF,OAEjB,CACL,IAAIhS,EAAQqB,EAAKqQ,UAAUS,iBAAiB1H,EAAM6G,EAAM3E,EAAMf,EAAOC,EAAUC,GAE/EsG,EAAkB3H,EAAMuH,EAAMhB,EAASM,EAAMtR,IAejD,SAASoS,EAAkB3H,EAAMuH,EAAMhB,EAASM,EAAMtR,GAKpD,GAJAA,EAAQqS,EAAoBL,EAAMhS,EAAOgR,EAASM,GAC9ClQ,QAAQ+N,mBACVnP,EAAQoB,QAAQ+N,iBAAiBnP,EAAOgR,EAAQjC,OAAQiC,EAAQJ,KAAMoB,IAEpD,aAAhBhB,EAAQJ,KAEVnG,EAAK6H,sBAAsBN,EAAMhS,EAAOgR,EAAQjC,YAC3C,CAEL,IAAIpN,EAAOqP,EAAQjC,OACfiD,EAAK9B,mBAAqB8B,EAAK9B,kBAAkBvO,GAC9CqQ,EAAKhD,YAAegD,EAAKhD,WAAWrN,IACnCqQ,EAAK7B,oBAAoBxO,EAAM3B,IACjCyK,EAAKyH,eAAeF,GAIxBvH,EAAK8H,4BAA4BP,EAAMrQ,EAAM3B,IAgBnD,SAASqS,EAAoBL,EAAMhS,EAAOgR,EAASM,GACjD,GAAIN,EAAQC,WAAY,CACtB,IAAIuB,EAAUR,EAAKS,sBAAsBzB,EAAQjC,QACjDyD,EAAQlB,EAAKC,eAAiBvR,EAC9BA,EAAQwS,EAAQE,KAAK,IASvB,MAPqB,cAAjB1B,EAAQJ,OAEa,gBAAnBI,EAAQjC,QACW,SAAlBiD,EAAKW,WAA0C,SAAlB3B,EAAQjC,UACxC/O,OAAiB6D,GAAT7D,EAAqB,GAAKA,GAG/BA,EAgBT,SAASkR,EAAkBF,GACzB,OAAOA,EAAQjC,QACQ,aAAhBiC,EAAQJ,MACQ,QAAhBI,EAAQJ,OACPI,EAAQC,YACiB,MAA1BD,EAAQH,MAAM,GAAG+B,KAW1B,SAASC,EAAcpI,EAAMiG,GAE3B,IAAIqB,SAACA,EAADV,aAAWA,GAAgBX,EAC/B,GAAIW,EAAa9J,OACf,IAAK,IAAI5H,EAAE,EAAGA,EAAI0R,EAAa9J,OAAQ5H,IAAK,CAC1C,IAAI0B,EAAOgQ,EAAa1R,GACpBqS,EAAOD,EAASpS,GAChBoR,EAAW1P,EAAK0P,SACpB,GAAIA,EACF,IAAK,IAAIpR,EAAE,EAAGA,EAAEoR,EAASxJ,OAAQ5H,IAAK,CACpC,IAAIqR,EAAUD,EAASpR,GACvBmT,EAAqBd,EAAMhB,GAC3B+B,EAAkBf,EAAMvH,EAAMuG,GAGlCgB,EAAKlE,WAAarD,GAkBxB,SAASqI,EAAqBd,EAAMhB,GAClC,GAAIA,EAAQC,WAAY,CAEtB,IAAIuB,EAAUR,EAAKS,wBAChBT,EAAKS,0BACJ5B,EAAQG,EAAQH,MAEhBmC,EAAW,IAAIvL,MAAMoJ,EAAMtJ,QAC/B,IAAK,IAAIoK,EAAE,EAAGA,EAAEd,EAAMtJ,OAAQoK,IAC5BqB,EAASrB,GAAKd,EAAMc,GAAGb,QAEzB,IAAI/B,EAASiC,EAAQjC,OACrByD,EAAQzD,GAAUiE,EAEdhC,EAAQF,SAA2B,YAAhBE,EAAQJ,OAC7BoB,EAAKjD,GAAUiC,EAAQF,UAa7B,SAASiC,EAAkBf,EAAMvH,EAAMuG,GACrC,GAAIA,EAAQG,cAAe,CACzB,IAAIG,EAAON,EAAQH,MAAM,GACzBmB,EAAKiB,iBAAiBjC,EAAQG,cAAe,SAAShN,GACpDqK,EAAmBrK,EAAGsG,EAAMuG,EAAQjC,OAAQuC,EAAKW,OAAQX,EAAK1C,WAuBpE,SAASsE,EAAmB3H,EAAO4H,EAAKpN,EAAMqN,EAAUnD,EAAY5C,GAClEA,EAAY8F,EAAIE,QAAWhG,IACH,iBAAdA,GAA0BA,EAAU8F,EAAIjG,aAClD,IAAI7L,GACF6L,WAAYiG,EAAIjG,WAChBoG,KAAMH,EAAIG,KACVrD,aACA5C,aAEF,IAAK,IAAS1F,EAALhI,EAAE,EAASA,EAAEwT,EAAIG,KAAK/L,SAAYI,EAAIwL,EAAIG,KAAK3T,IAAKA,IACtDgI,EAAImJ,SACPvF,EAAMgI,mBAAmB5L,EAAIqG,aAAcjI,GACzC2G,GAAI0G,EAAU/R,KAAMA,EAAMoL,QAAS9E,IAIrC0F,GACF9B,EAAMgI,mBAAmBJ,EAAIjG,WAAYnH,GACvC2G,GAAI0G,EAAU/R,KAAMA,IAqB1B,SAAS0O,EAAgBtF,EAAM5J,EAAU+K,EAAOC,EAAUxK,GAGxD,IAAImS,EAAU/I,EAAKgJ,aAAehJ,EAC9BiC,EAAK8G,EAAQnS,EAAK6L,YACtB,GAAIR,EAAI,CACN,IAAI4G,EAAOI,EAAYjJ,EAAK2C,OAAQ/L,EAAKiS,KAAMzS,EAAU+K,GACzD,OAAOc,EAAGxE,MAAMsL,EAASF,GACfjS,EAAKgM,WACfC,QAAQC,KAAK,WAAalM,EAAK6L,WAAa,iBAwBhD,SAASyG,EAAiB9C,GACxB,IAAI5P,EAAI,GACR,IAAK,IAAItB,EAAE,EAAGA,EAAEkR,EAAMtJ,OAAQ5H,IAAK,CACjC,IAAImR,EAAUD,EAAMlR,GAAGmR,QACvB7P,GAAK6P,GAAW,GAElB,OAAO7P,EAaT,SAAS2S,EAAYC,GAEnB,IAAI/T,EAAI+T,EAAWC,MAAM,0BACzB,GAAIhU,EAAG,CACL,IAAIoN,EAAapN,EAAE,GACfqT,GAAQjG,aAAYmG,QAAQ,GAChC,GAAIvT,EAAE,GAAGiU,OAAQ,CAEf,IAAIT,EAAOxT,EAAE,GAAGqD,QAAQ,OAAQ,WAAW6Q,MAAM,KACjD,OAAOC,EAAUX,EAAMH,GAGvB,OADAA,EAAIG,KAAOY,EACJf,EAGX,OAAO,KAaT,SAASc,EAAUE,EAAShB,GAQ1B,OAPAA,EAAIG,KAAOa,EAAQjS,IAAI,SAASkS,GAC9B,IAAIzM,EAAMiK,EAASwC,GAInB,OAHKzM,EAAImJ,UACPqC,EAAIE,QAAS,GAER1L,GACN0C,MACI8I,EAmBT,SAASvB,EAASwC,GAEhB,IAAIzM,EAAMyM,EAAOL,OAEd5Q,QAAQ,WAAY,KAIpBA,QAAQ,SAAU,MAGjBiH,GACFlK,KAAMyH,GAGJ0M,EAAK1M,EAAI,GAOb,OANW,MAAP0M,IACFA,EAAK1M,EAAI,IAEP0M,GAAM,KAAOA,GAAM,MACrBA,EAAK,KAEAA,GACL,IAAK,IACL,IAAK,IACHjK,EAAEpK,MAAQ2H,EAAIG,MAAM,GAAI,GACxBsC,EAAE0G,SAAU,EACZ,MACF,IAAK,IACH1G,EAAEpK,MAAQsU,OAAO3M,GACjByC,EAAE0G,SAAU,EAehB,OAXK1G,EAAE0G,UACL1G,EAAE4D,aAAe5M,QAAQgL,KAAKC,KAAK1E,GAEnCyC,EAAEyC,WAAazL,QAAQgL,KAAKmI,OAAO5M,GAC/ByC,EAAEyC,aACJzC,EAAE2C,SAA6B,MAAjBpF,EAAIG,OAAO,GACrBsC,EAAE2C,WACJ3C,EAAElK,KAAOyH,EAAIG,MAAM,GAAI,MAItBsC,EAiBT,SAASsJ,EAAYzN,EAAMqN,EAAM3G,EAAMf,GACrC,IAAI4I,KACJ,IAAK,IAAI7U,EAAE,EAAGC,EAAE0T,EAAK/L,OAAQ5H,EAAEC,EAAGD,IAAK,CACrC,IAEI8U,EAFA9M,EAAM2L,EAAK3T,GACXO,EAAOyH,EAAIzH,KAef,GAbIyH,EAAImJ,QACN2D,EAAI9M,EAAI3H,MAEJ2H,EAAIkF,gBAGIhJ,KAFV4Q,EAAIrT,QAAQgL,KAAK3L,IAAIwF,EAAM/F,MAGzBuU,EAAI7I,EAAM1L,IAGZuU,EAAIxO,EAAK/F,GAGTyH,EAAIoF,SAAU,CAGhB,IAAI2H,EAA4C,IAA7BxU,EAAKgD,QAAQyJ,EAAO,KACnCgI,EAAkC,IAAvBhI,EAAKzJ,QAAQhD,KAAgBwU,EAC5CF,EAAO7U,IACLgN,KAAMgI,EAAUhI,EAAOzM,EACvBF,MAAO2U,EAAU/I,EAAMe,GAAQ8H,EAC/B1S,KAAM0S,QAGRD,EAAO7U,GAAK8U,EAGhB,OAAOD,EAgBT,SAASI,EAAcnK,EAAMoK,EAAOlI,EAAMmI,GACxC,IAAIC,EAAcpI,EAAO,WACzBlC,EAAKmD,WAAWmH,GAAeC,aAAcF,IAC7CrK,EAAKmD,WAAWjB,EAAO,UAAWkI,EAAMtN,QAExCkD,EAAK2C,OAAO2H,IAAgBC,aAAc,MAiB5C,SAASC,EAAaxK,EAAMoK,EAAOlI,EAAM3D,EAAOkM,EAAYC,GAC1DP,EAAcnK,EAAMoK,EAAOlI,IACzB3D,MAAOA,EACPkM,WAAYA,EACZC,QAASA,EACTvU,OAAQiU,EACR9O,KAAM,YAWV,SAASqP,EAAMlV,GACb,OAAOA,EAAK,GAAGkD,cAAgBlD,EAAKkF,UAAU,GAl+BhD,MAAMrC,EAAU3B,QAAQ2B,QAIxB,IAAIV,EAAW,EAGf,MAAMgT,GACJC,QAAS,mBACTC,QAAS,mBACTC,OAAQ,kBACRC,UAAW,qBACXC,QAAS,mBACTC,UAAW,cAguBPzB,KAkBA0B,EAAe,IAAIC,OADNC,sYACyB,KAyQ5C1U,QAAQ2U,gBAAkB3U,QAAQkB,cAAc0I,IAQ9C,MAAMgL,EAAsB5U,QAAQ6U,cAAc7U,QAAQ8U,kBAAkBlL,UAOtE+K,UAAwBC,EAE5BG,4BACE,OAAOd,EASTe,wBACEC,MAAMD,wBACNE,EAAUC,aAAalM,MACvBA,KAAKmM,oBAAqB,EAC1BnM,KAAKoM,qBAAuB,KAC5BpM,KAAKqM,eAAiB,KACtBrM,KAAKiG,kBAAoB,KACzBjG,KAAKsM,gBAAiB,EAEtBtM,KAAKoI,sBAAwBpI,KAAKoI,uBAAyB,KAC3DpI,KAAKyD,WAAazD,KAAKyD,YAAc,KACrCzD,KAAKQ,cAUP+L,2BAA2BhL,GACzBvB,KAAK+C,OAAS/M,OAAOsC,OAAOiJ,GAC5BvB,KAAKuF,cAAgBvP,OAAOsC,OAAOiJ,GACnCvB,KAAKsF,aASPkH,8BAA8BjL,GAC5B,IAAIkL,EAAWzM,KAAK2E,WACpB,IAAK,IAAIrN,KAAQiK,EACVkL,GAAaA,EAASnV,KACzB0I,KAAKuF,cAAgBvF,KAAKuF,kBAC1BvF,KAAKsF,UAAYtF,KAAKsF,cACtBtF,KAAK+C,OAAOzL,GAAQ0I,KAAKuF,cAAcjO,GAAQiK,EAAMjK,IAiB3D4R,mBAAmB1S,EAAUkF,EAAMgR,GACjC1M,KAAK2M,wBAAwBnW,EAAUkF,GAAQsP,EAAMM,WAErD,IAAInK,EAAUF,EAAmBjB,KAAMtE,GAAMlF,GACxC2K,IACHA,EAAUnB,KAAKtE,GAAMlF,OAEvB2K,EAAQzC,KAAKgO,GAUfE,sBAAsBpW,EAAUkF,EAAMgR,GACpC,IAAIvL,EAAUF,EAAmBjB,KAAMtE,GAAMlF,GACzCqW,EAAM1L,EAAQtI,QAAQ6T,GACtBG,GAAO,GACT1L,EAAQvC,OAAOiO,EAAK,GAaxBC,mBAAmBtW,EAAUkF,GAC3B,IAAIyF,EAAUnB,KAAKtE,GACnB,OAAOqF,QAAQI,GAAWA,EAAQ3K,IAWpCuW,mBAAmBvW,GACjB,OAAOwJ,KAAK8M,mBAAmBtW,EAAUwU,EAAMM,WAWjD0B,iBAAiBxW,GACf,OAAOwJ,KAAK8M,mBAAmBtW,EAAUwU,EAAMG,QAWjD8B,kBAAkBzW,GAChB,OAAOwJ,KAAK8M,mBAAmBtW,EAAUwU,EAAME,SAWjDgC,mBAAmB1W,GACjB,OAAOwJ,KAAK8M,mBAAmBtW,EAAUwU,EAAMC,SAiCjDrG,0BAA0BtC,EAAM3M,EAAOwX,EAAcC,GACnD,GAAIA,GACArW,QAAQgL,KAAKC,KAAK5E,MAAMiQ,QAAQ/K,GAAQA,EAAK,GAAKA,KAAUA,EAAM,CASpE,IAAK8K,EAAoB,CACvB,IAAI/M,EAAMtJ,QAAQgL,KAAK3L,IAAI4J,KAAMsC,GAGjC,KAFAA,EAA8BvL,QAAQgL,KAAKhK,IAAIiI,KAAMsC,EAAM3M,MAE7CqW,MAAMpL,sBAAsB0B,EAAM3M,EAAO0K,GACrD,OAAO,EAIX,GADAL,KAAKsM,gBAAiB,EAClBtM,KAAK8F,oBAAoBxD,EAAM3M,EAAOwX,GAExC,OADApH,EAAmB/F,KAAMsC,EAAM3M,IACxB,MAEJ,CACL,GAAIqK,KAAK6F,mBAAqB7F,KAAK6F,kBAAkBvD,GACnD,OAAOtC,KAAK8F,oBAAoBxD,EAAM3M,EAAOwX,GAE7CnN,KAAKsC,GAAQ3M,EAGjB,OAAO,EAuBTuS,4BAA4BP,EAAMrQ,EAAM3B,GAKlCA,IAAUgS,EAAKrQ,IAAyB,iBAAT3B,IACjCgS,EAAKrQ,GAAQ3B,GAkCjBmQ,oBAAoBtP,EAAUb,EAAOwX,GACnC,IAAIjD,EAASlK,KAAKsM,gBAAkBvV,QAAQgL,KAAKmI,OAAO1T,GACpD8W,EAAYpD,EAASlK,KAAKQ,WAAaR,KAAK+C,OAChD,GAAI/C,KAAKY,sBAAsBpK,EAAUb,EAAO2X,EAAU9W,IAuBxD,OAtBKwJ,KAAKuF,gBACRvF,KAAKuF,iBACLvF,KAAKsF,cAGD9O,KAAYwJ,KAAKsF,YACrBtF,KAAKsF,UAAU9O,GAAYwJ,KAAK+C,OAAOvM,IAIrC0T,EACFlK,KAAKQ,WAAWhK,GAAYb,EAE5BqK,KAAK+C,OAAOvM,GAAYb,EAG1BqK,KAAKuF,cAAc/O,GAAYb,GAE3BuU,GAAWlK,KAAKsD,iBAAmBtD,KAAKsD,gBAAgB9M,MAC1DwJ,KAAKqM,eAAiBrM,KAAKqM,mBAC3BrM,KAAKqM,eAAe7V,GAAY2W,IAE3B,EAUXI,aAAa/W,EAAUb,GACjBqK,KAAK8F,oBAAoBtP,EAAUb,GAAO,IAC5CqK,KAAK0D,wBAYTA,wBACM1D,KAAKwN,aACPxN,KAAKyN,mBAYT5F,eAAe6F,GACb1N,KAAKoM,qBAAuBpM,KAAKoM,yBAC7BsB,IAAW1N,MACbA,KAAKoM,qBAAqB1N,KAAKgP,GAUnCC,gBACO3N,KAAKmM,mBAQRnM,KAAK4N,0BAPL5N,KAAKmM,oBAAqB,EAC1BnM,KAAK6N,gBAIL7N,KAAKwN,aAAc,GAkBvBI,yBACE,IAAIE,EAAU9N,KAAKoM,qBACnB,GAAI0B,EAAS,CACX9N,KAAKoM,qBAAuB,KAC5B,IAAK,IAAI9W,EAAE,EAAGA,EAAIwY,EAAQ5Q,OAAQ5H,IAAK,CACrC,IAAIoY,EAASI,EAAQxY,GAChBoY,EAAOK,cAEDL,EAAOnI,eAChBmI,EAAOD,mBAFPC,EAAOM,sBAefH,gBACE7N,KAAK4N,yBAiBPK,cAAc1M,EAAO2M,GACnB,IAAK,IAAI5L,KAAQf,GACX2M,GAAgBlO,KAAK2E,YAAe3E,KAAK2E,WAAWrC,IAKtDtC,KAAK4E,0BAA0BtC,EAAMf,EAAMe,IAAO,GAGtDtC,KAAK0D,wBAWPyK,QAKEnO,KAAKyN,mBAGAzN,KAAKmM,oBACRnM,KAAK2N,gBAIH3N,KAAKuF,eACPvF,KAAKyN,mBAYTW,mBAAmBC,EAAcnJ,EAAc1D,GAM7C,IAAIC,EAAWzB,KAAKsM,eACpBtM,KAAKsM,gBAAiB,EAEtBrH,EAAmBjF,KAAMkF,EAAc1D,EAAUC,GAGjD,IAAI2B,EAAcpD,KAAKqM,eACvBrM,KAAKqM,eAAiB,KAEtBrM,KAAKsO,0BAA0BpJ,EAAc1D,EAAUC,GAEvDzB,KAAK2N,gBAELrM,EAAWtB,KAAMA,KAAKuO,iBAAkBrJ,EAAc1D,EAAUC,GAEhEH,EAAWtB,KAAMA,KAAKwO,iBAAkBtJ,EAAc1D,EAAUC,GAE5D2B,GACFD,EAAiBnD,KAAMoD,EAAa8B,EAAc1D,EAAUC,GAGpC,GAAtBzB,KAAKyO,gBACPzO,KAAKQ,eAgBT8N,0BAA0BpJ,EAAc1D,EAAUC,GAC5CzB,KAAK0O,oBACPpN,EAAWtB,KAAMA,KAAK0O,mBAAoBxJ,EAAc1D,EAAUC,GAEpE,IAAI4E,EAAerG,KAAK2O,eACxB,KAAOtI,GACL/E,EAAWtB,KAAMqG,EAAauI,gBAAiB1J,EAAc1D,EAC3DC,EAAU4E,EAAaqB,UACzBrB,EAAeA,EAAawI,iBAYhCC,UAAUC,EAAIC,GACZD,EAAKhY,QAAQgL,KAAKkN,UAAUF,GAC5BC,EAAOjY,QAAQgL,KAAKkN,UAAUD,GAC9BhP,KAAKiG,kBAAoBjG,KAAKiG,sBAC9BjG,KAAKiG,kBAAkB8I,GAAMC,EAY/BE,YAAY5M,GACVA,EAAOvL,QAAQgL,KAAKkN,UAAU3M,GAC1BtC,KAAKiG,0BACAjG,KAAKiG,kBAAkB3D,GAiClCiI,cAAcjI,EAAMmI,GAClB,IAAIzT,KAEJuT,EAAcvK,KADmBjJ,QAAQgL,KAAK3L,IAAI4J,KAAMsC,EAAMtL,GACnCA,EAAKsL,KAAMmI,GAsBxCrU,IAAIkM,EAAMN,GACR,OAAOjL,QAAQgL,KAAK3L,IAAI4L,GAAQhC,KAAMsC,GAuBxCvK,IAAIuK,EAAM3M,EAAOqM,GACXA,EACFjL,QAAQgL,KAAKhK,IAAIiK,EAAMM,EAAM3M,GAExBqK,KAAK2E,YAAe3E,KAAK2E,WAAiCrC,IACzDtC,KAAK4E,0BAA0BtC,EAAM3M,GAAO,IAC9CqK,KAAK0D,wBAoBbhF,KAAK4D,KAAS3G,GACZ,IAAI3E,KACAwT,EAA4BzT,QAAQgL,KAAK3L,IAAI4J,KAAMsC,EAAMtL,GACzDmY,EAAM3E,EAAMtN,OACZkS,EAAM5E,EAAM9L,QAAQ/C,GAIxB,OAHIA,EAAMuB,QACR0N,EAAa5K,KAAMwK,EAAOxT,EAAKsL,KAAM6M,EAAKxT,EAAMuB,WAE3CkS,EAgBTC,IAAI/M,GACF,IAAItL,KACAwT,EAA6BzT,QAAQgL,KAAK3L,IAAI4J,KAAMsC,EAAMtL,GAC1DsY,EAAYvO,QAAQyJ,EAAMtN,QAC1BkS,EAAM5E,EAAM6E,MAIhB,OAHIC,GACF1E,EAAa5K,KAAMwK,EAAOxT,EAAKsL,KAAMkI,EAAMtN,OAAQ,GAAIkS,IAElDA,EAoBTxQ,OAAO0D,EAAMiN,EAAOC,KAAgB7T,GAClC,IAAI3E,KACAwT,EAA6BzT,QAAQgL,KAAK3L,IAAI4J,KAAMsC,EAAMtL,IAG5DuY,EADEA,EAAQ,EACF/E,EAAMtN,OAASuS,KAAKC,OAAOH,GAE3BE,KAAKC,MAAMH,MAGnBA,EAAQ,GAEV,IAAIH,EAAM5E,EAAM5L,OAAO2Q,EAAOC,KAAgB7T,GAI9C,OAHIA,EAAMuB,QAAUkS,EAAIlS,SACtB0N,EAAa5K,KAAMwK,EAAOxT,EAAKsL,KAAMiN,EAAO5T,EAAMuB,OAAQkS,GAErDA,EAgBTO,MAAMrN,GACJ,IAAItL,KACAwT,EAA6BzT,QAAQgL,KAAK3L,IAAI4J,KAAMsC,EAAMtL,GAC1DsY,EAAYvO,QAAQyJ,EAAMtN,QAC1BkS,EAAM5E,EAAMmF,QAIhB,OAHIL,GACF1E,EAAa5K,KAAMwK,EAAOxT,EAAKsL,KAAM,EAAG,GAAI8M,IAEvCA,EAiBTQ,QAAQtN,KAAS3G,GACf,IAAI3E,KACAwT,EAA6BzT,QAAQgL,KAAK3L,IAAI4J,KAAMsC,EAAMtL,GAC1DoY,EAAM5E,EAAMoF,WAAWjU,GAI3B,OAHIA,EAAMuB,QACR0N,EAAa5K,KAAMwK,EAAOxT,EAAKsL,KAAM,EAAG3G,EAAMuB,WAEzCkS,EAeT7L,WAAWjB,EAAM3M,GAEf,IAAIka,EACJ,GAAwB,GAApB5S,UAAUC,OAAa,CAEzB,IAAIlG,KACJrB,EAAQoB,QAAQgL,KAAK3L,IAAI4J,KAAMsC,EAAMtL,GACrC6Y,EAAW7Y,EAAKsL,UAGhBuN,EAFSzS,MAAMiQ,QAAQ/K,GAEZvL,QAAQgL,KAAKkN,UAAU3M,GAEFA,EAE9BtC,KAAK4E,0BAA0BiL,EAAUla,GAAO,GAAM,IACxDqK,KAAK0D,wBAcToM,wBAAwBtZ,EAAUuZ,GAChC/P,KAAKkJ,mBAAmB1S,EAAUwU,EAAMM,WACpCyE,IACF/P,KAAK,OAAS+K,EAAMvU,IAAa,SAASb,GACxCqK,KAAKuN,aAAa/W,EAAUb,KAgBlCqa,wBAAwBxZ,EAAUqM,EAAYG,GAC5C,IAAIhM,GAASR,WAAUqM,aAAYG,aACnChD,KAAKkJ,mBAAmB1S,EAAUwU,EAAMK,SACtChJ,GAAIO,EAAmB5L,OAAMoL,SAAUvM,KAAMW,KAE3CwM,GACFhD,KAAKkJ,mBAAmBrG,EAAYmI,EAAMK,SACxChJ,GAAIO,EAAmB5L,OAAMoL,SAAUvM,KAAMgN,KAenDoN,sBAAsBzG,EAAYxG,GAChC,IAAI8F,EAAMS,EAAYC,GACtB,IAAKV,EACH,MAAM,IAAI3R,MAAM,kCAAoCqS,EAAa,KAEnEX,EAAmB7I,KAAM8I,EAAKkC,EAAMK,QAAS3F,EAAiB,KAAM1C,GAWtEkN,yBAAyB1Z,GACvBwJ,KAAKkJ,mBAAmB1S,EAAUwU,EAAMG,QACtC9I,GAAI6B,EACJlN,MACE4M,UAAWlL,EAAQM,gBAAgBxC,GAAY,WAC/CA,SAAUA,KAahB2Z,yBAAyB3Z,GACvB,IAAI4Z,EAAO1X,EAAQM,gBAAgBxC,GACnB,MAAZ4Z,EAAK,GACPnN,QAAQC,KAAK,YAAc1M,EAAW,qCACpC4Z,EAAO,+GAETpQ,KAAKkJ,mBAAmB1S,EAAUwU,EAAME,SACtC7I,GAAIwC,EACJ7N,MACE+N,SAAUqL,KAiBlBC,wBAAwB7Z,EAAUgT,EAAYxG,GAC5C,IAAI8F,EAAMS,EAAYC,GACtB,IAAKV,EACH,MAAM,IAAI3R,MAAM,kCAAoCqS,EAAa,KAEnEX,EAAmB7I,KAAM8I,EAAKkC,EAAMC,QAASzF,EAAmBhP,EAAUwM,GAwC5EsN,yBAAyB9Z,EAAUkF,EAAMgR,GACvC1M,KAAKvJ,UAAUyS,mBAAmB1S,EAAUkF,EAAMgR,GAYpD4D,8BAA8B9Z,EAAUqM,EAAYG,GAClDhD,KAAKvJ,UAAUuZ,wBAAwBxZ,EAAUqM,EAAYG,GAe/DsN,4BAA4B9G,EAAYxG,GACtChD,KAAKvJ,UAAUwZ,sBAAsBzG,EAAYxG,GAUnDsN,+BAA+B9Z,GAC7BwJ,KAAKvJ,UAAUyZ,yBAAyB1Z,GAkB1C8Z,8BAA8B9Z,EAAUuZ,GACtC/P,KAAKvJ,UAAUqZ,wBAAwBtZ,EAAUuZ,GAUnDO,+BAA+B9Z,GAC7BwJ,KAAKvJ,UAAU0Z,yBAAyB3Z,GAgB1C8Z,8BAA8B9Z,EAAUgT,EAAYxG,GAClDhD,KAAKvJ,UAAU4Z,wBAAwB7Z,EAAUgT,EAAYxG,GAe/DsN,oBAAoBC,GAClB,OAAOvQ,KAAKvJ,UAAU+Z,cAAcD,GA2BtCC,cAAcD,EAAUE,GACtB,IAAIpK,EAAerG,KAAKxD,YAAYkU,eAAeH,GAC/CI,EAAc3Q,KAAK2O,gBAAkBtI,EAGzC,IAAKsK,EACH,IAAK,IAAIrZ,KAAQ+O,EAAauI,gBAC5B5O,KAAK2M,wBAAwBrV,GAGjC,GAAImZ,IAGFpK,EAAerQ,OAAOsC,OAAO+N,GAC7BA,EAAasK,YAAcA,GACtBA,GAAe3Q,KAAK2O,gBAAgB,CACvC,IAAIpR,EAAOyC,KAAK4Q,oBAAsB5Q,KAAK2O,eAG3C,OAFA3O,KAAK4Q,mBAAqBrT,EAAKsR,iBAAmBxI,EAClDA,EAAawK,qBAAuBtT,EAC7B8I,EAGX,OAAOrG,KAAK2O,eAAiBtI,EAe/BiK,kCAAkCjK,EAAc/O,EAAMoV,IACpCrG,EAAayK,UAAYzK,EAAayK,eAC5CxZ,IAAQ,EAClB,IAAI6J,EAAUkF,EAAauI,gBAAkBvI,EAAauI,qBACxCzN,EAAQ7J,GAAQ6J,EAAQ7J,QAC9BoH,KAAKgO,GAsBnBqE,eAAeR,GAGbtE,EAAU+E,aAAahR,MACvB,IAAIiR,EAAMjF,MAAM+E,eAAeR,GAC/BtE,EAAUiF,WAAWlR,MACrB,IAAIqG,EAAerG,KAAKwQ,cAAcD,GAAU,GAIhD,GAFAlK,EAAaqB,SAAWuJ,EAAIvJ,UAEvBrB,EAAasK,YAAa,CAC7B,IAAIQ,EAAQ9K,EAAa+K,cACzB,IAAK,IAAI/a,EAAE4a,EAAII,WAAYhb,EAAGA,EAAEA,EAAEib,YAChCH,EAAMzS,KAAKrI,GAWf,OARA4a,EAAI5K,aAAeA,EAEnBmC,EAAcxI,KAAMqG,GAEhBrG,KAAKwN,aACPlM,EAAWtB,KAAMqG,EAAauI,gBAAiB5O,KAAK+C,OAAQ,MAC1D,EAAOsD,EAAaqB,UAEjBuJ,EAWTM,gBAAgBN,GAEd,IAAI5K,EAAe4K,EAAI5K,aACnBA,EAAawK,uBACfxK,EAAawK,qBAAqBhC,iBAChCxI,EAAawI,kBAEbxI,EAAawI,mBACfxI,EAAawI,iBAAiBgC,qBAC5BxK,EAAawK,sBAEb7Q,KAAK4Q,oBAAsBvK,IAC7BrG,KAAK4Q,mBAAqBvK,EAAawK,sBAEzCxK,EAAawK,qBAAuBxK,EAAawI,iBAAmB,KAEpE,IAAIsC,EAAQ9K,EAAa+K,WACzB,IAAK,IAAI9b,EAAE,EAAGA,EAAE6b,EAAMjU,OAAQ5H,IAAK,CACjC,IAAIqS,EAAOwJ,EAAM7b,GACjBqS,EAAK6J,WAAWC,YAAY9J,IAoBhC2I,0BAA0B3I,EAAMtB,EAAcC,GAC5C,IAAIoL,EAAQ1F,MAAM2F,mBAAmBhK,EAAMtB,EAAcC,GACzD,GAAIqB,EAAKiK,WAAaC,KAAKC,UAAW,CACpC,IAAItL,EAAQxG,KAAK+R,eAAepK,EAAKqK,YAAa3L,GAC9CG,IAIFmB,EAAKqK,YAAc1I,EAAiB9C,IAAU,IAC9CJ,EAAWpG,KAAMqG,EAAcC,EAAU,OAAQ,cAAeE,GAChEkL,GAAQ,GAGZ,OAAOA,EAmBTpB,mCAAmC3I,EAAMtB,EAAcC,EAAUzQ,EAAMF,GACrE,IAAI6Q,EAAQxG,KAAK+R,eAAepc,EAAO0Q,GACvC,GAAIG,EAAO,CAET,IAAIyL,EAAWpc,EACX0Q,EAAO,WACgB,KAAvB1Q,EAAKA,EAAKqH,OAAO,KACnBrH,EAAOA,EAAK4H,MAAM,GAAI,GACtB8I,EAAO,aAGT,IAAIE,EAAU6C,EAAiB9C,GAqB/B,OApBIC,GAAmB,aAARF,GACboB,EAAKuK,aAAarc,EAAM4Q,GAMH,UAAnBkB,EAAKW,WAAsC,UAAb2J,GAChCtK,EAAKuK,aAAaD,EAAU,IAG9BtK,EAAKwK,gBAAgBF,GAKR,aAAT1L,IACF1Q,EAAOkB,QAAQ2B,QAAQC,gBAAgB9C,IAEzCuQ,EAAWpG,KAAMqG,EAAcC,EAAUC,EAAM1Q,EAAM2Q,EAAOC,IACrD,EAEP,OAAOuF,MAAMoG,4BAA4BzK,EAAMtB,EAAcC,EAAUzQ,EAAMF,GAiBjF2a,oCAAoC3I,EAAMtB,EAAcC,GACtD,IAAIoL,EAAQ1F,MAAMqG,6BAA6B1K,EAAMtB,EAAcC,GAE/DwK,EAAYxK,EAASD,aAAayK,UAEtC,IAAK,IAAIlJ,KAAUkJ,EAAW,CAC5B,IAAItK,IAAW+B,KAFN,IAEYX,SAAQR,cAAeQ,KAC5CxB,EAAWpG,KAAMqG,EAAcC,EAAU,WAAY,SAAWsB,EAAQpB,GAE1E,OAAOkL,EAoCTpB,sBAAsBgC,EAAMjM,GAC1B,IAEI5Q,EAFA+Q,KACA+L,EAAY,EAQhB,KAAyC,QAAjC9c,EAAI8V,EAAaiH,KAAKF,KAAiB,CAEzC7c,EAAEkJ,MAAQ4T,GACZ/L,EAAM9H,MAAM+H,QAAS6L,EAAK7U,MAAM8U,EAAW9c,EAAEkJ,SAG/C,IAGI8T,EAAaC,EAAaC,EAH1BpK,EAAO9S,EAAE,GAAG,GACZ8O,EAASxD,QAAQtL,EAAE,IACnBmS,EAASnS,EAAE,GAAGiU,OAEN,KAARnB,IAAgBoK,EAAQ/K,EAAO/O,QAAQ,OAAS,IAClD6Z,EAAc9K,EAAO7M,UAAU4X,EAAQ,GACvC/K,EAASA,EAAO7M,UAAU,EAAG4X,GAC7BF,GAAc,GAEhB,IAAIG,EAAYrJ,EAAY3B,GACxBR,KACJ,GAAIwL,EAAW,CAEb,IAAI3J,KAACA,EAADpG,WAAOA,GAAc+P,EACzB,IAAK,IAAItd,EAAE,EAAGA,EAAE2T,EAAK/L,OAAQ5H,IAAK,CAChC,IAAIgI,EAAM2L,EAAK3T,GACVgI,EAAImJ,SACPW,EAAa1I,KAAKpB,GAGtB,IAAIuV,EAAaxM,EAAawM,YAC1BA,GAAcA,EAAWhQ,IAAe+P,EAAU5J,UACpD5B,EAAa1I,KAAKmE,GAClB+P,EAAU5P,WAAY,QAIxBoE,EAAa1I,KAAKkJ,GAEpBpB,EAAM9H,MACJkJ,SAAQW,OAAMhE,SAAQkO,cAAaG,YAAWxL,eAC9ChD,MAAOsO,IAETH,EAAYhH,EAAagH,UAG3B,GAAIA,GAAaA,EAAYD,EAAKpV,OAAQ,CACxC,IAAIuJ,EAAU6L,EAAKvX,UAAUwX,GACzB9L,GACFD,EAAM9H,MACJ+H,QAASA,IAIf,GAAID,EAAMtJ,OACR,OAAOsJ,EAkBX8J,wBAAwBlQ,EAAM6G,EAAM3E,EAAMf,EAAOC,EAAUC,GACzD,IAAI9L,EAeJ,OAbEA,EADEsR,EAAK2L,UACClN,EAAgBtF,EAAMkC,EAAMf,EAAOC,EAAUyF,EAAK2L,WACjDtQ,GAAQ2E,EAAKW,OACd7Q,QAAQgL,KAAK3L,IAAIgK,EAAM6G,EAAKW,QAEhCnG,GAAY1K,QAAQgL,KAAKmI,OAAO5H,GAC1BvL,QAAQgL,KAAK3L,IAAIgK,EAAMkC,GAEvBlC,EAAK2C,OAAOT,GAGpB2E,EAAK1C,SACP5O,GAASA,GAEJA,GAKX,OAAO+V,IA0BT,IAAIO,GAEF6G,SAEA5G,aAAa9L,GACX,GAAIJ,KAAK8S,MAAM5V,OAAQ,CACrB,IAAIsG,EAAOxD,KAAK8S,MAAM9S,KAAK8S,MAAM5V,OAAO,GACxCsG,EAAKqE,eAAezH,KAIxB4Q,aAAa5Q,GACXJ,KAAK8S,MAAMpU,KAAK0B,IAGlB8Q,WAAW9Q,GACT,IAAI2S,EAAW/S,KAAK8S,MAAM5V,OACtB6V,GAAY/S,KAAK8S,MAAMC,EAAS,IAAM3S,GACxCJ,KAAK8S,MAAMzD,Yb69Bb,SAAUha,EAAQD,EAASH,Gcz+GjCA,EAAQ,GAGR,WAEE,aAaA,SAAS+d,IACP,MAAM7D,EAAM8D,EAAmB/V,OAC/B,IAAK,IAAI5H,EAAI,EAAGA,EAAI6Z,EAAK7Z,IAAK,CAC5B,IAAI4d,EAAKD,EAAmB3d,GAC5B,GAAI4d,EACF,IACEA,IACA,MAAOpZ,GACPqZ,WAAW,KAAQ,MAAMrZ,KAI/BmZ,EAAmBrU,OAAO,EAAGuQ,GAC7BiE,GAAuBjE,EAvBzB,IAGIkE,EAAsB,EACtBD,EAAsB,EACtBH,KACAK,EAAuB,EACvBC,EAAgBxZ,SAASyZ,eAAe,IAC5C,IAAI1c,OAAO2c,iBAAiBT,GAAgBU,QAAQH,GAAgBI,eAAe,IA6BnF5c,QAAQ6c,OASNC,SASEC,MAAMC,GACJ,OACEC,IAAI3R,GAAM,OAAO8Q,WAAW9Q,EAAI0R,IAChCE,OAAQnd,OAAOod,aAAaC,KAAKrd,UAUrCkd,IAAKld,OAAOqc,WAAWgB,KAAKrd,QAO5Bmd,OAAQnd,OAAOod,aAAaC,KAAKrd,SAUnCsd,gBAQEJ,IAAKld,OAAOud,sBAAsBF,KAAKrd,QAOvCmd,OAAQnd,OAAOwd,qBAAqBH,KAAKrd,SAW3Cyd,YAQEP,IAAI3R,GACF,OAAOvL,OAAO0d,oBACZ1d,OAAO0d,oBAAoBnS,GAC3BvL,OAAOqc,WAAW9Q,EAAI,KAQ1B4R,OAAOQ,GACL3d,OAAO4d,mBACL5d,OAAO4d,mBAAmBD,GAC1B3d,OAAOod,aAAaO,KAkB1BE,WASEX,IAAIY,GAGF,OAFArB,EAAcvB,YAAcsB,IAC5BL,EAAmBvU,KAAKkW,GACjBvB,KASTY,OAAOQ,GACL,MAAM5H,EAAM4H,EAASrB,EACrB,GAAIvG,GAAO,EAAG,CACZ,IAAKoG,EAAmBpG,GACtB,MAAM,IAAI1V,MAAM,yBAA2Bsd,GAE7CxB,EAAmBpG,GAAO,ads/G9B,SAAUxX,EAAQD,GejrHxB,IAAIyf,EAGJA,EAAK,WACJ,OAAO7U,QAGR,IAEC6U,EAAIA,GAAKjY,SAAS,mBAAoB,EAAGkY,MAAM,QAC9C,MAAMhb,GAEc,iBAAXhD,SACT+d,EAAI/d,QAONzB,EAAOD,QAAUyf,GfsrHX,SAAUxf,EAAQgG,EAAqBpG,GAE7C,aACAe,OAAOC,eAAeoF,EAAqB,cAAgB1F,OAAO,IACYV,EAAoB,KAO5F,SAAUI,EAAQgG,EAAqBpG,GAE7C,aACqB,IAAI8f,EAAsE9f,EAAoB,GAE1F+f,GAD8E/f,EAAoBoB,EAAE0e,GACrD9f,EAAoB,KACZA,EAAoBoB,EAAE2e,GACtC/f,EAAoB,GAChBA,EAAoB,UgBptHlFggB,UAAgBle,QAAQmE,QAC5Bga,gBAAkB,MAAO,WACzBpU,wBACE,OACEvH,MACEmC,KAAMyZ,OACNxf,MAAO,eAETyB,SACEsE,KAAMyZ,OACNxf,MAAO,IAAemB,OAAOC,QAAQK,WAO7Cge,eAAeC,OAAOJ,EAAQC,GAAID,IhBsuH5B,SAAU5f,EAAQgG,EAAqBpG,GAE7C,aACqB,IAAI8f,EAAsE9f,EAAoB,GAE1FqgB,GAD8ErgB,EAAoBoB,EAAE0e,GACtB9f,EAAoB,KAElGsgB,GADsFtgB,EAAoBoB,EAAEif,GAC7DrgB,EAAoB,KAEnEugB,GADuDvgB,EAAoBoB,EAAEkf,GACtCtgB,EAAoB,UiBjwH9EwgB,UAAiB1e,QAAQmE,QAC7Bga,gBAAkB,MAAO,YACzBpU,wBACE,OACElF,MACEF,KAAM0B,MACNzH,WAKN+f,oBACEC,MAAM,8CACHC,KAAKC,GAAQA,EAAKC,QAClBF,KAAKha,IACJ,MAAMma,EAAWna,EAAKoa,OAAO,CAAClc,EAAExE,IACvBA,EAAI,IAEb0K,KAAKpE,KAAOma,EACZP,EAAA,EAAM3W,UACJnD,KAAM,YACNE,KAAMma,OAOhBX,eAAeC,OAAOI,EAASP,GAAIO,IjB8wH7B,SAAUpgB,EAAQgG,EAAqBpG,GAE7C,akBlyHA,SAASghB,EAAWtgB,GAClB,OAAa,MAATA,OACe6D,IAAV7D,EAAsBugB,EAAeC,EAEtCC,GAAkBA,KAAkBpgB,OAAOL,GAC/CV,EAAAK,EAAA+gB,EAAA,GAAU1gB,GACVV,EAAAK,EAAAghB,EAAA,GAAe3gB,GlB6xHA,IAAI4gB,EAA2CthB,EAAoB,GAC/DohB,EAA8CphB,EAAoB,IAClEqhB,EAAmDrhB,EAAoB,IkBlzH5FkhB,EAAU,gBACVD,EAAe,qBAGfE,EAAiBG,EAAA,EAASA,EAAA,EAAOC,iBAAchd,EAkBnD6B,EAAA,KlB0zHM,SAAUhG,EAAQgG,EAAqBpG,GAE7C,cmBv1HA,SAAAwhB,GACA,IAAIC,EAA8B,iBAAVD,GAAsBA,GAAUA,EAAOzgB,SAAWA,QAAUygB,EAEpFpb,EAAA,MnBy1H6B7F,KAAK6F,EAAqBpG,EAAoB,MAIrE,SAAUI,EAAQgG,EAAqBpG,GAE7C,aACqB,IAAI0hB,EAA4C1hB,EAAoB,IoBh2HrF2hB,EAAe3hB,EAAAK,EAAAqhB,EAAA,GAAQ3gB,OAAO6gB,eAAgB7gB,QAElDqF,EAAA,KpBw2HM,SAAUhG,EAAQgG,EAAqBpG,GAE7C,aqBt1HA,SAAS6hB,EAAUnhB,GACjB,IAAIohB,EAAQrgB,EAAelB,KAAKG,EAAOygB,GACnCY,EAAMrhB,EAAMygB,GAEhB,IACEzgB,EAAMygB,QAAkB5c,EACxB,IAAIyd,GAAW,EACf,MAAOnd,IAET,IAAI2L,EAASyR,EAAqB1hB,KAAKG,GAQvC,OAPIshB,IACEF,EACFphB,EAAMygB,GAAkBY,SAEjBrhB,EAAMygB,IAGV3Q,ErBs0HY,IAAI8Q,EAA2CthB,EAAoB,GqB72HpF4H,EAAc7G,OAAOS,UAGrBC,EAAiBmG,EAAYnG,eAO7BwgB,EAAuBra,EAAYC,SAGnCsZ,EAAiBG,EAAA,EAASA,EAAA,EAAOC,iBAAchd,EA6BnD6B,EAAA,KrBq3HM,SAAUhG,EAAQgG,EAAqBpG,GAE7C,asBn5HA,SAASkiB,EAAexhB,GACtB,OAAOuhB,EAAqB1hB,KAAKG,GAjBnC,IAOIuhB,EAPclhB,OAAOS,UAOcqG,SAavCzB,EAAA,KtBy6HM,SAAUhG,EAAQgG,EAAqBpG,GAE7C,auBx7HA,SAASmiB,EAAQC,EAAMC,GACrB,OAAO,SAASha,GACd,OAAO+Z,EAAKC,EAAUha,KAI1BjC,EAAA,KvBq8HM,SAAUhG,EAAQgG,EAAqBpG,GAE7C,aACqB,IAAIsiB,EAA+CtiB,EAAoB,IwBn9HxFuiB,EAA0B,iBAARC,MAAoBA,MAAQA,KAAKzhB,SAAWA,QAAUyhB,KAGxEzV,EAAOuV,EAAA,GAAcC,GAAY5a,SAAS,iBAE9CvB,EAAA,KxB29HM,SAAUhG,EAAQgG,EAAqBpG,GAE7C,ayB78HA,SAASyiB,EAAa/hB,GACpB,OAAgB,MAATA,GAAiC,iBAATA,EAGjC0F,EAAA,KzB0+HM,SAAUhG,EAAQgG,EAAqBpG,GAE7C,a0BxgIAA,EAAA,GAAee,OAAOkB,Q1BskIhB,SAAU7B,EAAQgG,EAAqBpG,GAE7C,cAoDM,SAAUI,EAAQgG,EAAqBpG,GAE7C,aAEsEA,EAAoB,GACTA,EAAoB,GAC7BA,EAAoB,KAqItF,SAAUI,EAAQgG,EAAqBpG,GAE7C,aACqB,IAAI0iB,EAA6C1iB,EAAoB,GAChBA,EAAoB,IACjBA,EAAoB,IACvBA,EAAoB,IAC5BA,EAAoB,GACdA,EAAoB,IAC3DA,EAAoBW,EAAEyF,EAAqB,IAAK,WAAa,OAAOsc,EAA8C,KA0B7I,SAAUtiB,EAAQD,EAASH,G2B1yIjCI,EAAOD,QAAUH,EAAQ,K3BgzInB,SAAUI,EAAQD,EAASH,GAEjC,cAC4B,SAASwhB,EAAQphB,G4BjzI7CW,OAAOC,eAAeb,EAAS,cAC7BO,OAAO,IAGT,IAMIqM,EAJA4V,EAEJ,SAAgCrgB,GAAO,OAAOA,GAAOA,EAAIjB,WAAaiB,GAAQsgB,QAAWtgB,IAJzEtC,EAAQ,KAUtB+M,EADkB,oBAATyV,KACFA,KACoB,oBAAX3gB,OACTA,YACoB,IAAX2f,EACTA,EAEAphB,EAKT,IAAIoQ,GAAS,EAAImS,EAAA,SAAuB5V,GACxC5M,EAAA,QAAqBqQ,I5BqzIQjQ,KAAKJ,EAASH,EAAoB,IAAKA,EAAoB,IAAII,KAItF,SAAUA,EAAQD,EAASH,GAEjC,a6Bj1IA,SAAS6iB,EAAyB9V,GACjC,IAAIyD,EACAsS,EAAU/V,EAAKhG,OAanB,MAXuB,mBAAZ+b,EACNA,EAAQzY,WACXmG,EAASsS,EAAQzY,YAEjBmG,EAASsS,EAAQ,cACjBA,EAAQzY,WAAamG,GAGtBA,EAAS,eAGHA,EAnBRzP,OAAOC,eAAeb,EAAS,cAC9BO,OAAO,IAERP,EAAA,QAAqB0iB,G7B62If,SAAUziB,EAAQD,I8Bl3IP,SAAS2K,GAAG,IAAIoG,EAAE,6SAA+S,GAAGpG,EAAEvF,KAAK,CAAC,IAAI9E,EAAEqK,EAAEvF,KAAK5E,EAAEmK,EAAE3F,cAAc,OAAO,IAAIxE,EAAEoiB,UAAU7R,EAAEvQ,EAAEqiB,SAAS/a,OAAO,GAAGxH,EAAE4E,YAAY1E,EAAEqiB,SAAS,SAASlY,EAAEmY,MAAM/R,IAAIpM,W9B63Ild,SAAU1E,EAAQD,I+B73IP,SAAS2K,GAAG,IAAIoG,EAAE,kYAA0Y,GAAGpG,EAAEvF,KAAK,CAAC,IAAI9E,EAAEqK,EAAEvF,KAAK5E,EAAEmK,EAAE3F,cAAc,OAAO,IAAIxE,EAAEoiB,UAAU7R,EAAEvQ,EAAEqiB,SAAS/a,OAAO,GAAGxH,EAAE4E,YAAY1E,EAAEqiB,SAAS,SAASlY,EAAEmY,MAAM/R,IAAIpM,W/Bw4I7iB,SAAU1E,EAAQD,EAASH,GgCv4IjCA,EAAQ,GAERA,EAAQ,GAGR,WACE,aAIA,SAASkjB,EAAWvW,GAClB,OAAO5M,EAAQ4M,IAAOwW,EAAUxW,EAAG1I,eAGrC,SAASmf,EAA0BjY,GAC7BA,EAAKkY,cAAc,UACrBrV,QAAQC,KAAK,2CAA4C9C,EAAKwB,IARlE,IAAI5M,KACAojB,WAmCEG,UAAkBnd,YAEtBod,gCAAkC,OAAQ,MAU1ClI,cAAc1O,EAAI6W,GAChB,GAAI7W,EAAI,CACN,IAAInM,EAAI0iB,EAAWvW,GACnB,OAAInM,GAAKgjB,EACAhjB,EAAE6iB,cAAcG,GAElBhjB,EAET,OAAO,KAGTijB,yBAAyB7iB,EAAMwK,EAAK1K,GAC9B0K,IAAQ1K,GACVqK,KAAK2Y,WAeTC,gBAEE,IAAK5Y,KAAK6Y,YAAa,CAGrB,MAAMC,EAAQhiB,OAAOiiB,aAAeA,YAAYC,iBAC9CD,YAAYC,iBAAiBhZ,OAASjG,SAAWiG,KAAKiZ,cAClD7f,EAAMrC,QAAQkE,WAAW9B,WAC7B6G,KAAKkZ,aAAa,cAAgB,GAAIJ,EAAMzf,SAC9C2G,KAAK6Y,YAAc9hB,QAAQkE,WAAWH,YAAY1B,GAEpD,OAAO4G,KAAK6Y,YASdF,SAAS/W,IACPA,EAAKA,GAAM5B,KAAK4B,MAEd5B,KAAK4B,GAAKA,EAIV5M,EAAQ4M,GAAM5B,KACdoY,EAAUxW,EAAG1I,eAAiB8G,KAC9BqY,EAA0BrY,QAKhCuY,EAAU9hB,UAAV,QAAiCzB,EAEjCogB,eAAeC,OAAO,aAAckD,GAGpCxhB,QAAQwhB,UAAYA,MhC84IhB,SAAUljB,EAAQD,EAASH,GiCzgJjCA,EAAQ,GAERA,EAAQ,IAERA,EAAQ,IAERA,EAAQ,IAERA,EAAQ,IAGR,WACE,aAOA,MAAMkkB,EAAgBpiB,QAAQ8J,oBAAoB9J,QAAQmE,eAgGpDke,UAAkBD,EAItBjE,gBAAkB,MAAO,aAEzB3E,sBAAwB,OAAO,KAE/BzP,wBASE,OAMEnF,OACED,KAAM0B,OAORic,IACE3d,KAAMyZ,OACNxf,MAAO,QAST2jB,SACE5d,KAAMyZ,OACNxf,MAAO,SAST4jB,cACE7d,KAAMyZ,OACNxf,MAAO,cAUT6jB,MACE9d,KAAMkB,SACN6C,SAAU,iBAUZuW,QACEta,KAAMkB,SACN6C,SAAU,mBAUZiU,SACEhY,KAAMyZ,OACN1V,SAAU,oBAUZsU,MAAO9J,OAQPwP,mBACE/d,KAAMuO,OACNyP,QAAQ,EACRjN,UAAU,GAUZkN,cACEje,KAAMuO,OACNxK,SAAU,wBAWZma,iBACEle,KAAMuO,OACNtU,MAAO,IAGTkkB,kBACEne,KAAMuO,OACN6P,SAAU,wCAOhBC,uBACE,OAAS,2BAGXvd,cACEwP,QACAhM,KAAKga,eACLha,KAAKia,QAAUC,IACfla,KAAKma,UACLna,KAAKoa,kBAAoB,KACzBpa,KAAKqa,uBACLra,KAAKsa,aAAe,KACpBta,KAAKua,gBAAkB,KACvBva,KAAKwa,mBAAoB,EACzBxa,KAAKya,SAAW,KAChBza,KAAK0a,WAAa,KAClB1a,KAAK2a,eAAiB,KACtB3a,KAAK4a,OAAS,KAGhBC,uBACE7O,MAAM6O,uBACN7a,KAAK8a,cAAe,EACpB,IAAK,IAAIxlB,EAAE,EAAGA,EAAE0K,KAAKga,YAAY9c,OAAQ5H,IACvC0K,KAAK+a,iBAAiBzlB,GAI1BogB,oBAGE,GAFA1J,MAAM0J,oBAEF1V,KAAK8a,aAAc,CACrB9a,KAAK8a,cAAe,EACpB,IAAIE,EAAShb,KAAKwR,WAClB,IAAK,IAAIlc,EAAE,EAAGA,EAAE0K,KAAKga,YAAY9c,OAAQ5H,IACvC0K,KAAKib,iBAAiB3lB,EAAG0lB,IAK/BE,sBAIE,IAAKlb,KAAK4a,OAAQ,CAChB,IAAIrK,EAAWvQ,KAAKuQ,SAAWvQ,KAAKsY,cAAc,YAClD,IAAK/H,EAAU,CAEb,IAAI9Q,EAAW,IAAIgU,iBAAiB,KAClC,IAAIzT,KAAKsY,cAAc,YAIrB,MAAM,IAAInhB,MAAM,0CAHhBsI,EAAS0b,aACTnb,KAAKob,aAMT,OADA3b,EAASiU,QAAQ1T,MAAOqb,WAAW,KAC5B,EAGT,IAAIC,KACJA,EAActb,KAAKqZ,KAAM,EACzBiC,EAActb,KAAKsZ,UAAW,EAC9BgC,EAActb,KAAKuZ,eAAgB,EACnCvZ,KAAK4a,OAAS7jB,QAAQwkB,WAAWC,WAAWjL,EAAUvQ,MACpDM,YAAaN,KAAKM,YAClBmb,aAAa,EACbH,cAAeA,EACfI,gBAAiB,SAASpkB,EAAM3B,GAC9B,IAAIgmB,EAAK3b,KAAKga,YACd,IAAK,IAAS5Z,EAAL9K,EAAE,EAAUA,EAAEqmB,EAAGze,SAAYkD,EAAKub,EAAGrmB,IAAKA,IACjD8K,EAAKsb,gBAAgBpkB,EAAM3B,IAG/BimB,mBAAoB,SAASxb,EAAM9I,EAAM3B,GACvC,GAAIoB,QAAQgL,KAAKuI,QAAQtK,KAAKqZ,GAAI/hB,GAAO,CACvC,IAAIuV,EAAMzM,EAAKJ,KAAKuZ,cAChBjiB,GAAQ0I,KAAKqZ,KACfrZ,KAAKrE,MAAMkR,GAAOlX,GAEpB,IAAI2M,EAAOvL,QAAQgL,KAAK0C,UAAUzE,KAAKqZ,GAAI,SAAWxM,EAAKvV,GAC3D0I,KAAKuD,WAAWjB,EAAM3M,OAK9B,OAAO,EAGTkmB,kBAME,OAAO7b,KAAKyD,WAAW2F,aAAepJ,KAAKyD,WAG7CqY,cAActC,GACZ,IAAIuC,EAAa/b,KAAK6b,kBACtB7b,KAAKya,SAAWjB,IAAwB,mBAARA,EAAqBA,EACnD,WAAa,OAAOuC,EAAWvC,GAAM3b,MAAMke,EAAY9e,aACzD+C,KAAKwa,mBAAoB,EACrBxa,KAAKrE,OACPqE,KAAKgc,iBAAiBhc,KAAKob,UAI/Ba,gBAAgBjG,GACd,IAAI+F,EAAa/b,KAAK6b,kBACtB7b,KAAK0a,WAAa1E,IAA4B,mBAAVA,EAAuBA,EACzD,WAAa,OAAO+F,EAAW/F,GAAQnY,MAAMke,EAAY9e,aAC3D+C,KAAKwa,mBAAoB,EACrBxa,KAAKrE,OACPqE,KAAKgc,iBAAiBhc,KAAKob,UAI/Bc,mBAAmBC,GACjB,OAAO1M,KAAK2M,KAAK,IAAKD,GAGxBE,uBACMrc,KAAK2Z,eACP3Z,KAAKia,QAAUja,KAAK2Z,aACpB3Z,KAAKsa,aAAeta,KAAK2Z,aACzB3Z,KAAKua,gBAAkB+B,YAAYC,OAIvCC,mBAGMxc,KAAKrE,OAASqE,KAAKia,QAAUja,KAAKrE,MAAMuB,QAC1C8C,KAAKgc,iBAAiBhc,KAAKyc,sBAI/BA,uBACEpI,sBAAsB,IAAIrU,KAAK0c,iBAGjCA,gBAIE,IAAIC,EAAgBL,YAAYC,MAC5BK,EAAQ5c,KAAK6Z,kBAAoB8C,EAAgB3c,KAAKua,iBAC1Dva,KAAKsa,aAAe7K,KAAKoN,MAAM7c,KAAKsa,aAAesC,IAAU,EAC7D5c,KAAKia,SAAWja,KAAKsa,aACrBta,KAAKua,gBAAkBoC,EACvB3c,KAAKgc,iBAAiBhc,KAAKob,UAG7B0B,mBACE9c,KAAK2a,eAAiB3a,KAAK0T,SACzB1T,KAAK0T,QAAQ5a,QAAQ,KAAM,KAAK6Q,MAAM,KAG1CoT,eAAeC,GACThd,KAAKrE,QAAUyB,MAAMiQ,QAAQrN,KAAKrE,QACpCsH,QAAQC,KAAK,+CAAgDlD,KAAKrE,OAI/DqE,KAAKid,iBAAiBD,EAAO1a,KAAM0a,EAAOrnB,SAG7CqK,KAAKwa,mBAAoB,EACzBxa,KAAKqc,uBACLrc,KAAKgc,iBAAiBhc,KAAKob,WAI/B8B,sBAAsB5a,GACpB,GAAItC,KAAK2a,eAAgB,CACvBrY,EAAOA,EAAKvH,UAAUuH,EAAKzJ,QAAQ,KAAO,GAC1C,IAAIskB,EAAQnd,KAAK2a,eACjB,IAAK,IAAIrlB,EAAE,EAAGA,EAAE6nB,EAAMjgB,OAAQ5H,IAC5B,GAA+B,IAA3BgN,EAAKzJ,QAAQskB,EAAM7nB,IAGrB,OAFA0K,KAAKwa,mBAAoB,EACzBxa,KAAKgc,iBAAiBhc,KAAKob,SAAUpb,KAAK+T,QACnC,GAUfiI,iBAAiB3Z,EAAI0R,GACnB/T,KAAKoa,kBAAoBrjB,QAAQqmB,UAAUC,SACrCrd,KAAKoa,kBACLrG,EAAQ,EAAIhd,QAAQ6c,MAAMC,QAAQC,MAAMC,GAAShd,QAAQ6c,MAAMe,UAC/DtS,EAAG8R,KAAKnU,OACdjJ,QAAQumB,iBAAiBtd,KAAKoa,mBAUhCmD,SAEEvd,KAAKwa,mBAAoB,EACzBxa,KAAKgc,iBAAiBhc,KAAKob,UAC3BrkB,QAAQymB,QAGVpC,WACOpb,KAAKkb,wBAIVlb,KAAKyd,qBAMLzd,KAAKma,OAAOjd,OAAS,EAErB8C,KAAK0d,sBAAsB1d,KAAKga,YAAY9c,QAE5C8C,KAAKgE,cAAc,IAAIC,YAAY,cACjC0Z,SAAS,EACThgB,UAAU,KAGZqC,KAAKwc,oBAGPiB,qBACE,MAAM9hB,EAAQqE,KAAKrE,UACnB,IAAIiiB,EAAoB,IAAIxgB,MAAMzB,EAAMuB,QACxC,IAAK,IAAI5H,EAAE,EAAGA,EAAEqG,EAAMuB,OAAQ5H,IAC5BsoB,EAAkBtoB,GAAKA,EAGrB0K,KAAK0a,aACPkD,EAAoBA,EAAkB5H,OAAO,CAAC1gB,EAAGuX,EAAKrC,IACpDxK,KAAK0a,WAAW/e,EAAMrG,GAAIuX,EAAKrC,KAG/BxK,KAAKya,UACPmD,EAAkBpE,KAAK,CAACzZ,EAAGoG,IAAMnG,KAAKya,SAAS9e,EAAMoE,GAAIpE,EAAMwK,KAGjE,MAAM0X,EAAoB7d,KAAKqa,uBAC/B,IAAIyD,EAAU,EAEd,MAAMC,EAAQtO,KAAKuO,IAAIJ,EAAkB1gB,OAAQ8C,KAAKia,SACtD,KAAO6D,EAAQC,EAAOD,IAAW,CAC/B,IAAI1d,EAAOJ,KAAKga,YAAY8D,GACxBG,EAAUL,EAAkBE,GAC5BI,EAAOviB,EAAMsiB,GACjBJ,EAAkBI,GAAWH,EACzB1d,GAAQ0d,EAAU9d,KAAKia,SACzB7Z,EAAK0F,oBAAoB9F,KAAKqZ,GAAI6E,GAClC9d,EAAK0F,oBAAoB9F,KAAKsZ,QAASwE,GACvC1d,EAAK0F,oBAAoB9F,KAAKuZ,aAAc0E,GAC5C7d,EAAKqN,oBAELzN,KAAKme,iBAAiBD,EAAMJ,EAASG,GAIzC,IAAK,IAAI3oB,EAAE0K,KAAKga,YAAY9c,OAAO,EAAG5H,GAAGwoB,EAASxoB,IAChD0K,KAAKoe,0BAA0B9oB,GAInCylB,iBAAiBlO,GACf,IAAIzM,EAAOJ,KAAKga,YAAYnN,GAC5B,IAAK,IAAIvX,EAAE,EAAGA,EAAE8K,EAAK6X,SAAS/a,OAAQ5H,IAAK,CACzC,IAAI+oB,EAAKje,EAAK6X,SAAS3iB,GACvB8K,EAAK4B,KAAK1H,YAAY+jB,GAExB,OAAOje,EAGT6a,iBAAiBpO,EAAKmO,GACpB,IAAI5a,EAAOJ,KAAKga,YAAYnN,GAC5BmO,EAAOsD,aAAale,EAAK4B,KAAMhC,MAGjCoe,0BAA0BvR,GACxB,IAAIzM,EAAOJ,KAAK+a,iBAAiBlO,GAC7BzM,GACFJ,KAAKma,OAAOzb,KAAK0B,GAEnBJ,KAAKga,YAAYpb,OAAOiO,EAAK,GAG/B0R,gBAAgBL,EAAMJ,EAASG,GAC7B,IAAI/c,KAIJ,OAHAA,EAAMlB,KAAKqZ,IAAM6E,EACjBhd,EAAMlB,KAAKsZ,SAAWwE,EACtB5c,EAAMlB,KAAKuZ,cAAgB0E,EACpB,IAAIje,KAAK4a,OAAO1Z,GAGzBid,iBAAiBD,EAAMJ,EAASG,GAC9B,IAAI7d,EAAOJ,KAAKma,OAAO9K,MACnBjP,GAGFA,EAAK0F,oBAAoB9F,KAAKqZ,GAAI6E,GAClC9d,EAAK0F,oBAAoB9F,KAAKsZ,QAASwE,GACvC1d,EAAK0F,oBAAoB9F,KAAKuZ,aAAc0E,GAC5C7d,EAAKqN,oBAELrN,EAAOJ,KAAKue,gBAAgBL,EAAMJ,EAASG,GAE7C,IAAIO,EAAYxe,KAAKga,YAAY8D,EAAU,GACvCW,EAAaD,EAAYA,EAAUvG,SAAS,GAAKjY,KAGrD,OAFAA,KAAKwR,WAAW8M,aAAale,EAAK4B,KAAMyc,GACxCze,KAAKga,YAAY8D,GAAW1d,EACrBA,EAITse,kBAAkBC,GAChB,IAAK,IAAIrpB,EAAE,EAAGA,EAAE0K,KAAKga,YAAY9c,OAAQ5H,IACvC0K,KAAKga,YAAY1kB,GAAGopB,kBAAkBC,GAM1C1B,iBAAiB3a,EAAM3M,GACrB,IAAIipB,EAAYtc,EAAK7E,MAAM,GACvBohB,EAAMD,EAAU/lB,QAAQ,KACxBimB,EAAWD,EAAM,EAAID,EAAYA,EAAU7jB,UAAU,EAAG8jB,GAE5D,GAAIC,GAAYC,SAASD,EAAU,IAAK,CACtC,IAAIE,EAAcH,EAAM,EAAI,GAAKD,EAAU7jB,UAAU8jB,EAAI,GAEzD,IAAK7e,KAAKkd,sBAAsB8B,GAAc,CAE5C,IAAIlB,EAAU9d,KAAKqa,oBAAoByE,GACnC1e,EAAOJ,KAAKga,YAAY8D,GAC5B,GAAI1d,EAAM,CACR,IAAI6e,EAAWjf,KAAKqZ,IAAM2F,EAAc,IAAMA,EAAc,IAG5D5e,EAAKwE,0BAA0Bqa,EAAUtpB,GAAO,GAAO,GACvDyK,EAAKqN,oBAGT,OAAO,GAeXyR,eAAeb,GACb,IAAIc,EAAWnf,KAAKof,gBAAgBf,GACpC,OAAOc,GAAYA,EAASnf,KAAKqZ,IAYnCgG,gBAAgBhB,GACd,IAAIc,EAAWnf,KAAKof,gBAAgBf,GACpC,OAAOc,GAAYA,EAASnf,KAAKsZ,SAoBnC8F,gBAAgBf,GACd,OAAOtnB,QAAQwkB,WAAW6D,gBAAgBpf,KAAKuQ,SAAU8N,IAK7DjJ,eAAeC,OAAO+D,EAAUlE,GAAIkE,GAEpCriB,QAAQqiB,UAAYA,MjCihJhB,SAAU/jB,EAAQD,EAASH,GkCvrKjCA,EAAQ,GAERA,EAAQ,GAERA,EAAQ,GAERA,EAAQ,IAERA,EAAQ,GAERA,EAAQ,IAERA,EAAQ,IAGR,WACE,aA+FA8B,QAAQoE,aAAepE,QAAQkB,cAAcP,IAqB3C,SAAS4nB,EAAsBC,GAO7B,OANKA,EAAM7oB,eACTW,0BAA0B,kBAAmBkoB,MAC7CA,EAAMC,gBACJD,EAAM7oB,eAAeW,0BAA0B,aAAckoB,IAC7DA,EAAMze,eAEHye,EAAMC,gBAWf,SAASC,EAAqBF,GAO5B,OANKA,EAAM7oB,eACTW,0BAA0B,iBAAkBkoB,MAC5CA,EAAMG,eACJH,EAAM7oB,eAAeW,0BAA0B,YAAakoB,IAC5DA,EAAMxF,cAEHwF,EAAMG,eAYf,SAASC,EAAkBC,EAAgBre,GACzC,IAAK,IAAI5K,KAAK4K,EAAO,CACnB,IAAIxL,EAAIwL,EAAM5K,GACE,mBAALZ,IACTA,GAAM2F,KAAM3F,IAEd6pB,EAAejpB,GAAKZ,EAEtB,OAAO6pB,EAaT,SAASC,EAAmBN,GAC1B,IAAKA,EAAM7oB,eACTW,0BAA0B,oBAAqBkoB,IAAS,CACxDA,EAAMO,kBACNH,KAAsBL,EAAsBC,IAC5C,IAAIQ,EAAY/pB,OAAO6gB,eAAe0I,EAAM9oB,WAAW+F,YACnDujB,EAAUtpB,qBAAqBupB,IACjCT,EAAMO,kBAAoB9pB,OAAOkB,OAC/BlB,OAAOsC,OAAOunB,EAAmBE,IACjCR,EAAMO,oBAGZ,OAAOP,EAAMO,kBAcf,SAASG,EAAyBV,GAChC,IAAKA,EAAM7oB,eACTW,0BAA0B,0BAA2BkoB,IAAS,CAC9DA,EAAMW,wBAA0B,KAChC,IAAI3e,EAAQse,EAAmBN,GAC/B,IAAK,IAAI5oB,KAAK4K,EAAO,CACnB,IAAIvK,EAAOuK,EAAM5K,GACb,UAAWK,IACbuoB,EAAMW,wBAA0BX,EAAMW,4BACtCX,EAAMW,wBAAwBvpB,GAAKK,IAIzC,OAAOuoB,EAAMW,wBAUf,SAASC,EAAkBZ,GACzB,OAAOA,EAAM7oB,eAAeW,0BAA0B,cAAekoB,IAWvE,SAASa,EAAsBb,GAC7B,IAAIljB,EAAQkjB,EAAM9oB,UACdspB,EAAY/pB,OAAO6gB,eAAexa,GAAOG,YACzCujB,EAAUtpB,qBAAqBupB,GACjCD,EAAUM,WAEZC,EAAcf,GAYhB,SAASe,EAAcf,GACrBA,EAAMgB,aAAc,EACpB,IAAIlkB,EAAQkjB,EAAM9oB,UACd8oB,EAAM7oB,eACRW,0BAA0B,KAAMkoB,KAAWA,EAAMrK,IACjDne,QAAQypB,UAAU7H,SAAStc,GAE7B,IAAIkF,EAAQ+d,EAAsBC,GAC9Bhe,GACFkf,EAAmBpkB,EAAOkF,GAE5B,IAAIwY,EAAY0F,EAAqBF,GACjCxF,GACF2G,EAAkBrkB,EAAO0d,EAAWxY,GAGtC,IAAIgP,EAAWgP,EAAMhP,SACrB,GAAIA,EAAU,CACZ,GAAwB,iBAAbA,EAAuB,CAChC,IAAIoQ,EAAI5mB,SAASK,cAAc,YAC/BumB,EAAE3I,UAAYzH,EACdA,EAAWoQ,OAEXpQ,EAAWA,EAASqQ,WAAU,GAEhCvkB,EAAMwkB,UAAYtQ,GAetB,SAASkQ,EAAmBpkB,EAAOyE,GACjC,IAAK,IAAInK,KAAKmK,EACZggB,EAAyBzkB,EAAO1F,EAAGmK,EAAWnK,GAAImK,GAgBtD,SAAS4f,EAAkBrkB,EAAO0d,EAAWlH,GAC3C,IAAK,IAAIvd,EAAE,EAAGA,EAAIykB,EAAU7c,OAAQ5H,IAClC+G,EAAM4T,sBAAsB8J,EAAUzkB,GAAIud,GA8D9C,SAASiO,EAAyBzkB,EAAOxG,EAAMmB,EAAM+pB,GAE/C/pB,EAAK8iB,WACP9iB,EAAKyV,UAAW,GAOdzV,EAAK8iB,WAAczd,EAAM0Q,mBAAmBlX,IAC9CwG,EAAMgU,wBAAwBxa,EAAMmB,EAAK8iB,SAAUiH,GAEjD/pB,EAAKyV,WAAapQ,EAAM0Q,mBAAmBlX,IAC7CwG,EAAMyT,wBAAwBja,GAAOmB,EAAK8iB,UAExC9iB,EAAKgqB,qBAAuB3kB,EAAM4Q,kBAAkBpX,IACtDwG,EAAM8T,yBAAyBta,GAE7BmB,EAAK0iB,SAAWrd,EAAM2Q,iBAAiBnX,IACzCwG,EAAM6T,yBAAyBra,GAG7BmB,EAAKyI,UACPpD,EAAM2T,wBAAwBna,EAAMmB,EAAKyI,SAAUshB,EAAS/pB,EAAKyI,WAkBrE,SAASwhB,EAAiB5kB,EAAOkU,EAAUlX,EAAS6b,EAAIgM,GAEtD,IAAIxmB,EACF3D,QAAQoqB,YAAYC,gBAAgB7Q,EAAUlX,GAC9CtC,QAAQoqB,YAAYE,qBAAqBnM,GAC3C,GAAIxa,EAAS,CACX,IAAI4mB,EAAQvnB,SAASK,cAAc,SACnCknB,EAAMtP,YAActX,EACpB6V,EAASgR,QAAQjD,aAAagD,EAAO/Q,EAASgR,QAAQlQ,YAEpDva,OAAO0qB,UACT1qB,OAAO0qB,SAASC,gBAAgBlR,EAAU2E,EAAIgM,GAEhD7kB,EAAMmU,cAAcD,GAxUtB,MAAMmR,EAAqB3qB,QAAQ2U,gBAAgBhU,GAEnD,IAAIa,EAAUxB,QAAQ2B,cA8UhBsnB,UAAuB0B,EAU3BlJ,gCACE,IAAKxY,KAAKtJ,eAAeW,0BAA0B,uBAAwB2I,OAAQ,CACjF,IAAI2hB,KACA7gB,EAAa+e,EAAmB7f,MACpC,IAAK,IAAI1I,KAAQwJ,EACf6gB,EAAKjjB,KAAK3H,QAAQ2B,QAAQM,gBAAgB1B,IAE5C0I,KAAK4hB,qBAAuBD,EAE9B,OAAO3hB,KAAK4hB,qBAedtR,kBACO6P,EAAkBngB,OACrBogB,EAAsBpgB,MAyC1BuQ,sBAQE,OAPKvQ,KAAKtJ,eAAeW,0BAA0B,YAAa2I,SAC9DA,KAAK6gB,UAAY9pB,QAAQwhB,UAAUsJ,OAAO7hB,KAAKkV,GAAI,aAIjDlf,OAAO6gB,eAAe7W,KAAKvJ,WAAW+F,YAAY+T,UAE/CvQ,KAAK6gB,UAcdiB,wBACE,IAAK9hB,KAAKtJ,eAAeW,0BAA0B,cAAe2I,OAAQ,CACtE,MAAM3K,EAAS0B,QAAQwhB,UAAUsJ,OAAO7hB,KAAKkV,IAC7ClV,KAAK+hB,YAAc1sB,EAASA,EAAOujB,UACnC5iB,OAAO6gB,eAAe7W,KAAKvJ,WAAW+F,YAAYslB,WAEtD,OAAO9hB,KAAK+hB,YAadhW,wBACEhV,QAAQypB,UAAUwB,gBAClBhiB,KAAKxD,YAAY6jB,WACjB,MAAMyB,EAAa9hB,KAAKxD,YAAYslB,WAGpC,GAAI9hB,KAAK6gB,YAAc7gB,KAAK6gB,UAAUoB,mBAAoB,CACxDjiB,KAAK6gB,UAAUoB,oBAAqB,EACpC,MAAM5oB,EACJyoB,EAAa/qB,QAAQkE,WAAW9B,WAAW2oB,GAAc,GAC3Db,EAAiBjhB,KAAKkiB,UAAWliB,KAAK6gB,UAAWxnB,EAC/C2G,KAAKsI,WAET0D,MAAMD,wBAEN/L,KAAKmiB,SAAWprB,QAAQorB,SACxBniB,KAAK8hB,WAAaA,EAElB,IAAIM,EAAKnC,EAAyBjgB,KAAKxD,aACvC,GAAK4lB,EAGL,IAAK,IAAIzrB,KAAKyrB,EAAI,CAChB,IAAIprB,EAAOorB,EAAGzrB,GAId,IAAKqJ,KAAKtJ,eAAeC,GAAI,CAC3B,IAAIhB,EAA6B,mBAAdqB,EAAKrB,MACtBqB,EAAKrB,MAAMH,KAAKwK,MAChBhJ,EAAKrB,MAGHqK,KAAKqiB,aAAa1rB,GACpBqJ,KAAK8F,oBAAoBnP,EAAGhB,GAAO,GAEnCqK,KAAKrJ,GAAKhB,IAgBlB+f,oBACM5e,OAAO0qB,UAAYxhB,KAAK6gB,WAC1B/pB,OAAO0qB,SAASc,aAAatiB,MAE/BA,KAAKgO,oBASP6M,wBAOA1M,QACMnO,KAAK6gB,YACP7gB,KAAKgC,KAAOhC,KAAK+Q,eAAe/Q,KAAK6gB,WACrC7gB,KAAKuiB,EAAIviB,KAAKgC,KAAKugB,GAErBvW,MAAMmC,QAYRN,gBACM7N,KAAK6gB,YACP7gB,KAAKgC,KAAOhC,KAAKwiB,WAAWxiB,KAAKgC,OAMnCgK,MAAM6B,gBAeR2U,WAAWvR,GACT,IAAIjR,KAAKyiB,aASP,MAAM,IAAItrB,MAAM,8IARhB,GAAI8Z,EAKF,OAJKjR,KAAK0iB,YACR1iB,KAAKyiB,cAAcla,KAAM,SAE3BvI,KAAK0iB,WAAWpoB,YAAY2W,GACrBjR,KAAK0iB,WAqBlBhK,yBAAyB7iB,EAAMwK,EAAK1K,GAClC,GAAI0K,IAAQ1K,EAAO,CACjB,IAAIa,EAAW+B,EAAQI,gBAAgB9C,GACnC6F,EAAOmkB,EAAmB7f,KAAKxD,aAAahG,GAAUkF,KACrDsE,KAAK+M,mBAAmBvW,IAC3BwJ,KAAK2iB,qBAAqB9sB,EAAMF,EAAO+F,IAqB7CknB,aAAa9hB,GACPhK,OAAO0qB,UACT1qB,OAAO0qB,SAASqB,aAAa7iB,KAAMc,GAevC3H,WAAWC,EAAK1B,GAId,OAHKA,GAAQsI,KAAK8hB,aAChBpqB,EAAOX,QAAQkE,WAAW9B,WAAW6G,KAAK8hB,aAErC/qB,QAAQkE,WAAW9B,WAAWC,EAAK1B,GAW5C4Y,6BAA6BC,EAAUlK,EAAcC,GAEnD,OADAD,EAAawM,WAAaxM,EAAawM,YAAcgN,EAAmB7f,MACjEgM,MAAM8W,sBAAsBvS,EAAUlK,EAAcC,IAK/D,OAAO0Z,IAWTjpB,QAAQypB,WAKNwB,cAAe,EAKfe,iBAKAC,QAAS,SAASvsB,GAChBwM,QAAQggB,IAAI,IAAMxsB,EAAUye,GAAK,kBAOnCyD,SAAU,SAASliB,GACjBuJ,KAAK+iB,cAAcrkB,KAAKjI,GACxBM,QAAQksB,KAAOjjB,KAAKgjB,QAAQvsB,IAM9BysB,kBAAmB,WACjBljB,KAAK+iB,cAAcI,QAAQnjB,KAAKgjB,WAoBpCjsB,QAAQ6rB,aAAe,SAASrhB,GAC1BzK,OAAO0qB,UACT1qB,OAAO0qB,SAAS4B,cAAc7hB,IAclCxK,QAAQorB,SAAWprB,QAAQorB,UACzBprB,QAAQkE,WAAWH,YAAYf,SAASV,SAAWvC,OAAOkD,SAASH,UlCyqKjE,SAAUxE,EAAQD,EAASH,GmClgMjCA,EAAQ,GAERA,EAAQ,GAERA,EAAQ,GAERA,EAAQ,IAGR,WAEE,aAgCA,SAASouB,EAAkBniB,EAAO1K,GAEhC,IAAK8sB,EAAiB9sB,GAAW,CAC/B,IAAIb,EAAQuL,EAAM1K,QACJgD,IAAV7D,IACEuL,EAAM6B,OAGR7B,EAAM4E,oBAAoBtP,EAAUb,IAG/BuL,EAAMqiB,YAECriB,EAAMxK,eAAeW,0BAA0B,cAAe6J,MACxEA,EAAMqiB,YAAcvtB,OAAOsC,OAAO4I,EAAMqiB,cAFxCriB,EAAMqiB,eAIRriB,EAAMqiB,YAAY/sB,GAAYb,KA9CtC,IAAI4C,EAAUxB,QAAQ2B,QAElB8qB,EAAYzsB,QAAQ6c,MAAMe,UAK9B,MAAM2O,KACN,IAAIjnB,EAAQjB,YAAY3E,UACxB,KAAO4F,GAAO,CACZ,IAAIkF,EAAQvL,OAAOytB,oBAAoBpnB,GACvC,IAAK,IAAI/G,EAAE,EAAGA,EAAEiM,EAAMrE,OAAQ5H,IAC5BguB,EAAiB/hB,EAAMjM,KAAM,EAE/B+G,EAAQrG,OAAO6gB,eAAexa,GA2DhCtF,QAAQ8U,kBAAoB9U,QAAQkB,cAAc0I,UAO1CkL,UAA0BlL,EAU9B2P,uCACE,IAAIoT,EAAK1jB,KAAKwY,mBACd,IAAK,IAAIljB,EAAE,EAAGA,EAAIouB,EAAGxmB,OAAQ5H,IAC3B0K,KAAKvJ,UAAUkW,wBAAwBpU,EAAQI,gBAAgB+qB,EAAGpuB,KAItEkH,cACEwP,QACAhM,KAAK+L,wBAGP2M,yBAAyB7iB,EAAMwK,EAAK1K,GAC9B0K,IAAQ1K,GACVqK,KAAK2iB,qBAAqB9sB,EAAMF,GAYpCoW,wBACE/L,KAAK2jB,eAAgB,EACrB3jB,KAAKyO,cAAgB,EACrBzO,KAAK+N,eAAgB,EACrB/N,KAAKwN,aAAc,EACnBxN,KAAK4jB,eAAgB,EAErB5jB,KAAK+C,UACL/C,KAAKuF,cAAgB,KACrBvF,KAAKsF,UAAY,KACbtF,KAAKujB,cACPvjB,KAAKuM,2BAA2BvM,KAAKujB,aACrCvjB,KAAKujB,YAAc,MAKrB,IAAK,IAAI5sB,KAAKqJ,KAAK6F,kBACb7F,KAAKtJ,eAAeC,KACtBqJ,KAAK6jB,oBAAsB7jB,KAAK6jB,wBAChC7jB,KAAK6jB,oBAAoBltB,GAAKqJ,KAAKrJ,UAC5BqJ,KAAKrJ,IAiBlB4V,2BAA2BhL,GACzB,IAAK,IAAI5K,KAAK4K,EACZvB,KAAKuN,aAAa5W,EAAG4K,EAAM5K,IAgB/B6V,8BAA8BjL,GAC5BvL,OAAOkB,OAAO8I,KAAMuB,GAWtBuiB,iBAAiBC,EAAWpuB,GACrBqK,KAAKgkB,aAAaD,IACrB/jB,KAAKiI,sBAAsBjI,KAAMrK,EAAOouB,GAc5CpB,qBAAqBoB,EAAWpuB,EAAO+F,GAErC,IAAKsE,KAAK2jB,cAAe,CACvB,IAAIntB,EAAW+B,EAAQI,gBAAgBorB,GACvC/jB,KAAKxJ,GAAYwJ,KAAKikB,kBAAkBtuB,EAAO+F,IAWnDsJ,qBAAqBxO,EAAUutB,EAAWpuB,GACxCqK,KAAK2jB,eAAgB,EACrBhuB,EAASsH,UAAUC,OAAS,EAAK8C,KAAKxJ,GAAYb,EAClDqK,KAAKiI,sBAAsBjI,KAAMrK,EAC/BouB,GAAaxrB,EAAQS,gBAAgBxC,IACvCwJ,KAAK2jB,eAAgB,EAevB1b,sBAAsBN,EAAMhS,EAAOouB,GACjC,IAAIG,EAAMlkB,KAAKmkB,gBAAgBxuB,QACnB6D,IAAR0qB,EACFvc,EAAKwK,gBAAgB4R,GAErBpc,EAAKuK,aAAa6R,EAAWG,GAcjCC,gBAAgBxuB,GAEd,cAAeA,GACb,IAAK,UACH,OAAOA,EAAQ,QAAK6D,EAEtB,IAAK,SACH,GAAI7D,aAAiByuB,KACnB,OAAOzuB,EAAMmH,WACR,GAAInH,EACT,IACE,OAAO0uB,KAAKC,UAAU3uB,GACtB,MAAM4uB,GACN,MAAO,GAIb,QACE,OAAgB,MAAT5uB,EAAgBA,EAAMmH,gBAAatD,GAqBhDyqB,kBAAkBtuB,EAAO+F,GAIvB,IAAI8oB,EACJ,OAAQ9oB,GACN,KAAKuO,OACHua,EAAWva,OAAOtU,GAClB,MAEF,KAAKoL,QACHyjB,EAAsB,OAAV7uB,EACZ,MAEF,KAAKK,OACH,IACEwuB,EAAWH,KAAKI,MAAM9uB,GACtB,MAAM4uB,IAGR,MAEF,KAAKnnB,MACH,IACEonB,EAAWH,KAAKI,MAAM9uB,GACtB,MAAM4uB,GACNC,EAAW,KACXvhB,QAAQC,4DAA4DvN,KAEtE,MAEF,KAAKyuB,KACHI,EAAW,IAAIJ,KAAKzuB,GACpB,MAEF,KAAKwf,OACL,QACEqP,EAAW7uB,EAIf,OAAO6uB,EAyBT7X,wBAAwBnW,EAAUiW,GAC3BzM,KAAKtJ,eAAe,uBACvBsJ,KAAK6F,kBAAoB7P,OAAOkB,UAAW8I,KAAK6F,oBAE7C7F,KAAK6F,kBAAkBrP,KAC1BwJ,KAAK6F,kBAAkBrP,IAAY,EACnC6sB,EAAkBrjB,KAAMxJ,GACxBR,OAAOC,eAAe+J,KAAMxJ,GAC1BJ,IAAK,WACH,OAAO4J,KAAK+C,OAAOvM,IAErBuB,IAAK0U,EAAW,aAAiB,SAAS9W,GACxCqK,KAAKuN,aAAa/W,EAAUb,OAYpC0sB,aAAa7rB,GACX,OAAOwJ,KAAK6F,mBAAqB7F,KAAK6F,kBAAkBrP,GAW1D+W,aAAa/W,EAAUb,GACjBqK,KAAK8F,oBAAoBtP,EAAUb,IACrCqK,KAAK0D,wBAeToC,oBAAoBtP,EAAUb,GAC5B,IAAI0K,EAAML,KAAK+C,OAAOvM,GACtB,GAAIwJ,KAAKY,sBAAsBpK,EAAUb,EAAO0K,GAW9C,OAVKL,KAAKuF,gBACRvF,KAAKuF,iBACLvF,KAAKsF,cAGD9O,KAAYwJ,KAAKsF,YACrBtF,KAAKsF,UAAU9O,GAAY6J,GAE7BL,KAAK+C,OAAOvM,GAAYb,EACxBqK,KAAKuF,cAAc/O,GAAYb,GACxB,EAWX+uB,mBAAmBptB,GACjB,OAAO0I,KAAKuF,eAAkBjO,KAAQ0I,KAAKuF,cAS7C7B,yBACO1D,KAAK4jB,eAAiB5jB,KAAKwN,cAC9BxN,KAAK4jB,eAAgB,EACrBJ,EAAUxP,IAAI,KACRhU,KAAK4jB,gBACP5jB,KAAK4jB,eAAgB,EACrB5jB,KAAKyN,uBAcbO,oBACOhO,KAAK+N,gBACR/N,KAAK+N,eAAgB,EACjB/N,KAAK6jB,sBACP7jB,KAAKwM,8BAA8BxM,KAAK6jB,qBACxC7jB,KAAK6jB,oBAAsB,MAE7B7jB,KAAKmO,SAaTV,mBACE,GAAIzN,KAAKuF,cAAe,CACtB,IAAIL,EAAelF,KAAKuF,cACxBvF,KAAKuF,cAAgB,KACrBvF,KAAKyO,gBACLzO,KAAKoO,mBAAmBpO,KAAK+C,OAAQmC,EAAclF,KAAKsF,WACxDtF,KAAKyO,iBAkBTN,QACEnO,KAAKwN,aAAc,EAEnBxN,KAAKyN,mBAcPW,mBAAmBC,EAAcnJ,EAAc1D,IAsB/CZ,sBAAsBpK,EAAUb,EAAO0K,GACrC,OAEGA,IAAQ1K,IAEP0K,IAAQA,GAAO1K,IAAUA,IAMjC,OAAOkW,QnCygML,SAAUxW,EAAQD,EAASH,GoCtkNjCA,EAAQ,GAERA,EAAQ,GAGR,WAEE,aAaA,SAAS0vB,EAAsBhd,GAC7B,IAAIuN,EAAKvN,EAAKuR,aAAa,MAC3B,GAAIhE,GAAM0P,EAAmB1P,GAAK,CAChC,IAAIyL,EAAIhZ,EAKR,IAJAgZ,EAAExO,gBAAgB,MAClBxK,EAAOgZ,EAAE1H,cAAc7e,cAAc8a,GACrCyL,EAAEnP,WAAWqT,aAAald,EAAMgZ,GAChChZ,EAAKrN,YAAYqmB,GACXA,EAAEmE,WAAW5nB,QACjByK,EAAKuK,aAAayO,EAAEmE,WAAW,GAAGjvB,KAAM8qB,EAAEmE,WAAW,GAAGnvB,OACxDgrB,EAAExO,gBAAgBwO,EAAEmE,WAAW,GAAGjvB,MAGtC,OAAO8R,EAGT,SAASod,EAAiB/iB,EAAMsE,GAE9B,IAAI0U,EAAS1U,EAAS0e,YAAcD,EAAiB/iB,EAAMsE,EAAS0e,YAEpE,IAAIhK,EASF,OAAOhZ,EANP,IAAK,IAAI3L,EAAE2kB,EAAO3J,WAAY/b,EAAE,EAAGe,EAAGA,EAAEA,EAAEib,YACxC,GAAIhL,EAAS2e,cAAgB3vB,IAC3B,OAAOe,EASf,SAAS6uB,EAAa9kB,EAAMvI,EAAK8P,EAAMrB,GACjCA,EAAS1E,KACX/J,EAAIyO,EAAS1E,IAAM+F,GAKvB,SAASwd,EAAmB/kB,EAAMuH,EAAMrB,GACtC,GAAIA,EAAS8e,QAAU9e,EAAS8e,OAAOloB,OACrC,IAAK,IAA6BpD,EAAzBwN,EAAE,EAAG+d,EAAG/e,EAAS8e,OAAY9d,EAAE+d,EAAGnoB,SAAYpD,EAAEurB,EAAG/d,IAAKA,IAC/DlH,EAAKklB,8BAA8B3d,EAAM7N,EAAEjE,KAAMiE,EAAEnE,MAAOyK,GAMhE,SAASmlB,EAAqBnlB,EAAMuH,EAAMrB,GACpCA,EAASD,eACXsB,EAAK6d,cAAgBlf,EAASD,cAIlC,SAASof,EAAuBtc,EAASvF,EAAWf,GAWlD,OARAsG,EAAUA,EAAQC,aAAeD,EACnB,SAASrP,GACjBqP,EAAQtG,GACVsG,EAAQtG,GAAY/I,EAAGA,EAAEgK,QAEzBb,QAAQC,KAAK,oBAAsBL,EAAa,kBApEtD,MAAM+hB,GACJc,UAAU,EACVC,cAAc,GAqFhB5uB,QAAQ6U,cAAgB7U,QAAQkB,cAAc0I,UAMtCiL,UAAsBjL,EA6E1B2P,sBAAsBC,EAAUqV,GAE9B,IAAKrV,EAASiV,cAAe,CAC3B,IAAInf,EAAekK,EAASiV,iBAC5Bnf,EAAaW,gBACbX,EAAawf,gBACVD,GAAqBA,EAAkBC,iBACxCtV,EAASyT,aAAa,oBACxBhkB,KAAK8iB,sBAAsBvS,EAAUlK,GAAe2U,OAAQ,OAE9D,OAAOzK,EAASiV,cAGlBlV,6BAA6BC,EAAUlK,EAAcC,GACnD,OAAOtG,KAAK2R,mBAAmBpB,EAASgR,QAASlb,EAAcC,GAgBjEgK,0BAA0B3I,EAAMtB,EAAcC,GAC5C,IAAIoL,EAaJ,MAZsB,YAAlB/J,EAAKW,WAA4BX,EAAKqc,aAAa,oBAEzB,SAAnBrc,EAAKW,YAEdjC,EAAayf,mBAAoB,GAHjCpU,EAAQ1R,KAAKqS,6BAA6B1K,EAAMtB,EAAcC,IAAaoL,EAKzE/J,EAAK0J,aACPK,EAAQ1R,KAAK+lB,yBAAyBpe,EAAMtB,EAAcC,IAAaoL,GAErE/J,EAAKqe,eAAiBre,EAAKqe,kBAC7BtU,EAAQ1R,KAAKimB,6BAA6Bte,EAAMtB,EAAcC,IAAaoL,GAEtEA,EAeTpB,gCAAgCtO,EAAMqE,EAAcC,GAClD,IAAK,IAAyC3G,EAArCgI,EAAK3F,EAAKqP,WAAY4T,EAAY,EAAStd,EAAMA,EAAKhI,EAAM,CAUnE,GARsB,YAAlBgI,EAAKW,YACPX,EAAOgd,EAAsBhd,IAM/BhI,EAAOgI,EAAK2J,YACR3J,EAAKiK,WAAaC,KAAKC,UAAW,CACpC,IAAIzb,EAAIsJ,EACR,KAAOtJ,GAAMA,EAAEub,WAAaC,KAAKC,WAC/BnK,EAAKqK,aAAe3b,EAAE2b,YACtBrS,EAAOtJ,EAAEib,YACTtP,EAAKyP,YAAYpb,GACjBA,EAAIsJ,EAGN,GAAI0G,EAAawf,kBAAoBle,EAAKqK,YAAYtI,OAAQ,CAC5D1H,EAAKyP,YAAY9J,GACjB,UAGJ,IAAIue,GAAcjB,cAAaD,WAAY1e,GACvCtG,KAAK2R,mBAAmBhK,EAAMtB,EAAc6f,KAC9CA,EAAUC,UAAY9f,EAAaW,aAAatI,KAAKwnB,GAAa,GAGhEve,EAAK6J,YACPyT,KAsBN3U,oCAAoC3I,EAAMie,EAAmBtf,GAC3D,IAAID,EAAerG,KAAK0Q,eAAe/I,EAAMie,GAK7C,OAJcvf,EAAakb,QACzB5Z,EAAK4Z,QAAQtI,cAAcmN,0BACrB9rB,YAAYqN,EAAK4Z,SACzBjb,EAASD,aAAeA,GACjB,EAaTiK,oCAAoC3I,EAAMtB,EAAcC,GAGtD,IAAIoL,EACA2U,EAAQjpB,MAAM4R,KAAKrH,EAAKmd,YAC5B,IAAK,IAAsB/kB,EAAlBzK,EAAE+wB,EAAMnpB,OAAO,EAAO6C,EAAEsmB,EAAM/wB,GAAKA,IAC1Coc,EAAQ1R,KAAKoS,4BAA4BzK,EAAMtB,EAAcC,EAAUvG,EAAElK,KAAMkK,EAAEpK,QAAU+b,EAE7F,OAAOA,EAkBTpB,mCAAmC3I,EAAMtB,EAAcC,EAAUzQ,EAAMF,GAErE,MAAyB,QAArBE,EAAK4H,MAAM,EAAG,IAChBkK,EAAKwK,gBAAgBtc,GACrByQ,EAAS8e,OAAS9e,EAAS8e,WAC3B9e,EAAS8e,OAAO1mB,MACd7I,KAAMA,EAAK4H,MAAM,GACjB9H,WAEK,GAGS,OAATE,GACPyQ,EAAS1E,GAAKjM,GACP,QAFJ,EAgBP2a,2BAA2BC,GACzB,IAAIlK,EAAekK,EAAS5B,eAC5B,OAAQtI,GAAgBA,EAAakb,SAAYhR,EAASgR,QAyB5DxQ,eAAeR,GAETA,IAAaA,EAASgR,SACtBzqB,OAAOwvB,qBAAuBA,oBAAoBC,UACpDD,oBAAoBC,SAAShW,GAE/B,IAAIlK,EAAerG,KAAKxD,YAAYkU,eAAeH,GAC/CjK,EAAWD,EAAaW,aACxBua,EAAUlb,EAAakb,SAAWhR,EAASgR,QAC3CtQ,EAAMlX,SAASysB,WAAWjF,GAAS,GAEvCtQ,EAAIwV,oBAAsBpgB,EAAayf,kBACvC,IAAI3U,EAAQF,EAAIvJ,SAAW,IAAItK,MAAMkJ,EAASpJ,QAC9C+T,EAAIsR,KACJ,IAAK,IAA4BvrB,EAAxB1B,EAAE,EAAGC,EAAE+Q,EAASpJ,OAAe5H,EAAEC,IAAOyB,EAAKsP,EAAShR,IAAKA,IAAK,CACvE,IAAIqS,EAAOwJ,EAAM7b,GAAKyvB,EAAiB9T,EAAKja,GAC5CkuB,EAAallB,KAAMiR,EAAIsR,EAAG5a,EAAM3Q,GAChCuuB,EAAqBvlB,KAAM2H,EAAM3Q,GACjCmuB,EAAmBnlB,KAAM2H,EAAM3Q,GAEjC,OAAOia,EAgBTqU,8BAA8B3d,EAAM/D,EAAWf,EAAYsG,GAEzD,IAAIud,EAAUjB,EADdtc,EAAUA,GAAWxB,EACyB/D,EAAWf,GAEzD,OADA7C,KAAK2mB,wBAAwBhf,EAAM/D,EAAW8iB,GACvCA,EAUTC,wBAAwBhf,EAAM/D,EAAW8iB,GACvC/e,EAAKiB,iBAAiBhF,EAAW8iB,GAUnCE,6BAA6Bjf,EAAM/D,EAAW8iB,GAC5C/e,EAAKkf,oBAAoBjjB,EAAW8iB,IAKxC,OAAO9a,QpC2kNL,SAAUvW,EAAQD,EAASH,GqC5hOjCA,EAAQ,GAERA,EAAQ,GAERA,EAAQ,IAGR,WACE,mBAKMmoB,EACJ5gB,cACEwD,KAAK8mB,aAAe,KACpB9mB,KAAK+mB,UAAY,KACjB/mB,KAAKgnB,OAAS,KAUhBC,UAAUC,EAAatS,GACrB5U,KAAK8mB,aAAeI,EACpBlnB,KAAK+mB,UAAYnS,EACjB5U,KAAKgnB,OAAShnB,KAAK8mB,aAAa9S,IAAI,KAClChU,KAAKgnB,OAAS,KACdhnB,KAAK+mB,cAMT9S,SACMjU,KAAKmnB,aACPnnB,KAAK8mB,aAAa7S,OAAOjU,KAAKgnB,QAC9BhnB,KAAKgnB,OAAS,MAMlBxJ,QACMxd,KAAKmnB,aACPnnB,KAAKiU,SACLjU,KAAK+mB,aAQTI,WACE,OAAsB,MAAfnnB,KAAKgnB,OAgCd1W,gBAAgB8W,EAAWF,EAAatS,GAOtC,OANIwS,aAAqBhK,EACvBgK,EAAUnT,SAEVmT,EAAY,IAAIhK,EAElBgK,EAAUH,UAAUC,EAAatS,GAC1BwS,GAOXrwB,QAAQqmB,UAAYA,MrCoiOhB,SAAU/nB,EAAQD,EAASH,GsC7oOjCA,EAAQ,GAGR,WACE,aAcA,SAASoyB,IACP,MAAMC,EAAWvmB,QAAQwmB,EAAerqB,QACxC,KAAOqqB,EAAerqB,QACpB,IACEqqB,EAAe5X,QAAQ6N,QACvB,MAAM1jB,GACNqZ,WAAW,KACT,MAAMrZ,IAIZ,OAAOwtB,EAvBT,IAAIC,KAQJxwB,QAAQumB,iBAAmB,SAAS8J,GAClCG,EAAe7oB,KAAK0oB,IAwBtBrwB,QAAQymB,MAAQ,WACd,IAAIgK,EAAUC,EACd,GACED,EAAW1wB,OAAO4wB,UAAYA,SAASlK,QACnC1mB,OAAO0qB,UAAY1qB,OAAO0qB,SAASmG,aACrC7wB,OAAO0qB,SAASmG,YAAYnK,QAE9BiK,EAAaJ,UACNG,GAAYC,QtCqpOnB,SAAUpyB,EAAQD,EAASH,GuCpsOjCA,EAAQ,GAGR,WACE,aASA,MAAM8M,GAgBJmI,OAAQ,SAAS5H,GACf,OAAOA,EAAKzJ,QAAQ,MAAQ,GAiB9BmJ,KAAM,SAASM,GACb,IAAIslB,EAAWtlB,EAAKzJ,QAAQ,KAC5B,OAAkB,IAAd+uB,EACKtlB,EAEFA,EAAK7E,MAAM,EAAGmqB,IAoBvBnlB,WAAY,SAAS/K,EAAM4K,GAEzB,OAAoC,IAA7B5K,EAAKmB,QAAQyJ,EAAO,MAmB7BK,aAAc,SAASjL,EAAM4K,GAE3B,OAAoC,IAA7BA,EAAKzJ,QAAQnB,EAAO,MAqB7B+M,UAAW,SAAS/M,EAAMmwB,EAASvlB,GACjC,OAAOulB,EAAUvlB,EAAK7E,MAAM/F,EAAKwF,SAGnCoN,QAAS,SAAS5S,EAAM4K,GACtB,OAAQ5K,IAAS4K,GACVtC,KAAKyC,WAAW/K,EAAM4K,IACtBtC,KAAK2C,aAAajL,EAAM4K,IAkBjC2M,UAAW,SAAS3M,GAClB,GAAIlF,MAAMiQ,QAAQ/K,GAAO,CACvB,IAAIkE,KACJ,IAAK,IAAIlR,EAAE,EAAGA,EAAEgN,EAAKpF,OAAQ5H,IAAK,CAChC,IAAI2T,EAAO3G,EAAKhN,GAAGwH,WAAW6M,MAAM,KACpC,IAAK,IAAIrC,EAAE,EAAGA,EAAE2B,EAAK/L,OAAQoK,IAC3Bd,EAAM9H,KAAKuK,EAAK3B,IAGpB,OAAOd,EAAM6B,KAAK,KAElB,OAAO/F,GAmBXqH,MAAO,SAASrH,GACd,OAAIlF,MAAMiQ,QAAQ/K,GACTtC,KAAKiP,UAAU3M,GAAMqH,MAAM,KAE7BrH,EAAKxF,WAAW6M,MAAM,MAe/BvT,IAAK,SAAS4L,EAAMM,EAAMtL,GACxB,IAAIM,EAAO0K,EACPwE,EAAQxG,KAAK2J,MAAMrH,GAEvB,IAAK,IAAIhN,EAAE,EAAGA,EAAEkR,EAAMtJ,OAAQ5H,IAAK,CACjC,IAAKgC,EACH,OAEF,IAAI2P,EAAOT,EAAMlR,GACjBgC,EAAOA,EAAK2P,GAKd,OAHIjQ,IACFA,EAAKsL,KAAOkE,EAAM6B,KAAK,MAElB/Q,GAaTS,IAAK,SAASiK,EAAMM,EAAM3M,GACxB,IAAI2B,EAAO0K,EACPwE,EAAQxG,KAAK2J,MAAMrH,GACnB/E,EAAOiJ,EAAMA,EAAMtJ,OAAO,GAC9B,GAAIsJ,EAAMtJ,OAAS,EAAG,CAEpB,IAAK,IAAI5H,EAAE,EAAGA,EAAEkR,EAAMtJ,OAAO,EAAG5H,IAAK,CACnC,IAAI2R,EAAOT,EAAMlR,GAEjB,KADAgC,EAAOA,EAAK2P,IAEV,OAIJ3P,EAAKiG,GAAQ5H,OAGb2B,EAAKgL,GAAQ3M,EAEf,OAAO6Q,EAAM6B,KAAK,OAsBtBtG,EAAK+lB,OAAS/lB,EAAKmI,OAEnBnT,QAAQgL,KAAOA,MvC0sOX,SAAU1M,EAAQD,EAASH,GwC98OjCA,EAAQ,GAGR,WACE,aAKA,SAAS8yB,EAAa7yB,GACpB,OAAK6B,QAAQwhB,UAGNxhB,QAAQwhB,UAAUsJ,OAAO3sB,GAFvB,KALX,MAAM8yB,EAA6B,8BAC7BC,EAAe,UAiBf9G,GAUJ+G,eAAeC,GACb,IAAInzB,EAAUmzB,EAAUze,OAAOC,MAAM,KACjCjP,EAAU,GACd,IAAK,IAAIpF,EAAE,EAAGA,EAAIN,EAAQkI,OAAQ5H,IAChCoF,GAAWsF,KAAKooB,cAAcpzB,EAAQM,IAExC,OAAOoF,GAeT0tB,cAAclzB,GACZ,IAAIO,EAAIsyB,EAAa7yB,GACrB,GAAIO,QAAoB+D,IAAf/D,EAAE4yB,SAAwB,CACjC,IAAI3tB,EAAU,GAEVimB,EAAIlrB,EAAE6iB,cAAc,YACpBqI,IACFjmB,GAAWsF,KAAKohB,gBAAgBT,EAAGlrB,EAAEmjB,YAGvCle,GAAWsF,KAAKqhB,qBAAqBnsB,GACrCO,EAAE4yB,SAAW3tB,GAAW,KAK1B,OAHKjF,GACHwN,QAAQC,KAAK,4CAA6ChO,GAErDO,GAAKA,EAAE4yB,UAAY,IAa5BjH,gBAAgB7Q,EAAUlX,GACxB,IAAIqB,EAAU,GAEV2qB,EAAK9U,EAASgR,QAAQ+G,iBAAiB,SAC3C,IAAK,IAAIhzB,EAAE,EAAGA,EAAI+vB,EAAGnoB,OAAQ5H,IAAK,CAChC,IAAIwE,EAAIurB,EAAG/vB,GAGPizB,EAAUzuB,EAAEof,aAAa+O,GACzBM,IACF7tB,GAAWsF,KAAKkoB,eAAeK,IAEjCzuB,EAAE0X,WAAWC,YAAY3X,GACzBY,GAAWrB,EACTtC,QAAQkE,WAAWR,WAAWX,EAAEkY,YAAa3Y,GAAWS,EAAEkY,YAE9D,OAAOtX,GAWT2mB,qBAAqBnsB,GACnB,IAAIwF,EAAU,GACVjF,EAAIsyB,EAAa7yB,GACrB,IAAKO,EACH,OAAOiF,EAET,IAAI0nB,EAAK3sB,EAAE6yB,iBAAiBN,GAC5B,IAAK,IAAI1yB,EAAE,EAAGA,EAAI8sB,EAAGllB,OAAQ5H,IAAK,CAChC,IAAIqB,EAAIyrB,EAAG9sB,GACX,GAAIqB,EAAEkrB,OAAQ,CACZ,IAAI2G,EAAY7xB,EAAEkrB,OAId4G,EAAYD,EAAUhuB,KAAOguB,EAAUhuB,KAAOguB,EAClD9tB,GACE3D,QAAQkE,WAAWR,WAAWguB,EAAUzW,YACtCwW,EAAUnvB,UAGlB,OAAOqB,IAIX3D,QAAQoqB,YAAcA,MxCk9OlB,SAAU9rB,EAAQD,EAASH,GyCzlPjCA,EAAQ,GAERA,EAAQ,IAERA,EAAQ,IAGN,WACE,aAOA,SAASyzB,IAAiC,OAAOC,EAWjD,SAASC,EAAgBrY,EAAU/T,GACjCmsB,EAAcpY,EACdva,OAAO6yB,eAAetY,EAAU/T,EAAY/F,WAC5C,IAAI+F,EACJmsB,EAAc,KAgKhB,SAASG,EAAevY,GAMtB,IAAIwY,EAAexY,EAAS9M,WAC5B,OAAOslB,GAAgBA,EAAa3f,aAAe2f,EAGrD,SAASC,EAAuBzY,EAAUlK,EAAc4iB,GAKtD,IAAIvxB,EAAOuxB,EAAQ3oB,YACjB4oB,EAA8BC,EAC5B5J,gBAAsB7nB,IAI1B,OAHA6nB,EAAM9oB,UAAU2yB,oBAAsBH,EACtC1J,EAAM9oB,UAAU+Z,cAAcD,GAC9B8Y,EAAiB9J,EAAOhP,EAAUlK,EAAc4iB,GACzC1J,EAGT,SAAS+J,EAAoB/Y,EAAUlK,EAAc4iB,GACnD,IAAIM,EAAsBN,EAAQvN,gBAClC,GAAI6N,EAAqB,CAEvB,IAAIhK,EAAQlZ,EAAamjB,wBACzB,IAAKjK,EAAO,CACV,IAAI7nB,EAAOuxB,EAAQ3oB,YAAcmpB,EAAsBC,EACvDnK,EAAQlZ,EAAamjB,sCACe9xB,IAGpC,IAAIoZ,EAAYzK,EAAayK,UAC7B,IAAK,IAAIxZ,KAAQwZ,EACfyO,EAAM9oB,UAAUyS,mBAAmB,SAAW5R,EAC5CioB,EAAM9oB,UAAUqV,sBAAsBV,WACrC/I,GAAIsnB,EAA4BryB,EAAMiyB,KACzChK,EAAM9oB,UAAUyZ,yBAAyB,SAAW5Y,GAGxDsxB,EAAgBrY,EAAUgP,GAGtBhP,EAASgT,aAGXvtB,OAAOkB,OAAOqZ,EAASxN,OAAQwN,EAASgT,aAG1ChT,EAAS/P,cACT+P,EAAShL,cAAgB,KACzBgL,EAASjL,UAAY,KACrBiL,EAASvC,qBAIb,SAAS2b,EAA4BC,EAAUL,GAC7C,OAAO,SAAyBhZ,EAAUjZ,EAAMiK,GAC9CgoB,EAAoB/zB,KAAK+a,EAASsZ,kBAChCvyB,EAAKyD,UAAU,SAASmC,QAASqE,EAAMjK,KAI7C,SAAS+xB,EAAiB9J,EAAOhP,EAAUlK,EAAc4iB,GACvD,IAAInY,EAAYzK,EAAayK,cAC7B,IAAK,IAAIgZ,KAASb,EAAQ3N,cAAe,QAChCxK,EAAUgZ,GACjB,IAAIC,EAAyBd,EAAQrN,mBACjCmO,GACFxK,EAAM9oB,UAAUyS,mBAAmB4gB,EACjCvK,EAAM9oB,UAAUqV,sBAAsBX,QACrC9I,GAAI2nB,EAA+BF,EAAOC,KAGjD,GAAId,EAAQvN,iBAAmBnL,EAAS9M,WACtC,IAAK,IAAIwmB,KAASnZ,EAChByO,EAAM9oB,UAAUyS,mBAAmB+gB,EACjC1K,EAAM9oB,UAAUqV,sBAAsBX,QACrC9I,GAAI6nB,MAKb,SAASF,EAA+BG,EAAUJ,GAChD,OAAO,SAA4B3pB,EAAM9I,EAAMiK,GAC7CwoB,EAAuBv0B,KAAK4K,EAAKypB,kBAC/BzpB,EAAM9I,EAAMiK,EAAMjK,KAIxB,SAAS4yB,IACP,OAAO,SAAwB9pB,EAAM9I,EAAMiK,GACzCnB,EAAKqD,WAAWmB,0BAA0B,SAAWtN,EAAMiK,EAAMjK,IAAO,GAAM,IA/QlF,IAAIqxB,EAAc,KAElBD,EAA6BjyB,UAAYT,OAAOsC,OAAOguB,oBAAoB7vB,WACzE+F,aACE7G,MAAO+yB,EACP0B,UAAU,KAGd,MAAMV,EAAe3yB,QAAQ2U,gBAAgBgd,GACvCe,EAAsB1yB,QAAQ2J,YAAYgpB,GAe1ChyB,EAAOX,QAAQ2U,+BACfyd,UAA6BzxB,EACjC8E,YAAY+E,GACVyK,QACAhM,KAAKqqB,qBAAqB9oB,GAC1BvB,KAAKgC,KAAOhC,KAAK+Q,eAAe/Q,KAAKyD,YAErC,IAAIwU,EAAWjY,KAAKiY,YACpB,IAAK,IAAI5hB,EAAI2J,KAAKgC,KAAKqP,WAAYhb,EAAGA,EAAEA,EAAEib,YACxC2G,EAASvZ,KAAKrI,GACdA,EAAEi0B,qBAAuBtqB,KAEvBA,KAAK6pB,kBAAkBU,0BACzBvqB,KAAK0e,mBAAkB,GAIzB,IAAIuK,EAAUjpB,KAAKopB,qBACd7nB,GAAS0nB,EAAQ3N,gBAAmB2N,EAAQ3N,gBAC/Ctb,KAAKgO,oBASTqc,qBAAqB9oB,GACnB,IAAI0nB,EAAUjpB,KAAKopB,oBACnB,GAAI7nB,EACF,IAAK,IAAIuoB,KAASb,EAAQ3N,cACpBwO,KAASvoB,GACXvB,KAAK8F,oBAAoBgkB,EAAOvoB,EAAMuoB,IAI5C,IAAK,IAAIG,KAASjqB,KAAKwqB,YACrBxqB,KAAK8F,oBAAoBmkB,EAAOjqB,KAAKyD,WAAW,SAAWwmB,IAa/DvO,gBAAgBpkB,EAAM3B,GAChBqK,KAAK4E,0BAA0BtN,EAAM3B,GAAO,GAAO,IACrDqK,KAAKyD,WAAWoE,eAAe7H,MAMnC2mB,wBAAwBhf,EAAM/D,EAAW8iB,GACvC,GAAI1mB,KAAKoJ,aAAepJ,KAAKopB,oBAAoB3N,YAG/Czb,KAAKoJ,YAAYud,wBAAwBhf,EAAM/D,EAAY9J,IACzDA,EAAEoH,MAAQlB,KACV0mB,EAAQ5sB,SAEL,CAGL,IAAIivB,EAAe/oB,KAAKyD,WAAWA,WAC/BslB,GACFA,EAAapC,wBAAwBhf,EAAM/D,EAAW8iB,IAY5DhI,kBAAkB+L,GAChB,IAAI/0B,EAAIsK,KAAKiY,SACb,IAAK,IAAI3iB,EAAE,EAAGA,EAAEI,EAAEwH,OAAQ5H,IAAK,CAC7B,IAAIe,EAAIX,EAAEJ,GAENyL,QAAQ0pB,IAAS1pB,QAAQ1K,EAAEk0B,4BACzBl0B,EAAEub,WAAaC,KAAKC,UAClB2Y,GACFp0B,EAAEq0B,uBAAyBr0B,EAAE2b,YAC7B3b,EAAE2b,YAAc,IAEhB3b,EAAE2b,YAAc3b,EAAEq0B,uBAEXr0B,EAAEirB,QACPmJ,GACFp0B,EAAEs0B,mBAAqBt0B,EAAEirB,MAAMsJ,QAC/Bv0B,EAAEirB,MAAMsJ,QAAU,QAElBv0B,EAAEirB,MAAMsJ,QAAUv0B,EAAEs0B,qBAI1Bt0B,EAAEk0B,yBAA2BE,EACzBp0B,EAAEqoB,mBACJroB,EAAEqoB,kBAAkB+L,IAW1BviB,4BAA4BP,EAAMrQ,EAAM3B,GAClCgS,EAAK4iB,0BACL5iB,EAAKiK,UAAYC,KAAKC,WAAqB,eAARxa,EACrCqQ,EAAK+iB,uBAAyB/0B,EAE9BqW,MAAM9D,4BAA4BP,EAAMrQ,EAAM3B,GAUlD8lB,kBACE,IAAIva,EAAQlB,KAAK6qB,cACjB,IAAK3pB,EAAO,CACV,IAAI+nB,EACJ/nB,EAAQlB,KACR,GAGEkB,EAAQA,EAAMuC,WAAWA,kBACjBwlB,EAAU/nB,EAAMkoB,uBAAyBH,EAAQxN,aAC3Dzb,KAAK6qB,cAAgB3pB,EAEvB,OAAOA,GAIX,MAAMgoB,EAA8BnyB,QAAQ2J,YAAYyoB,GA4IlD5N,GA8DJC,WAAWjL,EAAUuI,EAAOmQ,GAE1B,GADAA,EAAUA,MACN1Y,EAASsZ,kBACX,MAAM,IAAI1yB,MAAM,6CAElBoZ,EAASsZ,kBAAoB/Q,EAC7B,IAAIzS,EAAeyS,EAAMtc,YAAYkU,eAAeH,GAGhDua,EAAYzkB,EAAa0kB,wBACxBD,IACHA,EAAY9B,EAAuBzY,EAAUlK,EAAc4iB,GAC3D5iB,EAAa0kB,wBAA0BD,GAGzCxB,EAAoB/Y,EAAUlK,EAAc4iB,GAE5C,IAAI1J,gBAAuCuL,IAK3C,OAJAvL,EAAM9oB,UAAU2S,YAAc0f,EAAevY,GAC7CgP,EAAM9oB,UAAUgN,WAAa8M,EAC7BgP,EAAM9oB,UAAUozB,kBAAoB/Q,EACpCyG,EAAM9oB,UAAU+zB,YAAcnkB,EAAayK,UACpCyO,GAwBTH,gBAAgB7O,EAAU8N,GACxB,IAAInd,EACJ,KAAOmd,GAIL,GAAKnd,EAAQmd,EAAGiM,qBAAuB,CAGrC,GAAIppB,EAAMuC,YAAc8M,EAGtB,OAAOrP,EAFPmd,EAAKnd,EAAMuC,gBAOb4a,EAAKA,EAAG7M,WAGZ,OAAO,OAIXza,QAAQwkB,WAAaA,MzCwlPnB,SAAUlmB,EAAQD,G0CriQxBC,EAAOD,QAAU,SAASC,GAoBzB,OAnBIA,EAAO21B,kBACV31B,EAAO41B,UAAY,aACnB51B,EAAO8nB,SAEH9nB,EAAO4iB,WAAU5iB,EAAO4iB,aAC5BjiB,OAAOC,eAAeZ,EAAQ,UAC7Bc,YAAY,EACZC,IAAK,WACJ,OAAOf,EAAOE,KAGhBS,OAAOC,eAAeZ,EAAQ,MAC7Bc,YAAY,EACZC,IAAK,WACJ,OAAOf,EAAOC,KAGhBD,EAAO21B,gBAAkB,GAEnB31B,I1C4iQF,SAAUA,EAAQD,EAASH,GAEjCI,EAAOD,QAAUH,EAAoB","file":"bundle.js","sourcesContent":["/******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId]) {\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/ \t\t}\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\ti: moduleId,\n/******/ \t\t\tl: false,\n/******/ \t\t\texports: {}\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.l = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// identity function for calling harmony imports with the correct context\n/******/ \t__webpack_require__.i = function(value) { return value; };\n/******/\n/******/ \t// define getter function for harmony exports\n/******/ \t__webpack_require__.d = function(exports, name, getter) {\n/******/ \t\tif(!__webpack_require__.o(exports, name)) {\n/******/ \t\t\tObject.defineProperty(exports, name, {\n/******/ \t\t\t\tconfigurable: false,\n/******/ \t\t\t\tenumerable: true,\n/******/ \t\t\t\tget: getter\n/******/ \t\t\t});\n/******/ \t\t}\n/******/ \t};\n/******/\n/******/ \t// getDefaultExport function for compatibility with non-harmony modules\n/******/ \t__webpack_require__.n = function(module) {\n/******/ \t\tvar getter = module && module.__esModule ?\n/******/ \t\t\tfunction getDefault() { return module['default']; } :\n/******/ \t\t\tfunction getModuleExports() { return module; };\n/******/ \t\t__webpack_require__.d(getter, 'a', getter);\n/******/ \t\treturn getter;\n/******/ \t};\n/******/\n/******/ \t// Object.prototype.hasOwnProperty.call\n/******/ \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(__webpack_require__.s = 46);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ (function(module, exports) {\n\n/*__wc__loader*/\n\n(function () {\n  'use strict';\n\n  const userPolymer = window.Polymer;\n\n  /**\n   * @namespace Polymer\n   * @summary Polymer is a lightweight library built on top of the web\n   * standards-based Web Components API's, and makes it easy to build your\n   * own custom HTML elements.\n   * @param {Object} info Prototype for the custom element. It must contain\n   * an `is` property to specify the element name. Other properties populate\n   * the element prototype. The `properties`, `observers`, `hostAttributes`,\n   * and `listeners` properties are processed to create element features.\n   * @return {Object} Returns a custom element class for the given provided\n   * prototype `info` object. The name of the element if given by `info.is`.\n   */\n  window.Polymer = function (info) {\n    return window.Polymer._polymerFn(info);\n  };\n\n  // support user settings on the Polymer object\n  if (userPolymer) {\n    Object.assign(Polymer, userPolymer);\n  }\n\n  // To be plugged by legacy implementation if loaded\n  /**\n   * @param {Object} info Prototype for the custom element. It must contain\n   * an `is` property to specify the element name. Other properties populate\n   * the element prototype. The `properties`, `observers`, `hostAttributes`,\n   * and `listeners` properties are processed to create element features.\n   */\n  window.Polymer._polymerFn = function (info) {\n    // eslint-disable-line no-unused-vars\n    throw new Error('Load polymer.html to use the Polymer() function.');\n  };\n  window.Polymer.version = '2.0.1';\n\n  /* eslint-disable no-unused-vars */\n  /*\n  When using Closure Compiler, JSCompiler_renameProperty(property, object) is replaced by the munged name for object[property]\n  We cannot alias this function, so we have to use a small shim that has the same behavior when not compiling.\n  */\n  window.JSCompiler_renameProperty = function (prop, obj) {\n    return prop;\n  };\n  /* eslint-enable */\n})();\n\n/***/ }),\n/* 1 */\n/***/ (function(module, exports, __webpack_require__) {\n\n/*__wc__loader*/\n__webpack_require__(0);\n\n(function () {\n\n  'use strict';\n\n  // unique global id for deduping mixins.\n\n  let dedupeId = 0;\n\n  /**\n   * Given a mixin producing function, memoize applications of mixin to base\n   * @private\n   * @param {Function} mixin Mixin for which to create a caching mixin.\n   * @return {Function} Returns a mixin which when applied multiple times to the\n   * same base will always return the same extended class.\n   */\n  function cachingMixin(mixin) {\n    return function (base) {\n      if (!mixin.__mixinApplications) {\n        mixin.__mixinApplications = new WeakMap();\n      }\n      let map = mixin.__mixinApplications;\n      let application = map.get(base);\n      if (!application) {\n        application = mixin(base);\n        map.set(base, application);\n      }\n      return application;\n    };\n  }\n\n  /**\n   * Wraps an ES6 class expression mixin such that the mixin is only applied\n   * if it has not already been applied its base argument.  Also memoizes mixin\n   * applications.\n   *\n   * @memberof Polymer\n   * @param {Function} mixin ES6 class expression mixin to wrap\n   * @return {Function} Wrapped mixin that deduplicates and memoizes\n   *   mixin applications to base\n   */\n  Polymer.dedupingMixin = function (mixin) {\n    mixin = cachingMixin(mixin);\n    // maintain a unique id for each mixin\n    mixin.__dedupeId = ++dedupeId;\n    return function (base) {\n      let baseSet = base.__mixinSet;\n      if (baseSet && baseSet[mixin.__dedupeId]) {\n        return base;\n      }\n      let extended = mixin(base);\n      // copy inherited mixin set from the extended class, or the base class\n      // NOTE: we avoid use of Set here because some browser (IE11)\n      // cannot extend a base Set via the constructor.\n      extended.__mixinSet = Object.create(extended.__mixinSet || baseSet || null);\n      extended.__mixinSet[mixin.__dedupeId] = true;\n      return extended;\n    };\n  };\n})();\n\n/***/ }),\n/* 2 */\n/***/ (function(module, exports, __webpack_require__) {\n\n/*__wc__loader*/\n__webpack_require__(0);\n\n(function () {\n  'use strict';\n\n  const caseMap = {};\n  const DASH_TO_CAMEL = /-[a-z]/g;\n  const CAMEL_TO_DASH = /([A-Z])/g;\n\n  /**\n   * Module with utilities for converting between \"dash-case\" and \"camelCase\"\n   * identifiers.\n   *\n   * @namespace\n   * @memberof Polymer\n   * @summary Module that provides utilities for converting between \"dash-case\"\n   *   and \"camelCase\".\n   */\n  const CaseMap = {\n\n    /**\n     * Converts \"dash-case\" identifier (e.g. `foo-bar-baz`) to \"camelCase\"\n     * (e.g. `fooBarBaz`).\n     *\n     * @memberof Polymer.CaseMap\n     * @param {string} dash Dash-case identifier\n     * @return {string} Camel-case representation of the identifier\n     */\n    dashToCamelCase(dash) {\n      return caseMap[dash] || (caseMap[dash] = dash.indexOf('-') < 0 ? dash : dash.replace(DASH_TO_CAMEL, m => m[1].toUpperCase()));\n    },\n\n    /**\n     * Converts \"camelCase\" identifier (e.g. `fooBarBaz`) to \"dash-case\"\n     * (e.g. `foo-bar-baz`).\n     *\n     * @memberof Polymer.CaseMap\n     * @param {string} camel Camel-case identifier\n     * @return {string} Dash-case representation of the identifier\n     */\n    camelToDashCase(camel) {\n      return caseMap[camel] || (caseMap[camel] = camel.replace(CAMEL_TO_DASH, '-$1').toLowerCase());\n    }\n\n  };\n\n  Polymer.CaseMap = CaseMap;\n})();\n\n/***/ }),\n/* 3 */\n/***/ (function(module, exports, __webpack_require__) {\n\n/*__wc__loader*/\n__webpack_require__(0);\n\n(function () {\n  'use strict';\n\n  let CSS_URL_RX = /(url\\()([^)]*)(\\))/g;\n  let ABS_URL = /(^\\/)|(^#)|(^[\\w-\\d]*:)/;\n  let workingURL;\n  let resolveDoc;\n  /**\n   * Resolves the given URL against the provided `baseUri'.\n   *\n   * @memberof Polymer.ResolveUrl\n   * @param {string} url Input URL to resolve\n   * @param {string} baseURI Base URI to resolve the URL against\n   * @return {string} resolved URL\n   */\n  function resolveUrl(url, baseURI) {\n    if (url && ABS_URL.test(url)) {\n      return url;\n    }\n    // Lazy feature detection.\n    if (workingURL === undefined) {\n      workingURL = false;\n      try {\n        const u = new URL('b', 'http://a');\n        u.pathname = 'c%20d';\n        workingURL = u.href === 'http://a/c%20d';\n      } catch (e) {\n        // silently fail\n      }\n    }\n    if (!baseURI) {\n      baseURI = document.baseURI || window.location.href;\n    }\n    if (workingURL) {\n      return new URL(url, baseURI).href;\n    }\n    // Fallback to creating an anchor into a disconnected document.\n    if (!resolveDoc) {\n      resolveDoc = document.implementation.createHTMLDocument('temp');\n      resolveDoc.base = resolveDoc.createElement('base');\n      resolveDoc.head.appendChild(resolveDoc.base);\n      resolveDoc.anchor = resolveDoc.createElement('a');\n      resolveDoc.body.appendChild(resolveDoc.anchor);\n    }\n    resolveDoc.base.href = baseURI;\n    resolveDoc.anchor.href = url;\n    return resolveDoc.anchor.href || url;\n  }\n\n  /**\n   * Resolves any relative URL's in the given CSS text against the provided\n   * `ownerDocument`'s `baseURI`.\n   *\n   * @memberof Polymer.ResolveUrl\n   * @param {string} cssText CSS text to process\n   * @param {string} baseURI Base URI to resolve the URL against\n   * @return {string} Processed CSS text with resolved URL's\n   */\n  function resolveCss(cssText, baseURI) {\n    return cssText.replace(CSS_URL_RX, function (m, pre, url, post) {\n      return pre + '\\'' + resolveUrl(url.replace(/[\"']/g, ''), baseURI) + '\\'' + post;\n    });\n  }\n\n  /**\n   * Returns a path from a given `url`. The path includes the trailing\n   * `/` from the url.\n   *\n   * @memberof Polymer.ResolveUrl\n   * @param {string} url Input URL to transform\n   * @return {string} resolved path\n   */\n  function pathFromUrl(url) {\n    return url.substring(0, url.lastIndexOf('/') + 1);\n  }\n\n  /**\n   * Module with utilities for resolving relative URL's.\n   *\n   * @namespace\n   * @memberof Polymer\n   * @summary Module with utilities for resolving relative URL's.\n   */\n  Polymer.ResolveUrl = {\n    resolveCss: resolveCss,\n    resolveUrl: resolveUrl,\n    pathFromUrl: pathFromUrl\n  };\n})();\n\n/***/ }),\n/* 4 */\n/***/ (function(module, exports, __webpack_require__) {\n\n/*__wc__loader*/\n__webpack_require__(37);\n\n(function () {\n  'use strict';\n\n  /**\n   * Base class that provides the core API for Polymer's meta-programming\n   * features including template stamping, data-binding, attribute deserialization,\n   * and property change observation.\n   *\n   * @polymerElement\n   * @memberof Polymer\n   * @constructor\n   * @implements {Polymer_ElementMixin}\n   * @extends HTMLElement\n   * @mixes Polymer.ElementMixin\n   * @summary Custom element base class that provides the core API for Polymer's\n   *   key meta-programming features including template stamping, data-binding,\n   *   attribute deserialization, and property change observation\n   */\n\n  const Element = Polymer.ElementMixin(HTMLElement);\n  Polymer.Element = Element;\n})();\n\n/***/ }),\n/* 5 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_redux__ = __webpack_require__(29);\n\n\n\n\nconst state = {\n  items: [],\n  selected: null\n};\n\nconst appReducer = (state = 0, action) => {\n  switch (action.type) {\n    case 'SET_ITEMS':\n      return Object.assign({}, state, { items: action.data });\n    case 'SELECTED':\n      return Object.assign({}, state, { selected: action.data });\n    default:\n      return state;\n  }\n};\n\nconst store = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0_redux__[\"a\" /* createStore */])(appReducer, window.__REDUX_DEVTOOLS_EXTENSION__ && window.__REDUX_DEVTOOLS_EXTENSION__());\n/* harmony export (immutable) */ __webpack_exports__[\"a\"] = store;\n\n\n/***/ }),\n/* 6 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__root_js__ = __webpack_require__(24);\n\n\n/** Built-in value references. */\nvar Symbol = __WEBPACK_IMPORTED_MODULE_0__root_js__[\"a\" /* default */].Symbol;\n\n/* harmony default export */ __webpack_exports__[\"a\"] = (Symbol);\n\n/***/ }),\n/* 7 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__baseGetTag_js__ = __webpack_require__(18);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__getPrototype_js__ = __webpack_require__(20);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__isObjectLike_js__ = __webpack_require__(25);\n\n\n\n\n/** `Object#toString` result references. */\nvar objectTag = '[object Object]';\n\n/** Used for built-in method references. */\nvar funcProto = Function.prototype,\n    objectProto = Object.prototype;\n\n/** Used to resolve the decompiled source of functions. */\nvar funcToString = funcProto.toString;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/** Used to infer the `Object` constructor. */\nvar objectCtorString = funcToString.call(Object);\n\n/**\n * Checks if `value` is a plain object, that is, an object created by the\n * `Object` constructor or one with a `[[Prototype]]` of `null`.\n *\n * @static\n * @memberOf _\n * @since 0.8.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a plain object, else `false`.\n * @example\n *\n * function Foo() {\n *   this.a = 1;\n * }\n *\n * _.isPlainObject(new Foo);\n * // => false\n *\n * _.isPlainObject([1, 2, 3]);\n * // => false\n *\n * _.isPlainObject({ 'x': 0, 'y': 0 });\n * // => true\n *\n * _.isPlainObject(Object.create(null));\n * // => true\n */\nfunction isPlainObject(value) {\n  if (!__webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2__isObjectLike_js__[\"a\" /* default */])(value) || __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__baseGetTag_js__[\"a\" /* default */])(value) != objectTag) {\n    return false;\n  }\n  var proto = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__getPrototype_js__[\"a\" /* default */])(value);\n  if (proto === null) {\n    return true;\n  }\n  var Ctor = hasOwnProperty.call(proto, 'constructor') && proto.constructor;\n  return typeof Ctor == 'function' && Ctor instanceof Ctor && funcToString.call(Ctor) == objectCtorString;\n}\n\n/* harmony default export */ __webpack_exports__[\"a\"] = (isPlainObject);\n\n/***/ }),\n/* 8 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony export (immutable) */ __webpack_exports__[\"a\"] = compose;\n/**\n * Composes single-argument functions from right to left. The rightmost\n * function can take multiple arguments as it provides the signature for\n * the resulting composite function.\n *\n * @param {...Function} funcs The functions to compose.\n * @returns {Function} A function obtained by composing the argument functions\n * from right to left. For example, compose(f, g, h) is identical to doing\n * (...args) => f(g(h(...args))).\n */\n\nfunction compose() {\n  for (var _len = arguments.length, funcs = Array(_len), _key = 0; _key < _len; _key++) {\n    funcs[_key] = arguments[_key];\n  }\n\n  if (funcs.length === 0) {\n    return function (arg) {\n      return arg;\n    };\n  }\n\n  if (funcs.length === 1) {\n    return funcs[0];\n  }\n\n  var last = funcs[funcs.length - 1];\n  var rest = funcs.slice(0, -1);\n  return function () {\n    return rest.reduceRight(function (composed, f) {\n      return f(composed);\n    }, last.apply(undefined, arguments));\n  };\n}\n\n/***/ }),\n/* 9 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"b\", function() { return ActionTypes; });\n/* harmony export (immutable) */ __webpack_exports__[\"a\"] = createStore;\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_lodash_es_isPlainObject__ = __webpack_require__(7);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_symbol_observable__ = __webpack_require__(30);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_symbol_observable___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1_symbol_observable__);\n\n\n\n/**\n * These are private action types reserved by Redux.\n * For any unknown actions, you must return the current state.\n * If the current state is undefined, you must return the initial state.\n * Do not reference these action types directly in your code.\n */\nvar ActionTypes = {\n  INIT: '@@redux/INIT'\n};\n\n/**\n * Creates a Redux store that holds the state tree.\n * The only way to change the data in the store is to call `dispatch()` on it.\n *\n * There should only be a single store in your app. To specify how different\n * parts of the state tree respond to actions, you may combine several reducers\n * into a single reducer function by using `combineReducers`.\n *\n * @param {Function} reducer A function that returns the next state tree, given\n * the current state tree and the action to handle.\n *\n * @param {any} [preloadedState] The initial state. You may optionally specify it\n * to hydrate the state from the server in universal apps, or to restore a\n * previously serialized user session.\n * If you use `combineReducers` to produce the root reducer function, this must be\n * an object with the same shape as `combineReducers` keys.\n *\n * @param {Function} enhancer The store enhancer. You may optionally specify it\n * to enhance the store with third-party capabilities such as middleware,\n * time travel, persistence, etc. The only store enhancer that ships with Redux\n * is `applyMiddleware()`.\n *\n * @returns {Store} A Redux store that lets you read the state, dispatch actions\n * and subscribe to changes.\n */\nfunction createStore(reducer, preloadedState, enhancer) {\n  var _ref2;\n\n  if (typeof preloadedState === 'function' && typeof enhancer === 'undefined') {\n    enhancer = preloadedState;\n    preloadedState = undefined;\n  }\n\n  if (typeof enhancer !== 'undefined') {\n    if (typeof enhancer !== 'function') {\n      throw new Error('Expected the enhancer to be a function.');\n    }\n\n    return enhancer(createStore)(reducer, preloadedState);\n  }\n\n  if (typeof reducer !== 'function') {\n    throw new Error('Expected the reducer to be a function.');\n  }\n\n  var currentReducer = reducer;\n  var currentState = preloadedState;\n  var currentListeners = [];\n  var nextListeners = currentListeners;\n  var isDispatching = false;\n\n  function ensureCanMutateNextListeners() {\n    if (nextListeners === currentListeners) {\n      nextListeners = currentListeners.slice();\n    }\n  }\n\n  /**\n   * Reads the state tree managed by the store.\n   *\n   * @returns {any} The current state tree of your application.\n   */\n  function getState() {\n    return currentState;\n  }\n\n  /**\n   * Adds a change listener. It will be called any time an action is dispatched,\n   * and some part of the state tree may potentially have changed. You may then\n   * call `getState()` to read the current state tree inside the callback.\n   *\n   * You may call `dispatch()` from a change listener, with the following\n   * caveats:\n   *\n   * 1. The subscriptions are snapshotted just before every `dispatch()` call.\n   * If you subscribe or unsubscribe while the listeners are being invoked, this\n   * will not have any effect on the `dispatch()` that is currently in progress.\n   * However, the next `dispatch()` call, whether nested or not, will use a more\n   * recent snapshot of the subscription list.\n   *\n   * 2. The listener should not expect to see all state changes, as the state\n   * might have been updated multiple times during a nested `dispatch()` before\n   * the listener is called. It is, however, guaranteed that all subscribers\n   * registered before the `dispatch()` started will be called with the latest\n   * state by the time it exits.\n   *\n   * @param {Function} listener A callback to be invoked on every dispatch.\n   * @returns {Function} A function to remove this change listener.\n   */\n  function subscribe(listener) {\n    if (typeof listener !== 'function') {\n      throw new Error('Expected listener to be a function.');\n    }\n\n    var isSubscribed = true;\n\n    ensureCanMutateNextListeners();\n    nextListeners.push(listener);\n\n    return function unsubscribe() {\n      if (!isSubscribed) {\n        return;\n      }\n\n      isSubscribed = false;\n\n      ensureCanMutateNextListeners();\n      var index = nextListeners.indexOf(listener);\n      nextListeners.splice(index, 1);\n    };\n  }\n\n  /**\n   * Dispatches an action. It is the only way to trigger a state change.\n   *\n   * The `reducer` function, used to create the store, will be called with the\n   * current state tree and the given `action`. Its return value will\n   * be considered the **next** state of the tree, and the change listeners\n   * will be notified.\n   *\n   * The base implementation only supports plain object actions. If you want to\n   * dispatch a Promise, an Observable, a thunk, or something else, you need to\n   * wrap your store creating function into the corresponding middleware. For\n   * example, see the documentation for the `redux-thunk` package. Even the\n   * middleware will eventually dispatch plain object actions using this method.\n   *\n   * @param {Object} action A plain object representing what changed. It is\n   * a good idea to keep actions serializable so you can record and replay user\n   * sessions, or use the time travelling `redux-devtools`. An action must have\n   * a `type` property which may not be `undefined`. It is a good idea to use\n   * string constants for action types.\n   *\n   * @returns {Object} For convenience, the same action object you dispatched.\n   *\n   * Note that, if you use a custom middleware, it may wrap `dispatch()` to\n   * return something else (for example, a Promise you can await).\n   */\n  function dispatch(action) {\n    if (!__webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0_lodash_es_isPlainObject__[\"a\" /* default */])(action)) {\n      throw new Error('Actions must be plain objects. ' + 'Use custom middleware for async actions.');\n    }\n\n    if (typeof action.type === 'undefined') {\n      throw new Error('Actions may not have an undefined \"type\" property. ' + 'Have you misspelled a constant?');\n    }\n\n    if (isDispatching) {\n      throw new Error('Reducers may not dispatch actions.');\n    }\n\n    try {\n      isDispatching = true;\n      currentState = currentReducer(currentState, action);\n    } finally {\n      isDispatching = false;\n    }\n\n    var listeners = currentListeners = nextListeners;\n    for (var i = 0; i < listeners.length; i++) {\n      listeners[i]();\n    }\n\n    return action;\n  }\n\n  /**\n   * Replaces the reducer currently used by the store to calculate the state.\n   *\n   * You might need this if your app implements code splitting and you want to\n   * load some of the reducers dynamically. You might also need this if you\n   * implement a hot reloading mechanism for Redux.\n   *\n   * @param {Function} nextReducer The reducer for the store to use instead.\n   * @returns {void}\n   */\n  function replaceReducer(nextReducer) {\n    if (typeof nextReducer !== 'function') {\n      throw new Error('Expected the nextReducer to be a function.');\n    }\n\n    currentReducer = nextReducer;\n    dispatch({ type: ActionTypes.INIT });\n  }\n\n  /**\n   * Interoperability point for observable/reactive libraries.\n   * @returns {observable} A minimal observable of state changes.\n   * For more information, see the observable proposal:\n   * https://github.com/zenparsing/es-observable\n   */\n  function observable() {\n    var _ref;\n\n    var outerSubscribe = subscribe;\n    return _ref = {\n      /**\n       * The minimal observable subscription method.\n       * @param {Object} observer Any object that can be used as an observer.\n       * The observer object should have a `next` method.\n       * @returns {subscription} An object with an `unsubscribe` method that can\n       * be used to unsubscribe the observable from the store, and prevent further\n       * emission of values from the observable.\n       */\n      subscribe: function subscribe(observer) {\n        if (typeof observer !== 'object') {\n          throw new TypeError('Expected the observer to be an object.');\n        }\n\n        function observeState() {\n          if (observer.next) {\n            observer.next(getState());\n          }\n        }\n\n        observeState();\n        var unsubscribe = outerSubscribe(observeState);\n        return { unsubscribe: unsubscribe };\n      }\n    }, _ref[__WEBPACK_IMPORTED_MODULE_1_symbol_observable___default.a] = function () {\n      return this;\n    }, _ref;\n  }\n\n  // When a store is created, an \"INIT\" action is dispatched so that every\n  // reducer returns their initial state. This effectively populates\n  // the initial state tree.\n  dispatch({ type: ActionTypes.INIT });\n\n  return _ref2 = {\n    dispatch: dispatch,\n    subscribe: subscribe,\n    getState: getState,\n    replaceReducer: replaceReducer\n  }, _ref2[__WEBPACK_IMPORTED_MODULE_1_symbol_observable___default.a] = observable, _ref2;\n}\n\n/***/ }),\n/* 10 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* unused harmony export default */\n/**\n * Prints a warning in the console if it exists.\n *\n * @param {String} message The warning message.\n * @returns {void}\n */\nfunction warning(message) {\n  /* eslint-disable no-console */\n  if (typeof console !== 'undefined' && typeof console.error === 'function') {\n    console.error(message);\n  }\n  /* eslint-enable no-console */\n  try {\n    // This error was thrown as a convenience so that if you enable\n    // \"break on all exceptions\" in your console,\n    // it would pause the execution at this line.\n    throw new Error(message);\n    /* eslint-disable no-empty */\n  } catch (e) {}\n  /* eslint-enable no-empty */\n}\n\n/***/ }),\n/* 11 */\n/***/ (function(module, exports, __webpack_require__) {\n\n/*__wc__loader*/\n__webpack_require__(1);\n\n(function () {\n  'use strict';\n\n  // Common implementation for mixin & behavior\n\n  function mutablePropertyChange(inst, property, value, old, mutableData) {\n    let isObject;\n    if (mutableData) {\n      isObject = typeof value === 'object' && value !== null;\n      // Pull `old` for Objects from temp cache, but treat `null` as a primitive\n      if (isObject) {\n        old = inst.__dataTemp[property];\n      }\n    }\n    // Strict equality check, but return false for NaN===NaN\n    let shouldChange = old !== value && (old === old || value === value);\n    // Objects are stored in temporary cache (cleared at end of\n    // turn), which is used for dirty-checking\n    if (isObject && shouldChange) {\n      inst.__dataTemp[property] = value;\n    }\n    return shouldChange;\n  }\n\n  /**\n   * Element class mixin to skip strict dirty-checking for objects and arrays\n   * (always consider them to be \"dirty\"), for use on elements utilizing\n   * `Polymer.PropertyEffects`\n   *\n   * By default, `Polymer.PropertyEffects` performs strict dirty checking on\n   * objects, which means that any deep modifications to an object or array will\n   * not be propagated unless \"immutable\" data patterns are used (i.e. all object\n   * references from the root to the mutation were changed).\n   *\n   * Polymer also provides a proprietary data mutation and path notification API\n   * (e.g. `notifyPath`, `set`, and array mutation API's) that allow efficient\n   * mutation and notification of deep changes in an object graph to all elements\n   * bound to the same object graph.\n   *\n   * In cases where neither immutable patterns nor the data mutation API can be\n   * used, applying this mixin will cause Polymer to skip dirty checking for\n   * objects and arrays (always consider them to be \"dirty\").  This allows a\n   * user to make a deep modification to a bound object graph, and then either\n   * simply re-set the object (e.g. `this.items = this.items`) or call `notifyPath`\n   * (e.g. `this.notifyPath('items')`) to update the tree.  Note that all\n   * elements that wish to be updated based on deep mutations must apply this\n   * mixin or otherwise skip strict dirty checking for objects/arrays.\n   *\n   * In order to make the dirty check strategy configurable, see\n   * `Polymer.OptionalMutableData`.\n   *\n   * Note, the performance characteristics of propagating large object graphs\n   * will be worse as opposed to using strict dirty checking with immutable\n   * patterns or Polymer's path notification API.\n   *\n   * @polymerMixin\n   * @memberof Polymer\n   * @summary Element class mixin to skip strict dirty-checking for objects\n   *   and arrays\n   */\n  Polymer.MutableData = Polymer.dedupingMixin(superClass => {\n\n    /**\n     * @polymerMixinClass\n     * @implements {Polymer_MutableData}\n     */\n    class MutableData extends superClass {\n      /**\n       * Overrides `Polymer.PropertyEffects` to provide option for skipping\n       * strict equality checking for Objects and Arrays.\n       *\n       * This method pulls the value to dirty check against from the `__dataTemp`\n       * cache (rather than the normal `__data` cache) for Objects.  Since the temp\n       * cache is cleared at the end of a turn, this implementation allows\n       * side-effects of deep object changes to be processed by re-setting the\n       * same object (using the temp cache as an in-turn backstop to prevent\n       * cycles due to 2-way notification).\n       *\n       * @param {string} property Property name\n       * @param {*} value New property value\n       * @param {*} old Previous property value\n       * @return {boolean} Whether the property should be considered a change\n       * @protected\n       */\n      _shouldPropertyChange(property, value, old) {\n        return mutablePropertyChange(this, property, value, old, true);\n      }\n\n    }\n\n    return MutableData;\n  });\n\n  /**\n   * Element class mixin to add the optional ability to skip strict\n   * dirty-checking for objects and arrays (always consider them to be\n   * \"dirty\") by setting a `mutable-data` attribute on an element instance.\n   *\n   * By default, `Polymer.PropertyEffects` performs strict dirty checking on\n   * objects, which means that any deep modifications to an object or array will\n   * not be propagated unless \"immutable\" data patterns are used (i.e. all object\n   * references from the root to the mutation were changed).\n   *\n   * Polymer also provides a proprietary data mutation and path notification API\n   * (e.g. `notifyPath`, `set`, and array mutation API's) that allow efficient\n   * mutation and notification of deep changes in an object graph to all elements\n   * bound to the same object graph.\n   *\n   * In cases where neither immutable patterns nor the data mutation API can be\n   * used, applying this mixin will allow Polymer to skip dirty checking for\n   * objects and arrays (always consider them to be \"dirty\").  This allows a\n   * user to make a deep modification to a bound object graph, and then either\n   * simply re-set the object (e.g. `this.items = this.items`) or call `notifyPath`\n   * (e.g. `this.notifyPath('items')`) to update the tree.  Note that all\n   * elements that wish to be updated based on deep mutations must apply this\n   * mixin or otherwise skip strict dirty checking for objects/arrays.\n   *\n   * While this mixin adds the ability to forgo Object/Array dirty checking,\n   * the `mutableData` flag defaults to false and must be set on the instance.\n   *\n   * Note, the performance characteristics of propagating large object graphs\n   * will be worse by relying on `mutableData: true` as opposed to using\n   * strict dirty checking with immutable patterns or Polymer's path notification\n   * API.\n   *\n   * @polymerMixin\n   * @memberof Polymer\n   * @summary Element class mixin to optionally skip strict dirty-checking\n   *   for objects and arrays\n   */\n  Polymer.OptionalMutableData = Polymer.dedupingMixin(superClass => {\n\n    /**\n     * @polymerMixinClass\n     * @implements {Polymer_OptionalMutableData}\n     */\n    class OptionalMutableData extends superClass {\n\n      static get properties() {\n        return {\n          /**\n           * Instance-level flag for configuring the dirty-checking strategy\n           * for this element.  When true, Objects and Arrays will skip dirty\n           * checking, otherwise strict equality checking will be used.\n           */\n          mutableData: Boolean\n        };\n      }\n\n      /**\n       * Overrides `Polymer.PropertyEffects` to provide option for skipping\n       * strict equality checking for Objects and Arrays.\n       *\n       * When `this.mutableData` is true on this instance, this method\n       * pulls the value to dirty check against from the `__dataTemp` cache\n       * (rather than the normal `__data` cache) for Objects.  Since the temp\n       * cache is cleared at the end of a turn, this implementation allows\n       * side-effects of deep object changes to be processed by re-setting the\n       * same object (using the temp cache as an in-turn backstop to prevent\n       * cycles due to 2-way notification).\n       *\n       * @param {string} property Property name\n       * @param {*} value New property value\n       * @param {*} old Previous property value\n       * @return {boolean} Whether the property should be considered a change\n       * @protected\n       */\n      _shouldPropertyChange(property, value, old) {\n        return mutablePropertyChange(this, property, value, old, this.mutableData);\n      }\n    }\n\n    return OptionalMutableData;\n  });\n\n  // Export for use by legacy behavior\n  Polymer.MutableData._mutablePropertyChange = mutablePropertyChange;\n})();\n\n/***/ }),\n/* 12 */\n/***/ (function(module, exports, __webpack_require__) {\n\n/*__wc__loader*/\n__webpack_require__(0);\n\n__webpack_require__(1);\n\n__webpack_require__(42);\n\n__webpack_require__(2);\n\n__webpack_require__(38);\n\n__webpack_require__(39);\n\n(function () {\n\n  'use strict';\n\n  /** @const {Object} */\n\n  const CaseMap = Polymer.CaseMap;\n\n  // Monotonically increasing unique ID used for de-duping effects triggered\n  // from multiple properties in the same turn\n  let dedupeId = 0;\n\n  // Property effect types; effects are stored on the prototype using these keys\n  const TYPES = {\n    COMPUTE: '__computeEffects',\n    REFLECT: '__reflectEffects',\n    NOTIFY: '__notifyEffects',\n    PROPAGATE: '__propagateEffects',\n    OBSERVE: '__observeEffects',\n    READ_ONLY: '__readOnly'\n  };\n\n  /**\n   * Ensures that the model has an own-property map of effects for the given type.\n   * The model may be a prototype or an instance.\n   *\n   * Property effects are stored as arrays of effects by property in a map,\n   * by named type on the model. e.g.\n   *\n   *   __computeEffects: {\n   *     foo: [ ... ],\n   *     bar: [ ... ]\n   *   }\n   *\n   * If the model does not yet have an effect map for the type, one is created\n   * and returned.  If it does, but it is not an own property (i.e. the\n   * prototype had effects), the the map is deeply cloned and the copy is\n   * set on the model and returned, ready for new effects to be added.\n   *\n   * @param {Object} model Prototype or instance\n   * @param {string} type Property effect type\n   * @return {Object} The own-property map of effects for the given type\n   * @private\n   */\n  function ensureOwnEffectMap(model, type) {\n    let effects = model[type];\n    if (!effects) {\n      effects = model[type] = {};\n    } else if (!model.hasOwnProperty(type)) {\n      effects = model[type] = Object.create(model[type]);\n      for (let p in effects) {\n        let protoFx = effects[p];\n        let instFx = effects[p] = Array(protoFx.length);\n        for (let i = 0; i < protoFx.length; i++) {\n          instFx[i] = protoFx[i];\n        }\n      }\n    }\n    return effects;\n  }\n\n  // -- effects ----------------------------------------------\n\n  /**\n   * Runs all effects of a given type for the given set of property changes\n   * on an instance.\n   *\n   * @param {Object} inst The instance with effects to run\n   * @param {Object} effects Object map of property-to-Array of effects\n   * @param {Object} props Bag of current property changes\n   * @param {Object=} oldProps Bag of previous values for changed properties\n   * @param {boolean=} hasPaths True with `props` contains one or more paths\n   * @param {*=} extraArgs Additional metadata to pass to effect function\n   * @return {boolean} True if an effect ran for this property\n   * @private\n   */\n  function runEffects(inst, effects, props, oldProps, hasPaths, extraArgs) {\n    if (effects) {\n      let ran = false;\n      let id = dedupeId++;\n      for (let prop in props) {\n        if (runEffectsForProperty(inst, effects, id, prop, props, oldProps, hasPaths, extraArgs)) {\n          ran = true;\n        }\n      }\n      return ran;\n    }\n    return false;\n  }\n\n  /**\n   * Runs a list of effects for a given property.\n   *\n   * @param {Object} inst The instance with effects to run\n   * @param {Object} effects Object map of property-to-Array of effects\n   * @param {number} dedupeId Counter used for de-duping effects\n   * @param {string} prop Name of changed property\n   * @param {*} props Changed properties\n   * @param {*} oldProps Old properties\n   * @param {boolean=} hasPaths True with `props` contains one or more paths\n   * @param {*=} extraArgs Additional metadata to pass to effect function\n   * @return {boolean} True if an effect ran for this property\n   * @private\n   */\n  function runEffectsForProperty(inst, effects, dedupeId, prop, props, oldProps, hasPaths, extraArgs) {\n    let ran = false;\n    let rootProperty = hasPaths ? Polymer.Path.root(prop) : prop;\n    let fxs = effects[rootProperty];\n    if (fxs) {\n      for (let i = 0, l = fxs.length, fx; i < l && (fx = fxs[i]); i++) {\n        if ((!fx.info || fx.info.lastRun !== dedupeId) && (!hasPaths || pathMatchesTrigger(prop, fx.trigger))) {\n          if (fx.info) {\n            fx.info.lastRun = dedupeId;\n          }\n          fx.fn(inst, prop, props, oldProps, fx.info, hasPaths, extraArgs);\n          ran = true;\n        }\n      }\n    }\n    return ran;\n  }\n\n  /**\n   * Determines whether a property/path that has changed matches the trigger\n   * criteria for an effect.  A trigger is a descriptor with the following\n   * structure, which matches the descriptors returned from `parseArg`.\n   * e.g. for `foo.bar.*`:\n   * ```\n   * trigger: {\n   *   name: 'a.b',\n   *   structured: true,\n   *   wildcard: true\n   * }\n   * ```\n   * If no trigger is given, the path is deemed to match.\n   *\n   * @param {string} path Path or property that changed\n   * @param {Object} trigger Descriptor\n   * @return {boolean} Whether the path matched the trigger\n   */\n  function pathMatchesTrigger(path, trigger) {\n    if (trigger) {\n      let triggerPath = trigger.name;\n      return triggerPath == path || trigger.structured && Polymer.Path.isAncestor(triggerPath, path) || trigger.wildcard && Polymer.Path.isDescendant(triggerPath, path);\n    } else {\n      return true;\n    }\n  }\n\n  /**\n   * Implements the \"observer\" effect.\n   *\n   * Calls the method with `info.methodName` on the instance, passing the\n   * new and old values.\n   *\n   * @param {Object} inst The instance the effect will be run on\n   * @param {string} property Name of property\n   * @param {Object} props Bag of current property changes\n   * @param {Object} oldProps Bag of previous values for changed properties\n   * @param {Object} info Effect metadata\n   * @private\n   */\n  function runObserverEffect(inst, property, props, oldProps, info) {\n    let fn = inst[info.methodName];\n    let changedProp = info.property;\n    if (fn) {\n      fn.call(inst, inst.__data[changedProp], oldProps[changedProp]);\n    } else if (!info.dynamicFn) {\n      console.warn('observer method `' + info.methodName + '` not defined');\n    }\n  }\n\n  /**\n   * Runs \"notify\" effects for a set of changed properties.\n   *\n   * This method differs from the generic `runEffects` method in that it\n   * will dispatch path notification events in the case that the property\n   * changed was a path and the root property for that path didn't have a\n   * \"notify\" effect.  This is to maintain 1.0 behavior that did not require\n   * `notify: true` to ensure object sub-property notifications were\n   * sent.\n   *\n   * @param {Element} inst The instance with effects to run\n   * @param {Object} notifyProps Bag of properties to notify\n   * @param {Object} props Bag of current property changes\n   * @param {Object} oldProps Bag of previous values for changed properties\n   * @param {boolean} hasPaths True with `props` contains one or more paths\n   * @private\n   */\n  function runNotifyEffects(inst, notifyProps, props, oldProps, hasPaths) {\n    // Notify\n    let fxs = inst.__notifyEffects;\n    let notified;\n    let id = dedupeId++;\n    // Try normal notify effects; if none, fall back to try path notification\n    for (let prop in notifyProps) {\n      if (notifyProps[prop]) {\n        if (fxs && runEffectsForProperty(inst, fxs, id, prop, props, oldProps, hasPaths)) {\n          notified = true;\n        } else if (hasPaths && notifyPath(inst, prop, props)) {\n          notified = true;\n        }\n      }\n    }\n    // Flush host if we actually notified and host was batching\n    // And the host has already initialized clients; this prevents\n    // an issue with a host observing data changes before clients are ready.\n    let host;\n    if (notified && (host = inst.__dataHost) && host._invalidateProperties) {\n      host._invalidateProperties();\n    }\n  }\n\n  /**\n   * Dispatches {property}-changed events with path information in the detail\n   * object to indicate a sub-path of the property was changed.\n   *\n   * @param {Element} inst The element from which to fire the event\n   * @param {string} path The path that was changed\n   * @param {Object} props Bag of current property changes\n   * @return {boolean} Returns true if the path was notified\n   * @private\n   */\n  function notifyPath(inst, path, props) {\n    let rootProperty = Polymer.Path.root(path);\n    if (rootProperty !== path) {\n      let eventName = Polymer.CaseMap.camelToDashCase(rootProperty) + '-changed';\n      dispatchNotifyEvent(inst, eventName, props[path], path);\n      return true;\n    }\n  }\n\n  /**\n   * Dispatches {property}-changed events to indicate a property (or path)\n   * changed.\n   *\n   * @param {Element} inst The element from which to fire the event\n   * @param {string} eventName The name of the event to send ('{property}-changed')\n   * @param {*} value The value of the changed property\n   * @param {string | null | undefined} path If a sub-path of this property changed, the path\n   *   that changed (optional).\n   * @private\n   */\n  function dispatchNotifyEvent(inst, eventName, value, path) {\n    let detail = {\n      value: value,\n      queueProperty: true\n    };\n    if (path) {\n      detail.path = path;\n    }\n    inst.dispatchEvent(new CustomEvent(eventName, { detail }));\n  }\n\n  /**\n   * Implements the \"notify\" effect.\n   *\n   * Dispatches a non-bubbling event named `info.eventName` on the instance\n   * with a detail object containing the new `value`.\n   *\n   * @param {Element} inst The instance the effect will be run on\n   * @param {string} property Name of property\n   * @param {Object} props Bag of current property changes\n   * @param {Object} oldProps Bag of previous values for changed properties\n   * @param {Object} info Effect metadata\n   * @param {boolean} hasPaths True with `props` contains one or more paths\n   * @private\n   */\n  function runNotifyEffect(inst, property, props, oldProps, info, hasPaths) {\n    let rootProperty = hasPaths ? Polymer.Path.root(property) : property;\n    let path = rootProperty != property ? property : null;\n    let value = path ? Polymer.Path.get(inst, path) : inst.__data[property];\n    if (path && value === undefined) {\n      value = props[property]; // specifically for .splices\n    }\n    dispatchNotifyEvent(inst, info.eventName, value, path);\n  }\n\n  /**\n   * Handler function for 2-way notification events. Receives context\n   * information captured in the `addNotifyListener` closure from the\n   * `__notifyListeners` metadata.\n   *\n   * Sets the value of the notified property to the host property or path.  If\n   * the event contained path information, translate that path to the host\n   * scope's name for that path first.\n   *\n   * @param {Event} event Notification event (e.g. '<property>-changed')\n   * @param {Object} inst Host element instance handling the notification event\n   * @param {string} fromProp Child element property that was bound\n   * @param {string} toPath Host property/path that was bound\n   * @param {boolean} negate Whether the binding was negated\n   * @private\n   */\n  function handleNotification(event, inst, fromProp, toPath, negate) {\n    let value;\n    let detail = event.detail;\n    let fromPath = detail && detail.path;\n    if (fromPath) {\n      toPath = Polymer.Path.translate(fromProp, toPath, fromPath);\n      value = detail && detail.value;\n    } else {\n      value = event.target[fromProp];\n    }\n    value = negate ? !value : value;\n    if (!inst.__readOnly || !inst.__readOnly[toPath]) {\n      if (inst._setPendingPropertyOrPath(toPath, value, true, Boolean(fromPath)) && (!detail || !detail.queueProperty)) {\n        inst._invalidateProperties();\n      }\n    }\n  }\n\n  /**\n   * Implements the \"reflect\" effect.\n   *\n   * Sets the attribute named `info.attrName` to the given property value.\n   *\n   * @param {Object} inst The instance the effect will be run on\n   * @param {string} property Name of property\n   * @param {Object} props Bag of current property changes\n   * @param {Object} oldProps Bag of previous values for changed properties\n   * @param {Object} info Effect metadata\n   * @private\n   */\n  function runReflectEffect(inst, property, props, oldProps, info) {\n    let value = inst.__data[property];\n    if (Polymer.sanitizeDOMValue) {\n      value = Polymer.sanitizeDOMValue(value, info.attrName, 'attribute', inst);\n    }\n    inst._propertyToAttribute(property, info.attrName, value);\n  }\n\n  /**\n   * Runs \"computed\" effects for a set of changed properties.\n   *\n   * This method differs from the generic `runEffects` method in that it\n   * continues to run computed effects based on the output of each pass until\n   * there are no more newly computed properties.  This ensures that all\n   * properties that will be computed by the initial set of changes are\n   * computed before other effects (binding propagation, observers, and notify)\n   * run.\n   *\n   * @param {Element} inst The instance the effect will be run on\n   * @param {Object} changedProps Bag of changed properties\n   * @param {Object} oldProps Bag of previous values for changed properties\n   * @param {boolean} hasPaths True with `props` contains one or more paths\n   * @private\n   */\n  function runComputedEffects(inst, changedProps, oldProps, hasPaths) {\n    let computeEffects = inst.__computeEffects;\n    if (computeEffects) {\n      let inputProps = changedProps;\n      while (runEffects(inst, computeEffects, inputProps, oldProps, hasPaths)) {\n        Object.assign(oldProps, inst.__dataOld);\n        Object.assign(changedProps, inst.__dataPending);\n        inputProps = inst.__dataPending;\n        inst.__dataPending = null;\n      }\n    }\n  }\n\n  /**\n   * Implements the \"computed property\" effect by running the method with the\n   * values of the arguments specified in the `info` object and setting the\n   * return value to the computed property specified.\n   *\n   * @param {Object} inst The instance the effect will be run on\n   * @param {string} property Name of property\n   * @param {Object} props Bag of current property changes\n   * @param {Object} oldProps Bag of previous values for changed properties\n   * @param {Object} info Effect metadata\n   * @private\n   */\n  function runComputedEffect(inst, property, props, oldProps, info) {\n    let result = runMethodEffect(inst, property, props, oldProps, info);\n    let computedProp = info.methodInfo;\n    if (inst.__dataHasAccessor && inst.__dataHasAccessor[computedProp]) {\n      inst._setPendingProperty(computedProp, result, true);\n    } else {\n      inst[computedProp] = result;\n    }\n  }\n\n  /**\n   * Computes path changes based on path links set up using the `linkPaths`\n   * API.\n   *\n   * @param {Element} inst The instance whose props are changing\n   * @param {string} path Path that has changed\n   * @param {*} value Value of changed path\n   * @private\n   */\n  function computeLinkedPaths(inst, path, value) {\n    let links = inst.__dataLinkedPaths;\n    if (links) {\n      let link;\n      for (let a in links) {\n        let b = links[a];\n        if (Polymer.Path.isDescendant(a, path)) {\n          link = Polymer.Path.translate(a, b, path);\n          inst._setPendingPropertyOrPath(link, value, true, true);\n        } else if (Polymer.Path.isDescendant(b, path)) {\n          link = Polymer.Path.translate(b, a, path);\n          inst._setPendingPropertyOrPath(link, value, true, true);\n        }\n      }\n    }\n  }\n\n  // -- bindings ----------------------------------------------\n\n  /**\n   * Adds binding metadata to the current `nodeInfo`, and binding effects\n   * for all part dependencies to `templateInfo`.\n   *\n   * @param {Function} constructor Class that `_parseTemplate` is currently\n   *   running on\n   * @param {Object} templateInfo Template metadata for current template\n   * @param {Object} nodeInfo Node metadata for current template node\n   * @param {string} kind Binding kind, either 'property', 'attribute', or 'text'\n   * @param {string} target Target property name\n   * @param {Array<Object>} parts Array of binding part metadata\n   * @param {string} literal Literal text surrounding binding parts (specified\n   *   only for 'property' bindings, since these must be initialized as part\n   *   of boot-up)\n   * @private\n   */\n  function addBinding(constructor, templateInfo, nodeInfo, kind, target, parts, literal) {\n    // Create binding metadata and add to nodeInfo\n    nodeInfo.bindings = nodeInfo.bindings || [];\n    let binding = { kind, target, parts, literal, isCompound: parts.length !== 1 };\n    nodeInfo.bindings.push(binding);\n    // Add listener info to binding metadata\n    if (shouldAddListener(binding)) {\n      let { event, negate } = binding.parts[0];\n      binding.listenerEvent = event || CaseMap.camelToDashCase(target) + '-changed';\n      binding.listenerNegate = negate;\n    }\n    // Add \"propagate\" property effects to templateInfo\n    let index = templateInfo.nodeInfoList.length;\n    for (let i = 0; i < binding.parts.length; i++) {\n      let part = binding.parts[i];\n      part.compoundIndex = i;\n      addEffectForBindingPart(constructor, templateInfo, binding, part, index);\n    }\n  }\n\n  /**\n   * Adds property effects to the given `templateInfo` for the given binding\n   * part.\n   *\n   * @param {Function} constructor Class that `_parseTemplate` is currently\n   *   running on\n   * @param {Object} templateInfo Template metadata for current template\n   * @param {Object} binding Binding metadata\n   * @param {Object} part Binding part metadata\n   * @param {number} index Index into `nodeInfoList` for this node\n   */\n  function addEffectForBindingPart(constructor, templateInfo, binding, part, index) {\n    if (!part.literal) {\n      if (binding.kind === 'attribute' && binding.target[0] === '-') {\n        console.warn('Cannot set attribute ' + binding.target + ' because \"-\" is not a valid attribute starting character');\n      } else {\n        let dependencies = part.dependencies;\n        let info = { index, binding, part, evaluator: constructor };\n        for (let j = 0; j < dependencies.length; j++) {\n          let trigger = dependencies[j];\n          if (typeof trigger == 'string') {\n            trigger = parseArg(trigger);\n            trigger.wildcard = true;\n          }\n          constructor._addTemplatePropertyEffect(templateInfo, trigger.rootProperty, {\n            fn: runBindingEffect,\n            info, trigger\n          });\n        }\n      }\n    }\n  }\n\n  /**\n   * Implements the \"binding\" (property/path binding) effect.\n   *\n   * Note that binding syntax is overridable via `_parseBindings` and\n   * `_evaluateBinding`.  This method will call `_evaluateBinding` for any\n   * non-literal parts returned from `_parseBindings`.  However,\n   * there is no support for _path_ bindings via custom binding parts,\n   * as this is specific to Polymer's path binding syntax.\n   *\n   * @param {Element} inst The instance the effect will be run on\n   * @param {string} path Name of property\n   * @param {Object} props Bag of current property changes\n   * @param {Object} oldProps Bag of previous values for changed properties\n   * @param {Object} info Effect metadata\n   * @param {boolean} hasPaths True with `props` contains one or more paths\n   * @param {Array} nodeList List of nodes associated with `nodeInfoList` template\n   *   metadata\n   * @private\n   */\n  function runBindingEffect(inst, path, props, oldProps, info, hasPaths, nodeList) {\n    let node = nodeList[info.index];\n    let binding = info.binding;\n    let part = info.part;\n    // Subpath notification: transform path and set to client\n    // e.g.: foo=\"{{obj.sub}}\", path: 'obj.sub.prop', set 'foo.prop'=obj.sub.prop\n    if (hasPaths && part.source && path.length > part.source.length && binding.kind == 'property' && !binding.isCompound && node.__dataHasAccessor && node.__dataHasAccessor[binding.target]) {\n      let value = props[path];\n      path = Polymer.Path.translate(part.source, binding.target, path);\n      if (node._setPendingPropertyOrPath(path, value, false, true)) {\n        inst._enqueueClient(node);\n      }\n    } else {\n      let value = info.evaluator._evaluateBinding(inst, part, path, props, oldProps, hasPaths);\n      // Propagate value to child\n      applyBindingValue(inst, node, binding, part, value);\n    }\n  }\n\n  /**\n   * Sets the value for an \"binding\" (binding) effect to a node,\n   * either as a property or attribute.\n   *\n   * @param {Object} inst The instance owning the binding effect\n   * @param {Node} node Target node for binding\n   * @param {Object} binding Binding metadata\n   * @param {Object} part Binding part metadata\n   * @param {*} value Value to set\n   * @private\n   */\n  function applyBindingValue(inst, node, binding, part, value) {\n    value = computeBindingValue(node, value, binding, part);\n    if (Polymer.sanitizeDOMValue) {\n      value = Polymer.sanitizeDOMValue(value, binding.target, binding.kind, node);\n    }\n    if (binding.kind == 'attribute') {\n      // Attribute binding\n      inst._valueToNodeAttribute(node, value, binding.target);\n    } else {\n      // Property binding\n      let prop = binding.target;\n      if (node.__dataHasAccessor && node.__dataHasAccessor[prop]) {\n        if (!node.__readOnly || !node.__readOnly[prop]) {\n          if (node._setPendingProperty(prop, value)) {\n            inst._enqueueClient(node);\n          }\n        }\n      } else {\n        inst._setUnmanagedPropertyToNode(node, prop, value);\n      }\n    }\n  }\n\n  /**\n   * Transforms an \"binding\" effect value based on compound & negation\n   * effect metadata, as well as handling for special-case properties\n   *\n   * @param {Node} node Node the value will be set to\n   * @param {*} value Value to set\n   * @param {Object} binding Binding metadata\n   * @param {Object} part Binding part metadata\n   * @return {*} Transformed value to set\n   * @private\n   */\n  function computeBindingValue(node, value, binding, part) {\n    if (binding.isCompound) {\n      let storage = node.__dataCompoundStorage[binding.target];\n      storage[part.compoundIndex] = value;\n      value = storage.join('');\n    }\n    if (binding.kind !== 'attribute') {\n      // Some browsers serialize `undefined` to `\"undefined\"`\n      if (binding.target === 'textContent' || node.localName == 'input' && binding.target == 'value') {\n        value = value == undefined ? '' : value;\n      }\n    }\n    return value;\n  }\n\n  /**\n   * Returns true if a binding's metadata meets all the requirements to allow\n   * 2-way binding, and therefore a `<property>-changed` event listener should be\n   * added:\n   * - used curly braces\n   * - is a property (not attribute) binding\n   * - is not a textContent binding\n   * - is not compound\n   *\n   * @param {Object} binding Binding metadata\n   * @return {boolean} True if 2-way listener should be added\n   * @private\n   */\n  function shouldAddListener(binding) {\n    return binding.target && binding.kind != 'attribute' && binding.kind != 'text' && !binding.isCompound && binding.parts[0].mode === '{';\n  }\n\n  /**\n   * Setup compound binding storage structures, notify listeners, and dataHost\n   * references onto the bound nodeList.\n   *\n   * @param {Object} inst Instance that bas been previously bound\n   * @param {Object} templateInfo Template metadata\n   * @private\n   */\n  function setupBindings(inst, templateInfo) {\n    // Setup compound storage, dataHost, and notify listeners\n    let { nodeList, nodeInfoList } = templateInfo;\n    if (nodeInfoList.length) {\n      for (let i = 0; i < nodeInfoList.length; i++) {\n        let info = nodeInfoList[i];\n        let node = nodeList[i];\n        let bindings = info.bindings;\n        if (bindings) {\n          for (let i = 0; i < bindings.length; i++) {\n            let binding = bindings[i];\n            setupCompoundStorage(node, binding);\n            addNotifyListener(node, inst, binding);\n          }\n        }\n        node.__dataHost = inst;\n      }\n    }\n  }\n\n  /**\n   * Initializes `__dataCompoundStorage` local storage on a bound node with\n   * initial literal data for compound bindings, and sets the joined\n   * literal parts to the bound property.\n   *\n   * When changes to compound parts occur, they are first set into the compound\n   * storage array for that property, and then the array is joined to result in\n   * the final value set to the property/attribute.\n   *\n   * @param {Node} node Bound node to initialize\n   * @param {Object} binding Binding metadata\n   * @private\n   */\n  function setupCompoundStorage(node, binding) {\n    if (binding.isCompound) {\n      // Create compound storage map\n      let storage = node.__dataCompoundStorage || (node.__dataCompoundStorage = {});\n      let parts = binding.parts;\n      // Copy literals from parts into storage for this binding\n      let literals = new Array(parts.length);\n      for (let j = 0; j < parts.length; j++) {\n        literals[j] = parts[j].literal;\n      }\n      let target = binding.target;\n      storage[target] = literals;\n      // Configure properties with their literal parts\n      if (binding.literal && binding.kind == 'property') {\n        node[target] = binding.literal;\n      }\n    }\n  }\n\n  /**\n   * Adds a 2-way binding notification event listener to the node specified\n   *\n   * @param {Object} node Child element to add listener to\n   * @param {Object} inst Host element instance to handle notification event\n   * @param {Object} binding Binding metadata\n   * @private\n   */\n  function addNotifyListener(node, inst, binding) {\n    if (binding.listenerEvent) {\n      let part = binding.parts[0];\n      node.addEventListener(binding.listenerEvent, function (e) {\n        handleNotification(e, inst, binding.target, part.source, part.negate);\n      });\n    }\n  }\n\n  // -- for method-based effects (complexObserver & computed) --------------\n\n  /**\n   * Adds property effects for each argument in the method signature (and\n   * optionally, for the method name if `dynamic` is true) that calls the\n   * provided effect function.\n   *\n   * @param {Element | Object} model Prototype or instance\n   * @param {Object} sig Method signature metadata\n   * @param {string} type Type of property effect to add\n   * @param {Function} effectFn Function to run when arguments change\n   * @param {*=} methodInfo Effect-specific information to be included in\n   *   method effect metadata\n   * @param {boolean|Object=} dynamicFn Boolean or object map indicating whether\n   *   method names should be included as a dependency to the effect. Note,\n   *   defaults to true if the signature is static (sig.static is true).\n   * @private\n   */\n  function createMethodEffect(model, sig, type, effectFn, methodInfo, dynamicFn) {\n    dynamicFn = sig.static || dynamicFn && (typeof dynamicFn !== 'object' || dynamicFn[sig.methodName]);\n    let info = {\n      methodName: sig.methodName,\n      args: sig.args,\n      methodInfo,\n      dynamicFn\n    };\n    for (let i = 0, arg; i < sig.args.length && (arg = sig.args[i]); i++) {\n      if (!arg.literal) {\n        model._addPropertyEffect(arg.rootProperty, type, {\n          fn: effectFn, info: info, trigger: arg\n        });\n      }\n    }\n    if (dynamicFn) {\n      model._addPropertyEffect(sig.methodName, type, {\n        fn: effectFn, info: info\n      });\n    }\n  }\n\n  /**\n   * Calls a method with arguments marshaled from properties on the instance\n   * based on the method signature contained in the effect metadata.\n   *\n   * Multi-property observers, computed properties, and inline computing\n   * functions call this function to invoke the method, then use the return\n   * value accordingly.\n   *\n   * @param {Object} inst The instance the effect will be run on\n   * @param {string} property Name of property\n   * @param {Object} props Bag of current property changes\n   * @param {Object} oldProps Bag of previous values for changed properties\n   * @param {Object} info Effect metadata\n   * @return {*} Returns the return value from the method invocation\n   * @private\n   */\n  function runMethodEffect(inst, property, props, oldProps, info) {\n    // Instances can optionally have a _methodHost which allows redirecting where\n    // to find methods. Currently used by `templatize`.\n    let context = inst._methodHost || inst;\n    let fn = context[info.methodName];\n    if (fn) {\n      let args = marshalArgs(inst.__data, info.args, property, props);\n      return fn.apply(context, args);\n    } else if (!info.dynamicFn) {\n      console.warn('method `' + info.methodName + '` not defined');\n    }\n  }\n\n  const emptyArray = [];\n\n  // Regular expressions used for binding\n  const IDENT = '(?:' + '[a-zA-Z_$][\\\\w.:$\\\\-*]*' + ')';\n  const NUMBER = '(?:' + '[-+]?[0-9]*\\\\.?[0-9]+(?:[eE][-+]?[0-9]+)?' + ')';\n  const SQUOTE_STRING = '(?:' + '\\'(?:[^\\'\\\\\\\\]|\\\\\\\\.)*\\'' + ')';\n  const DQUOTE_STRING = '(?:' + '\"(?:[^\"\\\\\\\\]|\\\\\\\\.)*\"' + ')';\n  const STRING = '(?:' + SQUOTE_STRING + '|' + DQUOTE_STRING + ')';\n  const ARGUMENT = '(?:' + IDENT + '|' + NUMBER + '|' + STRING + '\\\\s*' + ')';\n  const ARGUMENTS = '(?:' + ARGUMENT + '(?:,\\\\s*' + ARGUMENT + ')*' + ')';\n  const ARGUMENT_LIST = '(?:' + '\\\\(\\\\s*' + '(?:' + ARGUMENTS + '?' + ')' + '\\\\)\\\\s*' + ')';\n  const BINDING = '(' + IDENT + '\\\\s*' + ARGUMENT_LIST + '?' + ')'; // Group 3\n  const OPEN_BRACKET = '(\\\\[\\\\[|{{)' + '\\\\s*';\n  const CLOSE_BRACKET = '(?:]]|}})';\n  const NEGATE = '(?:(!)\\\\s*)?'; // Group 2\n  const EXPRESSION = OPEN_BRACKET + NEGATE + BINDING + CLOSE_BRACKET;\n  const bindingRegex = new RegExp(EXPRESSION, \"g\");\n\n  function literalFromParts(parts) {\n    let s = '';\n    for (let i = 0; i < parts.length; i++) {\n      let literal = parts[i].literal;\n      s += literal || '';\n    }\n    return s;\n  }\n\n  /**\n   * Parses an expression string for a method signature, and returns a metadata\n   * describing the method in terms of `methodName`, `static` (whether all the\n   * arguments are literals), and an array of `args`\n   *\n   * @param {string} expression The expression to parse\n   * @return {?Object} The method metadata object if a method expression was\n   *   found, otherwise `undefined`\n   * @private\n   */\n  function parseMethod(expression) {\n    // tries to match valid javascript property names\n    let m = expression.match(/([^\\s]+?)\\(([\\s\\S]*)\\)/);\n    if (m) {\n      let methodName = m[1];\n      let sig = { methodName, static: true };\n      if (m[2].trim()) {\n        // replace escaped commas with comma entity, split on un-escaped commas\n        let args = m[2].replace(/\\\\,/g, '&comma;').split(',');\n        return parseArgs(args, sig);\n      } else {\n        sig.args = emptyArray;\n        return sig;\n      }\n    }\n    return null;\n  }\n\n  /**\n   * Parses an array of arguments and sets the `args` property of the supplied\n   * signature metadata object. Sets the `static` property to false if any\n   * argument is a non-literal.\n   *\n   * @param {Array<string>} argList Array of argument names\n   * @param {Object} sig Method signature metadata object\n   * @return {Object} The updated signature metadata object\n   * @private\n   */\n  function parseArgs(argList, sig) {\n    sig.args = argList.map(function (rawArg) {\n      let arg = parseArg(rawArg);\n      if (!arg.literal) {\n        sig.static = false;\n      }\n      return arg;\n    }, this);\n    return sig;\n  }\n\n  /**\n   * Parses an individual argument, and returns an argument metadata object\n   * with the following fields:\n   *\n   *   {\n   *     value: 'prop',        // property/path or literal value\n   *     literal: false,       // whether argument is a literal\n   *     structured: false,    // whether the property is a path\n   *     rootProperty: 'prop', // the root property of the path\n   *     wildcard: false       // whether the argument was a wildcard '.*' path\n   *   }\n   *\n   * @param {string} rawArg The string value of the argument\n   * @return {Object} Argument metadata object\n   * @private\n   */\n  function parseArg(rawArg) {\n    // clean up whitespace\n    let arg = rawArg.trim()\n    // replace comma entity with comma\n    .replace(/&comma;/g, ',')\n    // repair extra escape sequences; note only commas strictly need\n    // escaping, but we allow any other char to be escaped since its\n    // likely users will do this\n    .replace(/\\\\(.)/g, '\\$1');\n    // basic argument descriptor\n    let a = {\n      name: arg\n    };\n    // detect literal value (must be String or Number)\n    let fc = arg[0];\n    if (fc === '-') {\n      fc = arg[1];\n    }\n    if (fc >= '0' && fc <= '9') {\n      fc = '#';\n    }\n    switch (fc) {\n      case \"'\":\n      case '\"':\n        a.value = arg.slice(1, -1);\n        a.literal = true;\n        break;\n      case '#':\n        a.value = Number(arg);\n        a.literal = true;\n        break;\n    }\n    // if not literal, look for structured path\n    if (!a.literal) {\n      a.rootProperty = Polymer.Path.root(arg);\n      // detect structured path (has dots)\n      a.structured = Polymer.Path.isPath(arg);\n      if (a.structured) {\n        a.wildcard = arg.slice(-2) == '.*';\n        if (a.wildcard) {\n          a.name = arg.slice(0, -2);\n        }\n      }\n    }\n    return a;\n  }\n\n  /**\n   * Gather the argument values for a method specified in the provided array\n   * of argument metadata.\n   *\n   * The `path` and `value` arguments are used to fill in wildcard descriptor\n   * when the method is being called as a result of a path notification.\n   *\n   * @param {Object} data Instance data storage object to read properties from\n   * @param {Array<Object>} args Array of argument metadata\n   * @param {string} path Property/path name that triggered the method effect\n   * @param {Object} props Bag of current property changes\n   * @return {Array<*>} Array of argument values\n   * @private\n   */\n  function marshalArgs(data, args, path, props) {\n    let values = [];\n    for (let i = 0, l = args.length; i < l; i++) {\n      let arg = args[i];\n      let name = arg.name;\n      let v;\n      if (arg.literal) {\n        v = arg.value;\n      } else {\n        if (arg.structured) {\n          v = Polymer.Path.get(data, name);\n          // when data is not stored e.g. `splices`\n          if (v === undefined) {\n            v = props[name];\n          }\n        } else {\n          v = data[name];\n        }\n      }\n      if (arg.wildcard) {\n        // Only send the actual path changed info if the change that\n        // caused the observer to run matched the wildcard\n        let baseChanged = name.indexOf(path + '.') === 0;\n        let matches = path.indexOf(name) === 0 && !baseChanged;\n        values[i] = {\n          path: matches ? path : name,\n          value: matches ? props[path] : v,\n          base: v\n        };\n      } else {\n        values[i] = v;\n      }\n    }\n    return values;\n  }\n\n  // data api\n\n  /**\n   * Sends array splice notifications (`.splices` and `.length`)\n   *\n   * Note: this implementation only accepts normalized paths\n   *\n   * @param {Element} inst Instance to send notifications to\n   * @param {Array} array The array the mutations occurred on\n   * @param {string} path The path to the array that was mutated\n   * @param {Array} splices Array of splice records\n   * @private\n   */\n  function notifySplices(inst, array, path, splices) {\n    let splicesPath = path + '.splices';\n    inst.notifyPath(splicesPath, { indexSplices: splices });\n    inst.notifyPath(path + '.length', array.length);\n    // Null here to allow potentially large splice records to be GC'ed.\n    inst.__data[splicesPath] = { indexSplices: null };\n  }\n\n  /**\n   * Creates a splice record and sends an array splice notification for\n   * the described mutation\n   *\n   * Note: this implementation only accepts normalized paths\n   *\n   * @param {Element} inst Instance to send notifications to\n   * @param {Array} array The array the mutations occurred on\n   * @param {string} path The path to the array that was mutated\n   * @param {number} index Index at which the array mutation occurred\n   * @param {number} addedCount Number of added items\n   * @param {Array} removed Array of removed items\n   * @private\n   */\n  function notifySplice(inst, array, path, index, addedCount, removed) {\n    notifySplices(inst, array, path, [{\n      index: index,\n      addedCount: addedCount,\n      removed: removed,\n      object: array,\n      type: 'splice'\n    }]);\n  }\n\n  /**\n   * Returns an upper-cased version of the string.\n   *\n   * @param {string} name String to uppercase\n   * @return {string} Uppercased string\n   * @private\n   */\n  function upper(name) {\n    return name[0].toUpperCase() + name.substring(1);\n  }\n\n  /**\n   * Element class mixin that provides meta-programming for Polymer's template\n   * binding and data observation (collectively, \"property effects\") system.\n   *\n   * This mixin uses provides the following key static methods for adding\n   * property effects to an element class:\n   * - `addPropertyEffect`\n   * - `createPropertyObserver`\n   * - `createMethodObserver`\n   * - `createNotifyingProperty`\n   * - `createReadOnlyProperty`\n   * - `createReflectedProperty`\n   * - `createComputedProperty`\n   * - `bindTemplate`\n   *\n   * Each method creates one or more property accessors, along with metadata\n   * used by this mixin's implementation of `_propertiesChanged` to perform\n   * the property effects.\n   *\n   * Underscored versions of the above methods also exist on the element\n   * prototype for adding property effects on instances at runtime.\n   *\n   * Note that this mixin overrides several `PropertyAccessors` methods, in\n   * many cases to maintain guarantees provided by the Polymer 1.x features;\n   * notably it changes property accessors to be synchronous by default\n   * whereas the default when using `PropertyAccessors` standalone is to be\n   * async by default.\n   *\n   * @polymerMixin\n   * @mixes Polymer.TemplateStamp\n   * @mixes Polymer.PropertyAccessors\n   * @memberof Polymer\n   * @summary Element class mixin that provides meta-programming for Polymer's\n   * template binding and data observation system.\n   */\n  Polymer.PropertyEffects = Polymer.dedupingMixin(superClass => {\n\n    /**\n     * @constructor\n     * @extends {superClass}\n     * @implements {Polymer_PropertyAccessors}\n     * @implements {Polymer_TemplateStamp}\n     */\n    const propertyEffectsBase = Polymer.TemplateStamp(Polymer.PropertyAccessors(superClass));\n\n    /**\n     * @polymerMixinClass\n     * @unrestricted\n     * @implements {Polymer_PropertyEffects}\n     */\n    class PropertyEffects extends propertyEffectsBase {\n\n      get PROPERTY_EFFECT_TYPES() {\n        return TYPES;\n      }\n\n      /**\n       * Overrides `Polymer.PropertyAccessors` implementation to initialize\n       * additional property-effect related properties.\n       *\n       * @override\n       */\n      _initializeProperties() {\n        super._initializeProperties();\n        hostStack.registerHost(this);\n        this.__dataClientsReady = false;\n        this.__dataPendingClients = null;\n        this.__dataToNotify = null;\n        this.__dataLinkedPaths = null;\n        this.__dataHasPaths = false;\n        // May be set on instance prior to upgrade\n        this.__dataCompoundStorage = this.__dataCompoundStorage || null;\n        this.__dataHost = this.__dataHost || null;\n        this.__dataTemp = {};\n      }\n\n      /**\n       * Overrides `Polymer.PropertyAccessors` implementation to provide a\n       * more efficient implementation of initializing properties from\n       * the prototype on the instance.\n       *\n       * @override\n       */\n      _initializeProtoProperties(props) {\n        this.__data = Object.create(props);\n        this.__dataPending = Object.create(props);\n        this.__dataOld = {};\n      }\n\n      /**\n       * Overrides `Polymer.PropertyAccessors` implementation to avoid setting\n       * `_setProperty`'s `shouldNotify: true`.\n       *\n       * @override\n       */\n      _initializeInstanceProperties(props) {\n        let readOnly = this.__readOnly;\n        for (let prop in props) {\n          if (!readOnly || !readOnly[prop]) {\n            this.__dataPending = this.__dataPending || {};\n            this.__dataOld = this.__dataOld || {};\n            this.__data[prop] = this.__dataPending[prop] = props[prop];\n          }\n        }\n      }\n\n      // Prototype setup ----------------------------------------\n\n      /**\n       * Equivalent to static `addPropertyEffect` API but can be called on\n       * an instance to add effects at runtime.  See that method for\n       * full API docs.\n       *\n       * @param {string} property Property that should trigger the effect\n       * @param {string} type Effect type, from this.PROPERTY_EFFECT_TYPES\n       * @param {Object=} effect Effect metadata object\n       * @protected\n       */\n      _addPropertyEffect(property, type, effect) {\n        this._createPropertyAccessor(property, type == TYPES.READ_ONLY);\n        // effects are accumulated into arrays per property based on type\n        let effects = ensureOwnEffectMap(this, type)[property];\n        if (!effects) {\n          effects = this[type][property] = [];\n        }\n        effects.push(effect);\n      }\n\n      /**\n       * Removes the given property effect.\n       *\n       * @param {string} property Property the effect was associated with\n       * @param {string} type Effect type, from this.PROPERTY_EFFECT_TYPES\n       * @param {Object=} effect Effect metadata object to remove\n       */\n      _removePropertyEffect(property, type, effect) {\n        let effects = ensureOwnEffectMap(this, type)[property];\n        let idx = effects.indexOf(effect);\n        if (idx >= 0) {\n          effects.splice(idx, 1);\n        }\n      }\n\n      /**\n       * Returns whether the current prototype/instance has a property effect\n       * of a certain type.\n       *\n       * @param {string} property Property name\n       * @param {string=} type Effect type, from this.PROPERTY_EFFECT_TYPES\n       * @return {boolean} True if the prototype/instance has an effect of this type\n       * @protected\n       */\n      _hasPropertyEffect(property, type) {\n        let effects = this[type];\n        return Boolean(effects && effects[property]);\n      }\n\n      /**\n       * Returns whether the current prototype/instance has a \"read only\"\n       * accessor for the given property.\n       *\n       * @param {string} property Property name\n       * @return {boolean} True if the prototype/instance has an effect of this type\n       * @protected\n       */\n      _hasReadOnlyEffect(property) {\n        return this._hasPropertyEffect(property, TYPES.READ_ONLY);\n      }\n\n      /**\n       * Returns whether the current prototype/instance has a \"notify\"\n       * property effect for the given property.\n       *\n       * @param {string} property Property name\n       * @return {boolean} True if the prototype/instance has an effect of this type\n       * @protected\n       */\n      _hasNotifyEffect(property) {\n        return this._hasPropertyEffect(property, TYPES.NOTIFY);\n      }\n\n      /**\n       * Returns whether the current prototype/instance has a \"reflect to attribute\"\n       * property effect for the given property.\n       *\n       * @param {string} property Property name\n       * @return {boolean} True if the prototype/instance has an effect of this type\n       * @protected\n       */\n      _hasReflectEffect(property) {\n        return this._hasPropertyEffect(property, TYPES.REFLECT);\n      }\n\n      /**\n       * Returns whether the current prototype/instance has a \"computed\"\n       * property effect for the given property.\n       *\n       * @param {string} property Property name\n       * @return {boolean} True if the prototype/instance has an effect of this type\n       * @protected\n       */\n      _hasComputedEffect(property) {\n        return this._hasPropertyEffect(property, TYPES.COMPUTE);\n      }\n\n      // Runtime ----------------------------------------\n\n      /**\n       * Sets a pending property or path.  If the root property of the path in\n       * question had no accessor, the path is set, otherwise it is enqueued\n       * via `_setPendingProperty`.\n       *\n       * This function isolates relatively expensive functionality necessary\n       * for the public API (`set`, `setProperties`, `notifyPath`, and property\n       * change listeners via {{...}} bindings), such that it is only done\n       * when paths enter the system, and not at every propagation step.  It\n       * also sets a `__dataHasPaths` flag on the instance which is used to\n       * fast-path slower path-matching code in the property effects host paths.\n       *\n       * `path` can be a path string or array of path parts as accepted by the\n       * public API.\n       *\n       * @param {string | !Array<number|string>} path Path to set\n       * @param {*} value Value to set\n       * @param {boolean=} shouldNotify Set to true if this change should\n       *  cause a property notification event dispatch\n       * @param {boolean=} isPathNotification If the path being set is a path\n       *   notification of an already changed value, as opposed to a request\n       *   to set and notify the change.  In the latter `false` case, a dirty\n       *   check is performed and then the value is set to the path before\n       *   enqueuing the pending property change.\n       * @return {boolean} Returns true if the property/path was enqueued in\n       *   the pending changes bag.\n       * @protected\n       */\n      _setPendingPropertyOrPath(path, value, shouldNotify, isPathNotification) {\n        if (isPathNotification || Polymer.Path.root(Array.isArray(path) ? path[0] : path) !== path) {\n          // Dirty check changes being set to a path against the actual object,\n          // since this is the entry point for paths into the system; from here\n          // the only dirty checks are against the `__dataTemp` cache to prevent\n          // duplicate work in the same turn only. Note, if this was a notification\n          // of a change already set to a path (isPathNotification: true),\n          // we always let the change through and skip the `set` since it was\n          // already dirty checked at the point of entry and the underlying\n          // object has already been updated\n          if (!isPathNotification) {\n            let old = Polymer.Path.get(this, path);\n            path = /** @type {string} */Polymer.Path.set(this, path, value);\n            // Use property-accessor's simpler dirty check\n            if (!path || !super._shouldPropertyChange(path, value, old)) {\n              return false;\n            }\n          }\n          this.__dataHasPaths = true;\n          if (this._setPendingProperty(path, value, shouldNotify)) {\n            computeLinkedPaths(this, path, value);\n            return true;\n          }\n        } else {\n          if (this.__dataHasAccessor && this.__dataHasAccessor[path]) {\n            return this._setPendingProperty(path, value, shouldNotify);\n          } else {\n            this[path] = value;\n          }\n        }\n        return false;\n      }\n\n      /**\n       * Applies a value to a non-Polymer element/node's property.\n       *\n       * The implementation makes a best-effort at binding interop:\n       * Some native element properties have side-effects when\n       * re-setting the same value (e.g. setting `<input>.value` resets the\n       * cursor position), so we do a dirty-check before setting the value.\n       * However, for better interop with non-Polymer custom elements that\n       * accept objects, we explicitly re-set object changes coming from the\n       * Polymer world (which may include deep object changes without the\n       * top reference changing), erring on the side of providing more\n       * information.\n       *\n       * Users may override this method to provide alternate approaches.\n       *\n       * @param {Node} node The node to set a property on\n       * @param {string} prop The property to set\n       * @param {*} value The value to set\n       * @protected\n       */\n      _setUnmanagedPropertyToNode(node, prop, value) {\n        // It is a judgment call that resetting primitives is\n        // \"bad\" and resettings objects is also \"good\"; alternatively we could\n        // implement a whitelist of tag & property values that should never\n        // be reset (e.g. <input>.value && <select>.value)\n        if (value !== node[prop] || typeof value == 'object') {\n          node[prop] = value;\n        }\n      }\n\n      /**\n       * Overrides the `PropertyAccessors` implementation to introduce special\n       * dirty check logic depending on the property & value being set:\n       *\n       * 1. Any value set to a path (e.g. 'obj.prop': 42 or 'obj.prop': {...})\n       *    Stored in `__dataTemp`, dirty checked against `__dataTemp`\n       * 2. Object set to simple property (e.g. 'prop': {...})\n       *    Stored in `__dataTemp` and `__data`, dirty checked against\n       *    `__dataTemp` by default implementation of `_shouldPropertyChange`\n       * 3. Primitive value set to simple property (e.g. 'prop': 42)\n       *    Stored in `__data`, dirty checked against `__data`\n       *\n       * The dirty-check is important to prevent cycles due to two-way\n       * notification, but paths and objects are only dirty checked against any\n       * previous value set during this turn via a \"temporary cache\" that is\n       * cleared when the last `_propertiesChaged` exits. This is so:\n       * a. any cached array paths (e.g. 'array.3.prop') may be invalidated\n       *    due to array mutations like shift/unshift/splice; this is fine\n       *    since path changes are dirty-checked at user entry points like `set`\n       * b. dirty-checking for objects only lasts one turn to allow the user\n       *    to mutate the object in-place and re-set it with the same identity\n       *    and have all sub-properties re-propagated in a subsequent turn.\n       *\n       * The temp cache is not necessarily sufficient to prevent invalid array\n       * paths, since a splice can happen during the same turn (with pathological\n       * user code); we could introduce a \"fixup\" for temporarily cached array\n       * paths if needed: https://github.com/Polymer/polymer/issues/4227\n       *\n       * @override\n       */\n      _setPendingProperty(property, value, shouldNotify) {\n        let isPath = this.__dataHasPaths && Polymer.Path.isPath(property);\n        let prevProps = isPath ? this.__dataTemp : this.__data;\n        if (this._shouldPropertyChange(property, value, prevProps[property])) {\n          if (!this.__dataPending) {\n            this.__dataPending = {};\n            this.__dataOld = {};\n          }\n          // Ensure old is captured from the last turn\n          if (!(property in this.__dataOld)) {\n            this.__dataOld[property] = this.__data[property];\n          }\n          // Paths are stored in temporary cache (cleared at end of turn),\n          // which is used for dirty-checking, all others stored in __data\n          if (isPath) {\n            this.__dataTemp[property] = value;\n          } else {\n            this.__data[property] = value;\n          }\n          // All changes go into pending property bag, passed to _propertiesChanged\n          this.__dataPending[property] = value;\n          // Track properties that should notify separately\n          if (isPath || this.__notifyEffects && this.__notifyEffects[property]) {\n            this.__dataToNotify = this.__dataToNotify || {};\n            this.__dataToNotify[property] = shouldNotify;\n          }\n          return true;\n        }\n      }\n\n      /**\n       * Overrides base implementation to ensure all accessors set `shouldNotify`\n       * to true, for per-property notification tracking.\n       *\n       * @override\n       */\n      _setProperty(property, value) {\n        if (this._setPendingProperty(property, value, true)) {\n          this._invalidateProperties();\n        }\n      }\n\n      /**\n       * Overrides `PropertyAccessor`'s default async queuing of\n       * `_propertiesChanged`: if `__dataReady` is false (has not yet been\n       * manually flushed), the function no-ops; otherwise flushes\n       * `_propertiesChanged` synchronously.\n       *\n       * @override\n       */\n      _invalidateProperties() {\n        if (this.__dataReady) {\n          this._flushProperties();\n        }\n      }\n\n      /**\n       * Enqueues the given client on a list of pending clients, whose\n       * pending property changes can later be flushed via a call to\n       * `_flushClients`.\n       *\n       * @param {Object} client PropertyEffects client to enqueue\n       * @protected\n       */\n      _enqueueClient(client) {\n        this.__dataPendingClients = this.__dataPendingClients || [];\n        if (client !== this) {\n          this.__dataPendingClients.push(client);\n        }\n      }\n\n      /**\n       * Flushes any clients previously enqueued via `_enqueueClient`, causing\n       * their `_flushProperties` method to run.\n       *\n       * @protected\n       */\n      _flushClients() {\n        if (!this.__dataClientsReady) {\n          this.__dataClientsReady = true;\n          this._readyClients();\n          // Override point where accessors are turned on; importantly,\n          // this is after clients have fully readied, providing a guarantee\n          // that any property effects occur only after all clients are ready.\n          this.__dataReady = true;\n        } else {\n          this.__enableOrFlushClients();\n        }\n      }\n\n      // NOTE: We ensure clients either enable or flush as appropriate. This\n      // handles two corner cases:\n      // (1) clients flush properly when connected/enabled before the host\n      // enables; e.g.\n      //   (a) Templatize stamps with no properties and does not flush and\n      //   (b) the instance is inserted into dom and\n      //   (c) then the instance flushes.\n      // (2) clients enable properly when not connected/enabled when the host\n      // flushes; e.g.\n      //   (a) a template is runtime stamped and not yet connected/enabled\n      //   (b) a host sets a property, causing stamped dom to flush\n      //   (c) the stamped dom enables.\n      __enableOrFlushClients() {\n        let clients = this.__dataPendingClients;\n        if (clients) {\n          this.__dataPendingClients = null;\n          for (let i = 0; i < clients.length; i++) {\n            let client = clients[i];\n            if (!client.__dataEnabled) {\n              client._enableProperties();\n            } else if (client.__dataPending) {\n              client._flushProperties();\n            }\n          }\n        }\n      }\n\n      /**\n       * Perform any initial setup on client dom. Called before the first\n       * `_flushProperties` call on client dom and before any element\n       * observers are called.\n       *\n       * @protected\n       */\n      _readyClients() {\n        this.__enableOrFlushClients();\n      }\n\n      /**\n       * Sets a bag of property changes to this instance, and\n       * synchronously processes all effects of the properties as a batch.\n       *\n       * Property names must be simple properties, not paths.  Batched\n       * path propagation is not supported.\n       *\n       * @param {Object} props Bag of one or more key-value pairs whose key is\n       *   a property and value is the new value to set for that property.\n       * @param {boolean=} setReadOnly When true, any private values set in\n       *   `props` will be set. By default, `setProperties` will not set\n       *   `readOnly: true` root properties.\n       * @public\n       */\n      setProperties(props, setReadOnly) {\n        for (let path in props) {\n          if (setReadOnly || !this.__readOnly || !this.__readOnly[path]) {\n            //TODO(kschaaf): explicitly disallow paths in setProperty?\n            // wildcard observers currently only pass the first changed path\n            // in the `info` object, and you could do some odd things batching\n            // paths, e.g. {'foo.bar': {...}, 'foo': null}\n            this._setPendingPropertyOrPath(path, props[path], true);\n          }\n        }\n        this._invalidateProperties();\n      }\n\n      /**\n       * Overrides `PropertyAccessors` so that property accessor\n       * side effects are not enabled until after client dom is fully ready.\n       * Also calls `_flushClients` callback to ensure client dom is enabled\n       * that was not enabled as a result of flushing properties.\n       *\n       * @override\n       */\n      ready() {\n        // It is important that `super.ready()` is not called here as it\n        // immediately turns on accessors. Instead, we wait until `readyClients`\n        // to enable accessors to provide a guarantee that clients are ready\n        // before processing any accessors side effects.\n        this._flushProperties();\n        // If no data was pending, `_flushProperties` will not `flushClients`\n        // so ensure this is done.\n        if (!this.__dataClientsReady) {\n          this._flushClients();\n        }\n        // Before ready, client notifications do not trigger _flushProperties.\n        // Therefore a flush is necessary here if data has been set.\n        if (this.__dataPending) {\n          this._flushProperties();\n        }\n      }\n\n      /**\n       * Implements `PropertyAccessors`'s properties changed callback.\n       *\n       * Runs each class of effects for the batch of changed properties in\n       * a specific order (compute, propagate, reflect, observe, notify).\n       *\n       * @override\n       */\n      _propertiesChanged(currentProps, changedProps, oldProps) {\n        // ----------------------------\n        // let c = Object.getOwnPropertyNames(changedProps || {});\n        // window.debug && console.group(this.localName + '#' + this.id + ': ' + c);\n        // if (window.debug) { debugger; }\n        // ----------------------------\n        let hasPaths = this.__dataHasPaths;\n        this.__dataHasPaths = false;\n        // Compute properties\n        runComputedEffects(this, changedProps, oldProps, hasPaths);\n        // Clear notify properties prior to possible reentry (propagate, observe),\n        // but after computing effects have a chance to add to them\n        let notifyProps = this.__dataToNotify;\n        this.__dataToNotify = null;\n        // Propagate properties to clients\n        this._propagatePropertyChanges(changedProps, oldProps, hasPaths);\n        // Flush clients\n        this._flushClients();\n        // Reflect properties\n        runEffects(this, this.__reflectEffects, changedProps, oldProps, hasPaths);\n        // Observe properties\n        runEffects(this, this.__observeEffects, changedProps, oldProps, hasPaths);\n        // Notify properties to host\n        if (notifyProps) {\n          runNotifyEffects(this, notifyProps, changedProps, oldProps, hasPaths);\n        }\n        // Clear temporary cache at end of turn\n        if (this.__dataCounter == 1) {\n          this.__dataTemp = {};\n        }\n        // ----------------------------\n        // window.debug && console.groupEnd(this.localName + '#' + this.id + ': ' + c);\n        // ----------------------------\n      }\n\n      /**\n       * Called to propagate any property changes to stamped template nodes\n       * managed by this element.\n       *\n       * @param {Object} changedProps Bag of changed properties\n       * @param {Object} oldProps Bag of previous values for changed properties\n       * @param {boolean} hasPaths True with `props` contains one or more paths\n       * @protected\n       */\n      _propagatePropertyChanges(changedProps, oldProps, hasPaths) {\n        if (this.__propagateEffects) {\n          runEffects(this, this.__propagateEffects, changedProps, oldProps, hasPaths);\n        }\n        let templateInfo = this.__templateInfo;\n        while (templateInfo) {\n          runEffects(this, templateInfo.propertyEffects, changedProps, oldProps, hasPaths, templateInfo.nodeList);\n          templateInfo = templateInfo.nextTemplateInfo;\n        }\n      }\n\n      /**\n       * Aliases one data path as another, such that path notifications from one\n       * are routed to the other.\n       *\n       * @param {string | !Array<string|number>} to Target path to link.\n       * @param {string | !Array<string|number>} from Source path to link.\n       * @public\n       */\n      linkPaths(to, from) {\n        to = Polymer.Path.normalize(to);\n        from = Polymer.Path.normalize(from);\n        this.__dataLinkedPaths = this.__dataLinkedPaths || {};\n        this.__dataLinkedPaths[to] = from;\n      }\n\n      /**\n       * Removes a data path alias previously established with `_linkPaths`.\n       *\n       * Note, the path to unlink should be the target (`to`) used when\n       * linking the paths.\n       *\n       * @param {string | !Array<string|number>} path Target path to unlink.\n       * @public\n       */\n      unlinkPaths(path) {\n        path = Polymer.Path.normalize(path);\n        if (this.__dataLinkedPaths) {\n          delete this.__dataLinkedPaths[path];\n        }\n      }\n\n      /**\n       * Notify that an array has changed.\n       *\n       * Example:\n       *\n       *     this.items = [ {name: 'Jim'}, {name: 'Todd'}, {name: 'Bill'} ];\n       *     ...\n       *     this.items.splice(1, 1, {name: 'Sam'});\n       *     this.items.push({name: 'Bob'});\n       *     this.notifySplices('items', [\n       *       { index: 1, removed: [{name: 'Todd'}], addedCount: 1, obect: this.items, type: 'splice' },\n       *       { index: 3, removed: [], addedCount: 1, object: this.items, type: 'splice'}\n       *     ]);\n       *\n       * @param {string} path Path that should be notified.\n       * @param {Array} splices Array of splice records indicating ordered\n       *   changes that occurred to the array. Each record should have the\n       *   following fields:\n       *    * index: index at which the change occurred\n       *    * removed: array of items that were removed from this index\n       *    * addedCount: number of new items added at this index\n       *    * object: a reference to the array in question\n       *    * type: the string literal 'splice'\n       *\n       *   Note that splice records _must_ be normalized such that they are\n       *   reported in index order (raw results from `Object.observe` are not\n       *   ordered and must be normalized/merged before notifying).\n       * @public\n      */\n      notifySplices(path, splices) {\n        let info = {};\n        let array = /** @type {Array} */Polymer.Path.get(this, path, info);\n        notifySplices(this, array, info.path, splices);\n      }\n\n      /**\n       * Convenience method for reading a value from a path.\n       *\n       * Note, if any part in the path is undefined, this method returns\n       * `undefined` (this method does not throw when dereferencing undefined\n       * paths).\n       *\n       * @param {(string|!Array<(string|number)>)} path Path to the value\n       *   to read.  The path may be specified as a string (e.g. `foo.bar.baz`)\n       *   or an array of path parts (e.g. `['foo.bar', 'baz']`).  Note that\n       *   bracketed expressions are not supported; string-based path parts\n       *   *must* be separated by dots.  Note that when dereferencing array\n       *   indices, the index may be used as a dotted part directly\n       *   (e.g. `users.12.name` or `['users', 12, 'name']`).\n       * @param {Object=} root Root object from which the path is evaluated.\n       * @return {*} Value at the path, or `undefined` if any part of the path\n       *   is undefined.\n       * @public\n       */\n      get(path, root) {\n        return Polymer.Path.get(root || this, path);\n      }\n\n      /**\n       * Convenience method for setting a value to a path and notifying any\n       * elements bound to the same path.\n       *\n       * Note, if any part in the path except for the last is undefined,\n       * this method does nothing (this method does not throw when\n       * dereferencing undefined paths).\n       *\n       * @param {(string|!Array<(string|number)>)} path Path to the value\n       *   to write.  The path may be specified as a string (e.g. `'foo.bar.baz'`)\n       *   or an array of path parts (e.g. `['foo.bar', 'baz']`).  Note that\n       *   bracketed expressions are not supported; string-based path parts\n       *   *must* be separated by dots.  Note that when dereferencing array\n       *   indices, the index may be used as a dotted part directly\n       *   (e.g. `'users.12.name'` or `['users', 12, 'name']`).\n       * @param {*} value Value to set at the specified path.\n       * @param {Object=} root Root object from which the path is evaluated.\n       *   When specified, no notification will occur.\n       * @public\n      */\n      set(path, value, root) {\n        if (root) {\n          Polymer.Path.set(root, path, value);\n        } else {\n          if (!this.__readOnly || !this.__readOnly[/** @type {string} */path]) {\n            if (this._setPendingPropertyOrPath(path, value, true)) {\n              this._invalidateProperties();\n            }\n          }\n        }\n      }\n\n      /**\n       * Adds items onto the end of the array at the path specified.\n       *\n       * The arguments after `path` and return value match that of\n       * `Array.prototype.push`.\n       *\n       * This method notifies other paths to the same array that a\n       * splice occurred to the array.\n       *\n       * @param {string} path Path to array.\n       * @param {...*} items Items to push onto array\n       * @return {number} New length of the array.\n       * @public\n       */\n      push(path, ...items) {\n        let info = {};\n        let array = /** @type {Array}*/Polymer.Path.get(this, path, info);\n        let len = array.length;\n        let ret = array.push(...items);\n        if (items.length) {\n          notifySplice(this, array, info.path, len, items.length, []);\n        }\n        return ret;\n      }\n\n      /**\n       * Removes an item from the end of array at the path specified.\n       *\n       * The arguments after `path` and return value match that of\n       * `Array.prototype.pop`.\n       *\n       * This method notifies other paths to the same array that a\n       * splice occurred to the array.\n       *\n       * @param {string} path Path to array.\n       * @return {*} Item that was removed.\n       * @public\n       */\n      pop(path) {\n        let info = {};\n        let array = /** @type {Array} */Polymer.Path.get(this, path, info);\n        let hadLength = Boolean(array.length);\n        let ret = array.pop();\n        if (hadLength) {\n          notifySplice(this, array, info.path, array.length, 0, [ret]);\n        }\n        return ret;\n      }\n\n      /**\n       * Starting from the start index specified, removes 0 or more items\n       * from the array and inserts 0 or more new items in their place.\n       *\n       * The arguments after `path` and return value match that of\n       * `Array.prototype.splice`.\n       *\n       * This method notifies other paths to the same array that a\n       * splice occurred to the array.\n       *\n       * @param {string} path Path to array.\n       * @param {number} start Index from which to start removing/inserting.\n       * @param {number} deleteCount Number of items to remove.\n       * @param {...*} items Items to insert into array.\n       * @return {Array} Array of removed items.\n       * @public\n       */\n      splice(path, start, deleteCount, ...items) {\n        let info = {};\n        let array = /** @type {Array} */Polymer.Path.get(this, path, info);\n        // Normalize fancy native splice handling of crazy start values\n        if (start < 0) {\n          start = array.length - Math.floor(-start);\n        } else {\n          start = Math.floor(start);\n        }\n        if (!start) {\n          start = 0;\n        }\n        let ret = array.splice(start, deleteCount, ...items);\n        if (items.length || ret.length) {\n          notifySplice(this, array, info.path, start, items.length, ret);\n        }\n        return ret;\n      }\n\n      /**\n       * Removes an item from the beginning of array at the path specified.\n       *\n       * The arguments after `path` and return value match that of\n       * `Array.prototype.pop`.\n       *\n       * This method notifies other paths to the same array that a\n       * splice occurred to the array.\n       *\n       * @param {string} path Path to array.\n       * @return {*} Item that was removed.\n       * @public\n       */\n      shift(path) {\n        let info = {};\n        let array = /** @type {Array} */Polymer.Path.get(this, path, info);\n        let hadLength = Boolean(array.length);\n        let ret = array.shift();\n        if (hadLength) {\n          notifySplice(this, array, info.path, 0, 0, [ret]);\n        }\n        return ret;\n      }\n\n      /**\n       * Adds items onto the beginning of the array at the path specified.\n       *\n       * The arguments after `path` and return value match that of\n       * `Array.prototype.push`.\n       *\n       * This method notifies other paths to the same array that a\n       * splice occurred to the array.\n       *\n       * @param {string} path Path to array.\n       * @param {...*} items Items to insert info array\n       * @return {number} New length of the array.\n       * @public\n       */\n      unshift(path, ...items) {\n        let info = {};\n        let array = /** @type {Array} */Polymer.Path.get(this, path, info);\n        let ret = array.unshift(...items);\n        if (items.length) {\n          notifySplice(this, array, info.path, 0, items.length, []);\n        }\n        return ret;\n      }\n\n      /**\n       * Notify that a path has changed.\n       *\n       * Example:\n       *\n       *     this.item.user.name = 'Bob';\n       *     this.notifyPath('item.user.name');\n       *\n       * @param {string} path Path that should be notified.\n       * @param {*=} value Value at the path (optional).\n       * @public\n      */\n      notifyPath(path, value) {\n        /** @type {string} */\n        let propPath;\n        if (arguments.length == 1) {\n          // Get value if not supplied\n          let info = {};\n          value = Polymer.Path.get(this, path, info);\n          propPath = info.path;\n        } else if (Array.isArray(path)) {\n          // Normalize path if needed\n          propPath = Polymer.Path.normalize(path);\n        } else {\n          propPath = /** @type{string} */path;\n        }\n        if (this._setPendingPropertyOrPath(propPath, value, true, true)) {\n          this._invalidateProperties();\n        }\n      }\n\n      /**\n       * Equivalent to static `createReadOnlyProperty` API but can be called on\n       * an instance to add effects at runtime.  See that method for\n       * full API docs.\n       *\n       * @param {string} property Property name\n       * @param {boolean=} protectedSetter Creates a custom protected setter\n       *   when `true`.\n       * @protected\n       */\n      _createReadOnlyProperty(property, protectedSetter) {\n        this._addPropertyEffect(property, TYPES.READ_ONLY);\n        if (protectedSetter) {\n          this['_set' + upper(property)] = function (value) {\n            this._setProperty(property, value);\n          };\n        }\n      }\n\n      /**\n       * Equivalent to static `createPropertyObserver` API but can be called on\n       * an instance to add effects at runtime.  See that method for\n       * full API docs.\n       *\n       * @param {string} property Property name\n       * @param {string} methodName Name of observer method to call\n       * @param {boolean=} dynamicFn Whether the method name should be included as\n       *   a dependency to the effect.\n       * @protected\n       */\n      _createPropertyObserver(property, methodName, dynamicFn) {\n        let info = { property, methodName, dynamicFn };\n        this._addPropertyEffect(property, TYPES.OBSERVE, {\n          fn: runObserverEffect, info, trigger: { name: property }\n        });\n        if (dynamicFn) {\n          this._addPropertyEffect(methodName, TYPES.OBSERVE, {\n            fn: runObserverEffect, info, trigger: { name: methodName }\n          });\n        }\n      }\n\n      /**\n       * Equivalent to static `createMethodObserver` API but can be called on\n       * an instance to add effects at runtime.  See that method for\n       * full API docs.\n       *\n       * @param {string} expression Method expression\n       * @param {boolean|Object=} dynamicFn Boolean or object map indicating\n       *   whether method names should be included as a dependency to the effect.\n       * @protected\n       */\n      _createMethodObserver(expression, dynamicFn) {\n        let sig = parseMethod(expression);\n        if (!sig) {\n          throw new Error(\"Malformed observer expression '\" + expression + \"'\");\n        }\n        createMethodEffect(this, sig, TYPES.OBSERVE, runMethodEffect, null, dynamicFn);\n      }\n\n      /**\n       * Equivalent to static `createNotifyingProperty` API but can be called on\n       * an instance to add effects at runtime.  See that method for\n       * full API docs.\n       *\n       * @param {string} property Property name\n       * @protected\n       */\n      _createNotifyingProperty(property) {\n        this._addPropertyEffect(property, TYPES.NOTIFY, {\n          fn: runNotifyEffect,\n          info: {\n            eventName: CaseMap.camelToDashCase(property) + '-changed',\n            property: property\n          }\n        });\n      }\n\n      /**\n       * Equivalent to static `createReflectedProperty` API but can be called on\n       * an instance to add effects at runtime.  See that method for\n       * full API docs.\n       *\n       * @param {string} property Property name\n       * @protected\n       */\n      _createReflectedProperty(property) {\n        let attr = CaseMap.camelToDashCase(property);\n        if (attr[0] === '-') {\n          console.warn('Property ' + property + ' cannot be reflected to attribute ' + attr + ' because \"-\" is not a valid starting attribute name. Use a lowercase first letter for the property thisead.');\n        } else {\n          this._addPropertyEffect(property, TYPES.REFLECT, {\n            fn: runReflectEffect,\n            info: {\n              attrName: attr\n            }\n          });\n        }\n      }\n\n      /**\n       * Equivalent to static `createComputedProperty` API but can be called on\n       * an instance to add effects at runtime.  See that method for\n       * full API docs.\n       *\n       * @param {string} property Name of computed property to set\n       * @param {string} expression Method expression\n       * @param {boolean|Object=} dynamicFn Boolean or object map indicating\n       *   whether method names should be included as a dependency to the effect.\n       * @protected\n       */\n      _createComputedProperty(property, expression, dynamicFn) {\n        let sig = parseMethod(expression);\n        if (!sig) {\n          throw new Error(\"Malformed computed expression '\" + expression + \"'\");\n        }\n        createMethodEffect(this, sig, TYPES.COMPUTE, runComputedEffect, property, dynamicFn);\n      }\n\n      // -- static class methods ------------\n\n      /**\n       * Ensures an accessor exists for the specified property, and adds\n       * to a list of \"property effects\" that will run when the accessor for\n       * the specified property is set.  Effects are grouped by \"type\", which\n       * roughly corresponds to a phase in effect processing.  The effect\n       * metadata should be in the following form:\n       *\n       *   {\n       *     fn: effectFunction, // Reference to function to call to perform effect\n       *     info: { ... }       // Effect metadata passed to function\n       *     trigger: {          // Optional triggering metadata; if not provided\n       *       name: string      // the property is treated as a wildcard\n       *       structured: boolean\n       *       wildcard: boolean\n       *     }\n       *   }\n       *\n       * Effects are called from `_propertiesChanged` in the following order by\n       * type:\n       *\n       * 1. COMPUTE\n       * 2. PROPAGATE\n       * 3. REFLECT\n       * 4. OBSERVE\n       * 5. NOTIFY\n       *\n       * Effect functions are called with the following signature:\n       *\n       *   effectFunction(inst, path, props, oldProps, info, hasPaths)\n       *\n       * @param {string} property Property that should trigger the effect\n       * @param {string} type Effect type, from this.PROPERTY_EFFECT_TYPES\n       * @param {Object=} effect Effect metadata object\n       * @protected\n       */\n      static addPropertyEffect(property, type, effect) {\n        this.prototype._addPropertyEffect(property, type, effect);\n      }\n\n      /**\n       * Creates a single-property observer for the given property.\n       *\n       * @param {string} property Property name\n       * @param {string} methodName Name of observer method to call\n       * @param {boolean=} dynamicFn Whether the method name should be included as\n       *   a dependency to the effect.\n       * @protected\n       */\n      static createPropertyObserver(property, methodName, dynamicFn) {\n        this.prototype._createPropertyObserver(property, methodName, dynamicFn);\n      }\n\n      /**\n       * Creates a multi-property \"method observer\" based on the provided\n       * expression, which should be a string in the form of a normal Javascript\n       * function signature: `'methodName(arg1, [..., argn])'`.  Each argument\n       * should correspond to a property or path in the context of this\n       * prototype (or instance), or may be a literal string or number.\n       *\n       * @param {string} expression Method expression\n       * @param {boolean|Object=} dynamicFn Boolean or object map indicating\n       *   whether method names should be included as a dependency to the effect.\n       * @protected\n       */\n      static createMethodObserver(expression, dynamicFn) {\n        this.prototype._createMethodObserver(expression, dynamicFn);\n      }\n\n      /**\n       * Causes the setter for the given property to dispatch `<property>-changed`\n       * events to notify of changes to the property.\n       *\n       * @param {string} property Property name\n       * @protected\n       */\n      static createNotifyingProperty(property) {\n        this.prototype._createNotifyingProperty(property);\n      }\n\n      /**\n       * Creates a read-only accessor for the given property.\n       *\n       * To set the property, use the protected `_setProperty` API.\n       * To create a custom protected setter (e.g. `_setMyProp()` for\n       * property `myProp`), pass `true` for `protectedSetter`.\n       *\n       * Note, if the property will have other property effects, this method\n       * should be called first, before adding other effects.\n       *\n       * @param {string} property Property name\n       * @param {boolean=} protectedSetter Creates a custom protected setter\n       *   when `true`.\n       * @protected\n       */\n      static createReadOnlyProperty(property, protectedSetter) {\n        this.prototype._createReadOnlyProperty(property, protectedSetter);\n      }\n\n      /**\n       * Causes the setter for the given property to reflect the property value\n       * to a (dash-cased) attribute of the same name.\n       *\n       * @param {string} property Property name\n       * @protected\n       */\n      static createReflectedProperty(property) {\n        this.prototype._createReflectedProperty(property);\n      }\n\n      /**\n       * Creates a computed property whose value is set to the result of the\n       * method described by the given `expression` each time one or more\n       * arguments to the method changes.  The expression should be a string\n       * in the form of a normal Javascript function signature:\n       * `'methodName(arg1, [..., argn])'`\n       *\n       * @param {string} property Name of computed property to set\n       * @param {string} expression Method expression\n       * @param {boolean|Object=} dynamicFn Boolean or object map indicating whether\n       *   method names should be included as a dependency to the effect.\n       * @protected\n       */\n      static createComputedProperty(property, expression, dynamicFn) {\n        this.prototype._createComputedProperty(property, expression, dynamicFn);\n      }\n\n      /**\n       * Parses the provided template to ensure binding effects are created\n       * for them, and then ensures property accessors are created for any\n       * dependent properties in the template.  Binding effects for bound\n       * templates are stored in a linked list on the instance so that\n       * templates can be efficiently stamped and unstamped.\n       *\n       * @param {HTMLTemplateElement} template Template containing binding\n       *   bindings\n       * @return {Object} Template metadata object\n       * @protected\n       */\n      static bindTemplate(template) {\n        return this.prototype._bindTemplate(template);\n      }\n\n      // -- binding ----------------------------------------------\n\n      /**\n       * Equivalent to static `bindTemplate` API but can be called on\n       * an instance to add effects at runtime.  See that method for\n       * full API docs.\n       *\n       * This method may be called on the prototype (for prototypical template\n       * binding, to avoid creating accessors every instance) once per prototype,\n       * and will be called with `runtimeBinding: true` by `_stampTemplate` to\n       * create and link an instance of the template metadata associated with a\n       * particular stamping.\n       *\n       * @param {HTMLTemplateElement} template Template containing binding\n       *   bindings\n       * @param {boolean=} instanceBinding When false (default), performs\n       *   \"prototypical\" binding of the template and overwrites any previously\n       *   bound template for the class. When true (as passed from\n       *   `_stampTemplate`), the template info is instanced and linked into\n       *   the list of bound templates.\n       * @return {Object} Template metadata object; for `runtimeBinding`,\n       *   this is an instance of the prototypical template info\n       * @protected\n       */\n      _bindTemplate(template, instanceBinding) {\n        let templateInfo = this.constructor._parseTemplate(template);\n        let wasPreBound = this.__templateInfo == templateInfo;\n        // Optimization: since this is called twice for proto-bound templates,\n        // don't attempt to recreate accessors if this template was pre-bound\n        if (!wasPreBound) {\n          for (let prop in templateInfo.propertyEffects) {\n            this._createPropertyAccessor(prop);\n          }\n        }\n        if (instanceBinding) {\n          // For instance-time binding, create instance of template metadata\n          // and link into list of templates if necessary\n          templateInfo = Object.create(templateInfo);\n          templateInfo.wasPreBound = wasPreBound;\n          if (!wasPreBound && this.__templateInfo) {\n            let last = this.__templateInfoLast || this.__templateInfo;\n            this.__templateInfoLast = last.nextTemplateInfo = templateInfo;\n            templateInfo.previousTemplateInfo = last;\n            return templateInfo;\n          }\n        }\n        return this.__templateInfo = templateInfo;\n      }\n\n      /**\n       * Adds a property effect to the given template metadata, which is run\n       * at the \"propagate\" stage of `_propertiesChanged` when the template\n       * has been bound to the element via `_bindTemplate`.\n       *\n       * The `effect` object should match the format in `_addPropertyEffect`.\n       *\n       * @param {Object} templateInfo Template metadata to add effect to\n       * @param {string} prop Property that should trigger the effect\n       * @param {Object=} effect Effect metadata object\n       * @protected\n       */\n      static _addTemplatePropertyEffect(templateInfo, prop, effect) {\n        let hostProps = templateInfo.hostProps = templateInfo.hostProps || {};\n        hostProps[prop] = true;\n        let effects = templateInfo.propertyEffects = templateInfo.propertyEffects || {};\n        let propEffects = effects[prop] = effects[prop] || [];\n        propEffects.push(effect);\n      }\n\n      /**\n       * Stamps the provided template and performs instance-time setup for\n       * Polymer template features, including data bindings, declarative event\n       * listeners, and the `this.$` map of `id`'s to nodes.  A document fragment\n       * is returned containing the stamped DOM, ready for insertion into the\n       * DOM.\n       *\n       * This method may be called more than once; however note that due to\n       * `shadycss` polyfill limitations, only styles from templates prepared\n       * using `ShadyCSS.prepareTemplate` will be correctly polyfilled (scoped\n       * to the shadow root and support CSS custom properties), and note that\n       * `ShadyCSS.prepareTemplate` may only be called once per element. As such,\n       * any styles required by in runtime-stamped templates must be included\n       * in the main element template.\n       *\n       * @param {HTMLTemplateElement} template Template to stamp\n       * @return {DocumentFragment} Cloned template content\n       * @protected\n       */\n      _stampTemplate(template) {\n        // Ensures that created dom is `_enqueueClient`'d to this element so\n        // that it can be flushed on next call to `_flushProperties`\n        hostStack.beginHosting(this);\n        let dom = super._stampTemplate(template);\n        hostStack.endHosting(this);\n        let templateInfo = this._bindTemplate(template, true);\n        // Add template-instance-specific data to instanced templateInfo\n        templateInfo.nodeList = dom.nodeList;\n        // Capture child nodes to allow unstamping of non-prototypical templates\n        if (!templateInfo.wasPreBound) {\n          let nodes = templateInfo.childNodes = [];\n          for (let n = dom.firstChild; n; n = n.nextSibling) {\n            nodes.push(n);\n          }\n        }\n        dom.templateInfo = templateInfo;\n        // Setup compound storage, 2-way listeners, and dataHost for bindings\n        setupBindings(this, templateInfo);\n        // Flush properties into template nodes if already booted\n        if (this.__dataReady) {\n          runEffects(this, templateInfo.propertyEffects, this.__data, null, false, templateInfo.nodeList);\n        }\n        return dom;\n      }\n\n      /**\n       * Removes and unbinds the nodes previously contained in the provided\n       * DocumentFragment returned from `_stampTemplate`.\n       *\n       * @param {DocumentFragment} dom DocumentFragment previously returned\n       *   from `_stampTemplate` associated with the nodes to be removed\n       * @protected\n       */\n      _removeBoundDom(dom) {\n        // Unlink template info\n        let templateInfo = dom.templateInfo;\n        if (templateInfo.previousTemplateInfo) {\n          templateInfo.previousTemplateInfo.nextTemplateInfo = templateInfo.nextTemplateInfo;\n        }\n        if (templateInfo.nextTemplateInfo) {\n          templateInfo.nextTemplateInfo.previousTemplateInfo = templateInfo.previousTemplateInfo;\n        }\n        if (this.__templateInfoLast == templateInfo) {\n          this.__templateInfoLast = templateInfo.previousTemplateInfo;\n        }\n        templateInfo.previousTemplateInfo = templateInfo.nextTemplateInfo = null;\n        // Remove stamped nodes\n        let nodes = templateInfo.childNodes;\n        for (let i = 0; i < nodes.length; i++) {\n          let node = nodes[i];\n          node.parentNode.removeChild(node);\n        }\n      }\n\n      /**\n       * Overrides default `TemplateStamp` implementation to add support for\n       * parsing bindings from `TextNode`'s' `textContent`.  A `bindings`\n       * array is added to `nodeInfo` and populated with binding metadata\n       * with information capturing the binding target, and a `parts` array\n       * with one or more metadata objects capturing the source(s) of the\n       * binding.\n       *\n       * @override\n       * @param {Node} node Node to parse\n       * @param {Object} templateInfo Template metadata for current template\n       * @param {Object} nodeInfo Node metadata for current template node\n       * @return {boolean} `true` if the visited node added node-specific\n       *   metadata to `nodeInfo`\n       * @protected\n       */\n      static _parseTemplateNode(node, templateInfo, nodeInfo) {\n        let noted = super._parseTemplateNode(node, templateInfo, nodeInfo);\n        if (node.nodeType === Node.TEXT_NODE) {\n          let parts = this._parseBindings(node.textContent, templateInfo);\n          if (parts) {\n            // Initialize the textContent with any literal parts\n            // NOTE: default to a space here so the textNode remains; some browsers\n            // (IE) evacipate an empty textNode following cloneNode/importNode.\n            node.textContent = literalFromParts(parts) || ' ';\n            addBinding(this, templateInfo, nodeInfo, 'text', 'textContent', parts);\n            noted = true;\n          }\n        }\n        return noted;\n      }\n\n      /**\n       * Overrides default `TemplateStamp` implementation to add support for\n       * parsing bindings from attributes.  A `bindings`\n       * array is added to `nodeInfo` and populated with binding metadata\n       * with information capturing the binding target, and a `parts` array\n       * with one or more metadata objects capturing the source(s) of the\n       * binding.\n       *\n       * @override\n       * @param {Node} node Node to parse\n       * @param {Object} templateInfo Template metadata for current template\n       * @param {Object} nodeInfo Node metadata for current template node\n       * @return {boolean} `true` if the visited node added node-specific\n       *   metadata to `nodeInfo`\n       * @protected\n       */\n      static _parseTemplateNodeAttribute(node, templateInfo, nodeInfo, name, value) {\n        let parts = this._parseBindings(value, templateInfo);\n        if (parts) {\n          // Attribute or property\n          let origName = name;\n          let kind = 'property';\n          if (name[name.length - 1] == '$') {\n            name = name.slice(0, -1);\n            kind = 'attribute';\n          }\n          // Initialize attribute bindings with any literal parts\n          let literal = literalFromParts(parts);\n          if (literal && kind == 'attribute') {\n            node.setAttribute(name, literal);\n          }\n          // Clear attribute before removing, since IE won't allow removing\n          // `value` attribute if it previously had a value (can't\n          // unconditionally set '' before removing since attributes with `$`\n          // can't be set using setAttribute)\n          if (node.localName === 'input' && origName === 'value') {\n            node.setAttribute(origName, '');\n          }\n          // Remove annotation\n          node.removeAttribute(origName);\n          // Case hackery: attributes are lower-case, but bind targets\n          // (properties) are case sensitive. Gambit is to map dash-case to\n          // camel-case: `foo-bar` becomes `fooBar`.\n          // Attribute bindings are excepted.\n          if (kind === 'property') {\n            name = Polymer.CaseMap.dashToCamelCase(name);\n          }\n          addBinding(this, templateInfo, nodeInfo, kind, name, parts, literal);\n          return true;\n        } else {\n          return super._parseTemplateNodeAttribute(node, templateInfo, nodeInfo, name, value);\n        }\n      }\n\n      /**\n       * Overrides default `TemplateStamp` implementation to add support for\n       * binding the properties that a nested template depends on to the template\n       * as `_host_<property>`.\n       *\n       * @override\n       * @param {Node} node Node to parse\n       * @param {Object} templateInfo Template metadata for current template\n       * @param {Object} nodeInfo Node metadata for current template node\n       * @return {boolean} `true` if the visited node added node-specific\n       *   metadata to `nodeInfo`\n       * @protected\n       */\n      static _parseTemplateNestedTemplate(node, templateInfo, nodeInfo) {\n        let noted = super._parseTemplateNestedTemplate(node, templateInfo, nodeInfo);\n        // Merge host props into outer template and add bindings\n        let hostProps = nodeInfo.templateInfo.hostProps;\n        let mode = '{';\n        for (let source in hostProps) {\n          let parts = [{ mode, source, dependencies: [source] }];\n          addBinding(this, templateInfo, nodeInfo, 'property', '_host_' + source, parts);\n        }\n        return noted;\n      }\n\n      /**\n       * Called to parse text in a template (either attribute values or\n       * textContent) into binding metadata.\n       *\n       * Any overrides of this method should return an array of binding part\n       * metadata  representing one or more bindings found in the provided text\n       * and any \"literal\" text in between.  Any non-literal parts will be passed\n       * to `_evaluateBinding` when any dependencies change.  The only required\n       * fields of each \"part\" in the returned array are as follows:\n       *\n       * - `dependencies` - Array containing trigger metadata for each property\n       *   that should trigger the binding to update\n       * - `literal` - String containing text if the part represents a literal;\n       *   in this case no `dependencies` are needed\n       *\n       * Additional metadata for use by `_evaluateBinding` may be provided in\n       * each part object as needed.\n       *\n       * The default implementation handles the following types of bindings\n       * (one or more may be intermixed with literal strings):\n       * - Property binding: `[[prop]]`\n       * - Path binding: `[[object.prop]]`\n       * - Negated property or path bindings: `[[!prop]]` or `[[!object.prop]]`\n       * - Two-way property or path bindings (supports negation):\n       *   `{{prop}}`, `{{object.prop}}`, `{{!prop}}` or `{{!object.prop}}`\n       * - Inline computed method (supports negation):\n       *   `[[compute(a, 'literal', b)]]`, `[[!compute(a, 'literal', b)]]`\n       *\n       * @param {string} text Text to parse from attribute or textContent\n       * @param {Object} templateInfo Current template metadata\n       * @return {Array<Object>} Array of binding part metadata\n       * @protected\n       */\n      static _parseBindings(text, templateInfo) {\n        let parts = [];\n        let lastIndex = 0;\n        let m;\n        // Example: \"literal1{{prop}}literal2[[!compute(foo,bar)]]final\"\n        // Regex matches:\n        //        Iteration 1:  Iteration 2:\n        // m[1]: '{{'          '[['\n        // m[2]: ''            '!'\n        // m[3]: 'prop'        'compute(foo,bar)'\n        while ((m = bindingRegex.exec(text)) !== null) {\n          // Add literal part\n          if (m.index > lastIndex) {\n            parts.push({ literal: text.slice(lastIndex, m.index) });\n          }\n          // Add binding part\n          let mode = m[1][0];\n          let negate = Boolean(m[2]);\n          let source = m[3].trim();\n          let customEvent, notifyEvent, colon;\n          if (mode == '{' && (colon = source.indexOf('::')) > 0) {\n            notifyEvent = source.substring(colon + 2);\n            source = source.substring(0, colon);\n            customEvent = true;\n          }\n          let signature = parseMethod(source);\n          let dependencies = [];\n          if (signature) {\n            // Inline computed function\n            let { args, methodName } = signature;\n            for (let i = 0; i < args.length; i++) {\n              let arg = args[i];\n              if (!arg.literal) {\n                dependencies.push(arg);\n              }\n            }\n            let dynamicFns = templateInfo.dynamicFns;\n            if (dynamicFns && dynamicFns[methodName] || signature.static) {\n              dependencies.push(methodName);\n              signature.dynamicFn = true;\n            }\n          } else {\n            // Property or path\n            dependencies.push(source);\n          }\n          parts.push({\n            source, mode, negate, customEvent, signature, dependencies,\n            event: notifyEvent\n          });\n          lastIndex = bindingRegex.lastIndex;\n        }\n        // Add a final literal part\n        if (lastIndex && lastIndex < text.length) {\n          let literal = text.substring(lastIndex);\n          if (literal) {\n            parts.push({\n              literal: literal\n            });\n          }\n        }\n        if (parts.length) {\n          return parts;\n        }\n      }\n\n      /**\n       * Called to evaluate a previously parsed binding part based on a set of\n       * one or more changed dependencies.\n       *\n       * @param {HTMLElement} inst Element that should be used as scope for\n       *   binding dependencies\n       * @param {Object} part Binding part metadata\n       * @param {string} path Property/path that triggered this effect\n       * @param {Object} props Bag of current property changes\n       * @param {Object} oldProps Bag of previous values for changed properties\n       * @param {boolean} hasPaths True with `props` contains one or more paths\n       * @return {*} Value the binding part evaluated to\n       * @protected\n       */\n      static _evaluateBinding(inst, part, path, props, oldProps, hasPaths) {\n        let value;\n        if (part.signature) {\n          value = runMethodEffect(inst, path, props, oldProps, part.signature);\n        } else if (path != part.source) {\n          value = Polymer.Path.get(inst, part.source);\n        } else {\n          if (hasPaths && Polymer.Path.isPath(path)) {\n            value = Polymer.Path.get(inst, path);\n          } else {\n            value = inst.__data[path];\n          }\n        }\n        if (part.negate) {\n          value = !value;\n        }\n        return value;\n      }\n\n    }\n\n    return PropertyEffects;\n  });\n\n  /**\n   * Helper api for enqueing client dom created by a host element.\n   *\n   * By default elements are flushed via `_flushProperties` when\n   * `connectedCallback` is called. Elements attach their client dom to\n   * themselves at `ready` time which results from this first flush.\n   * This provides an ordering guarantee that the client dom an element\n   * creates is flushed before the element itself (i.e. client `ready`\n   * fires before host `ready`).\n   *\n   * However, if `_flushProperties` is called *before* an element is connected,\n   * as for example `Templatize` does, this ordering guarantee cannot be\n   * satisfied because no elements are connected. (Note: Bound elements that\n   * receive data do become enqueued clients and are properly ordered but\n   * unbound elements are not.)\n   *\n   * To maintain the desired \"client before host\" ordering guarantee for this\n   * case we rely on the \"host stack. Client nodes registers themselves with\n   * the creating host element when created. This ensures that all client dom\n   * is readied in the proper order, maintaining the desired guarantee.\n   *\n   * @private\n   */\n  let hostStack = {\n\n    stack: [],\n\n    registerHost(inst) {\n      if (this.stack.length) {\n        let host = this.stack[this.stack.length - 1];\n        host._enqueueClient(inst);\n      }\n    },\n\n    beginHosting(inst) {\n      this.stack.push(inst);\n    },\n\n    endHosting(inst) {\n      let stackLen = this.stack.length;\n      if (stackLen && this.stack[stackLen - 1] == inst) {\n        this.stack.pop();\n      }\n    }\n\n  };\n})();\n\n/***/ }),\n/* 13 */\n/***/ (function(module, exports, __webpack_require__) {\n\n/*__wc__loader*/\n__webpack_require__(0);\n\n(function () {\n\n  'use strict';\n\n  /** @typedef {{run: function(function(), number=):number, cancel: function(number)}} */\n\n  let AsyncInterface; // eslint-disable-line no-unused-vars\n\n  // Microtask implemented using Mutation Observer\n  let microtaskCurrHandle = 0;\n  let microtaskLastHandle = 0;\n  let microtaskCallbacks = [];\n  let microtaskNodeContent = 0;\n  let microtaskNode = document.createTextNode('');\n  new window.MutationObserver(microtaskFlush).observe(microtaskNode, { characterData: true });\n\n  function microtaskFlush() {\n    const len = microtaskCallbacks.length;\n    for (let i = 0; i < len; i++) {\n      let cb = microtaskCallbacks[i];\n      if (cb) {\n        try {\n          cb();\n        } catch (e) {\n          setTimeout(() => {\n            throw e;\n          });\n        }\n      }\n    }\n    microtaskCallbacks.splice(0, len);\n    microtaskLastHandle += len;\n  }\n\n  /**\n   * Module that provides a number of strategies for enqueuing asynchronous\n   * tasks.  Each sub-module provides a standard `run(fn)` interface that returns a\n   * handle, and a `cancel(handle)` interface for canceling async tasks before\n   * they run.\n   *\n   * @namespace\n   * @memberof Polymer\n   * @summary Module that provides a number of strategies for enqueuing asynchronous\n   * tasks.\n   */\n  Polymer.Async = {\n\n    /**\n     * Async interface wrapper around `setTimeout`.\n     *\n     * @namespace\n     * @memberof Polymer.Async\n     * @summary Async interface wrapper around `setTimeout`.\n     */\n    timeOut: {\n      /**\n       * Returns a sub-module with the async interface providing the provided\n       * delay.\n       *\n       * @memberof Polymer.Async.timeOut\n       * @param {number} delay Time to wait before calling callbacks in ms\n       * @return {AsyncInterface} An async timeout interface\n       */\n      after(delay) {\n        return {\n          run(fn) {\n            return setTimeout(fn, delay);\n          },\n          cancel: window.clearTimeout.bind(window)\n        };\n      },\n      /**\n       * Enqueues a function called in the next task.\n       *\n       * @memberof Polymer.Async.timeOut\n       * @param {Function} fn Callback to run\n       * @return {number} Handle used for canceling task\n       */\n      run: window.setTimeout.bind(window),\n      /**\n       * Cancels a previously enqueued `timeOut` callback.\n       *\n       * @memberof Polymer.Async.timeOut\n       * @param {number} handle Handle returned from `run` of callback to cancel\n       */\n      cancel: window.clearTimeout.bind(window)\n    },\n\n    /**\n     * Async interface wrapper around `requestAnimationFrame`.\n     *\n     * @namespace\n     * @memberof Polymer.Async\n     * @summary Async interface wrapper around `requestAnimationFrame`.\n     */\n    animationFrame: {\n      /**\n       * Enqueues a function called at `requestAnimationFrame` timing.\n       *\n       * @memberof Polymer.Async.animationFrame\n       * @param {Function} fn Callback to run\n       * @return {number} Handle used for canceling task\n       */\n      run: window.requestAnimationFrame.bind(window),\n      /**\n       * Cancels a previously enqueued `animationFrame` callback.\n       *\n       * @memberof Polymer.Async.timeOut\n       * @param {number} handle Handle returned from `run` of callback to cancel\n       */\n      cancel: window.cancelAnimationFrame.bind(window)\n    },\n\n    /**\n     * Async interface wrapper around `requestIdleCallback`.  Falls back to\n     * `setTimeout` on browsers that do not support `requestIdleCallback`.\n     *\n     * @namespace\n     * @memberof Polymer.Async\n     * @summary Async interface wrapper around `requestIdleCallback`.\n     */\n    idlePeriod: {\n      /**\n       * Enqueues a function called at `requestIdleCallback` timing.\n       *\n       * @memberof Polymer.Async.idlePeriod\n       * @param {function(IdleDeadline)} fn Callback to run\n       * @return {number} Handle used for canceling task\n       */\n      run(fn) {\n        return window.requestIdleCallback ? window.requestIdleCallback(fn) : window.setTimeout(fn, 16);\n      },\n      /**\n       * Cancels a previously enqueued `idlePeriod` callback.\n       *\n       * @memberof Polymer.Async.idlePeriod\n       * @param {number} handle Handle returned from `run` of callback to cancel\n       */\n      cancel(handle) {\n        window.cancelIdleCallback ? window.cancelIdleCallback(handle) : window.clearTimeout(handle);\n      }\n    },\n\n    /**\n     * Async interface for enqueueing callbacks that run at microtask timing.\n     *\n     * Note that microtask timing is achieved via a single `MutationObserver`,\n     * and thus callbacks enqueued with this API will all run in a single\n     * batch, and not interleaved with other microtasks such as promises.\n     * Promises are avoided as an implementation choice for the time being\n     * due to Safari bugs that cause Promises to lack microtask guarantees.\n     *\n     * @namespace\n     * @memberof Polymer.Async\n     * @summary Async interface for enqueueing callbacks that run at microtask\n     *   timing.\n     */\n    microTask: {\n\n      /**\n       * Enqueues a function called at microtask timing.\n       *\n       * @memberof Polymer.Async.microTask\n       * @param {Function} callback Callback to run\n       * @return {*} Handle used for canceling task\n       */\n      run(callback) {\n        microtaskNode.textContent = microtaskNodeContent++;\n        microtaskCallbacks.push(callback);\n        return microtaskCurrHandle++;\n      },\n\n      /**\n       * Cancels a previously enqueued `microTask` callback.\n       *\n       * @memberof Polymer.Async.microTask\n       * @param {number} handle Handle returned from `run` of callback to cancel\n       */\n      cancel(handle) {\n        const idx = handle - microtaskLastHandle;\n        if (idx >= 0) {\n          if (!microtaskCallbacks[idx]) {\n            throw new Error('invalid async handle: ' + handle);\n          }\n          microtaskCallbacks[idx] = null;\n        }\n      }\n\n    }\n  };\n})();\n\n/***/ }),\n/* 14 */\n/***/ (function(module, exports) {\n\nvar g;\n\n// This works in non-strict mode\ng = function () {\n\treturn this;\n}();\n\ntry {\n\t// This works if eval is allowed (see CSP)\n\tg = g || Function(\"return this\")() || (1, eval)(\"this\");\n} catch (e) {\n\t// This works if the window reference is available\n\tif (typeof window === \"object\") g = window;\n}\n\n// g can still be undefined, but nothing to do about it...\n// We return undefined, instead of nothing here, so it's\n// easier to handle this case. if(!global) { ...}\n\nmodule.exports = g;\n\n/***/ }),\n/* 15 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\nObject.defineProperty(__webpack_exports__, \"__esModule\", { value: true });\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__components_fake_app__ = __webpack_require__(16);\n\n\n\n\n/***/ }),\n/* 16 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__polymer_polymer_polymer_element_html__ = __webpack_require__(4);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__polymer_polymer_polymer_element_html___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0__polymer_polymer_polymer_element_html__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__template_html__ = __webpack_require__(33);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__template_html___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1__template_html__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__store__ = __webpack_require__(5);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__list_data__ = __webpack_require__(17);\n\n\n\n\n\n\n\n\n\nclass FakeApp extends Polymer.Element {\n  static get is() {\n    return 'fake-app';\n  }\n  static get properties() {\n    return {\n      test: {\n        type: String,\n        value: \"hello world\"\n      },\n      version: {\n        type: String,\n        value: () => {\n          return window.Polymer.version;\n        }\n      }\n    };\n  }\n\n}\n\ncustomElements.define(FakeApp.is, FakeApp);\n\n/***/ }),\n/* 17 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__polymer_polymer_polymer_element_html__ = __webpack_require__(4);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__polymer_polymer_polymer_element_html___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0__polymer_polymer_polymer_element_html__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__polymer_polymer_lib_elements_dom_repeat_html__ = __webpack_require__(36);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__polymer_polymer_lib_elements_dom_repeat_html___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1__polymer_polymer_lib_elements_dom_repeat_html__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__template_html__ = __webpack_require__(34);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__template_html___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_2__template_html__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__store__ = __webpack_require__(5);\n\n\n\n\n\n\n\n\nclass ListData extends Polymer.Element {\n  static get is() {\n    return 'list-data';\n  }\n  static get properties() {\n    return {\n      data: {\n        type: Array,\n        value: []\n      }\n    };\n  }\n\n  connectedCallback() {\n    fetch('http://jsonplaceholder.typicode.com/posts/').then(resp => resp.json()).then(data => {\n      const filtered = data.filter((e, i) => {\n        return i < 10;\n      });\n      this.data = filtered;\n      __WEBPACK_IMPORTED_MODULE_3__store__[\"a\" /* store */].dispatch({\n        type: 'SET_ITEMS',\n        data: filtered\n      });\n    });\n  }\n\n}\n\ncustomElements.define(ListData.is, ListData);\n\n/***/ }),\n/* 18 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__Symbol_js__ = __webpack_require__(6);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__getRawTag_js__ = __webpack_require__(21);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__objectToString_js__ = __webpack_require__(22);\n\n\n\n\n/** `Object#toString` result references. */\nvar nullTag = '[object Null]',\n    undefinedTag = '[object Undefined]';\n\n/** Built-in value references. */\nvar symToStringTag = __WEBPACK_IMPORTED_MODULE_0__Symbol_js__[\"a\" /* default */] ? __WEBPACK_IMPORTED_MODULE_0__Symbol_js__[\"a\" /* default */].toStringTag : undefined;\n\n/**\n * The base implementation of `getTag` without fallbacks for buggy environments.\n *\n * @private\n * @param {*} value The value to query.\n * @returns {string} Returns the `toStringTag`.\n */\nfunction baseGetTag(value) {\n  if (value == null) {\n    return value === undefined ? undefinedTag : nullTag;\n  }\n  return symToStringTag && symToStringTag in Object(value) ? __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__getRawTag_js__[\"a\" /* default */])(value) : __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2__objectToString_js__[\"a\" /* default */])(value);\n}\n\n/* harmony default export */ __webpack_exports__[\"a\"] = (baseGetTag);\n\n/***/ }),\n/* 19 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* WEBPACK VAR INJECTION */(function(global) {/** Detect free variable `global` from Node.js. */\nvar freeGlobal = typeof global == 'object' && global && global.Object === Object && global;\n\n/* harmony default export */ __webpack_exports__[\"a\"] = (freeGlobal);\n/* WEBPACK VAR INJECTION */}.call(__webpack_exports__, __webpack_require__(14)))\n\n/***/ }),\n/* 20 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__overArg_js__ = __webpack_require__(23);\n\n\n/** Built-in value references. */\nvar getPrototype = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__overArg_js__[\"a\" /* default */])(Object.getPrototypeOf, Object);\n\n/* harmony default export */ __webpack_exports__[\"a\"] = (getPrototype);\n\n/***/ }),\n/* 21 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__Symbol_js__ = __webpack_require__(6);\n\n\n/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/**\n * Used to resolve the\n * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)\n * of values.\n */\nvar nativeObjectToString = objectProto.toString;\n\n/** Built-in value references. */\nvar symToStringTag = __WEBPACK_IMPORTED_MODULE_0__Symbol_js__[\"a\" /* default */] ? __WEBPACK_IMPORTED_MODULE_0__Symbol_js__[\"a\" /* default */].toStringTag : undefined;\n\n/**\n * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.\n *\n * @private\n * @param {*} value The value to query.\n * @returns {string} Returns the raw `toStringTag`.\n */\nfunction getRawTag(value) {\n  var isOwn = hasOwnProperty.call(value, symToStringTag),\n      tag = value[symToStringTag];\n\n  try {\n    value[symToStringTag] = undefined;\n    var unmasked = true;\n  } catch (e) {}\n\n  var result = nativeObjectToString.call(value);\n  if (unmasked) {\n    if (isOwn) {\n      value[symToStringTag] = tag;\n    } else {\n      delete value[symToStringTag];\n    }\n  }\n  return result;\n}\n\n/* harmony default export */ __webpack_exports__[\"a\"] = (getRawTag);\n\n/***/ }),\n/* 22 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/**\n * Used to resolve the\n * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)\n * of values.\n */\nvar nativeObjectToString = objectProto.toString;\n\n/**\n * Converts `value` to a string using `Object.prototype.toString`.\n *\n * @private\n * @param {*} value The value to convert.\n * @returns {string} Returns the converted string.\n */\nfunction objectToString(value) {\n  return nativeObjectToString.call(value);\n}\n\n/* harmony default export */ __webpack_exports__[\"a\"] = (objectToString);\n\n/***/ }),\n/* 23 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/**\n * Creates a unary function that invokes `func` with its argument transformed.\n *\n * @private\n * @param {Function} func The function to wrap.\n * @param {Function} transform The argument transform.\n * @returns {Function} Returns the new function.\n */\nfunction overArg(func, transform) {\n  return function (arg) {\n    return func(transform(arg));\n  };\n}\n\n/* harmony default export */ __webpack_exports__[\"a\"] = (overArg);\n\n/***/ }),\n/* 24 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__freeGlobal_js__ = __webpack_require__(19);\n\n\n/** Detect free variable `self`. */\nvar freeSelf = typeof self == 'object' && self && self.Object === Object && self;\n\n/** Used as a reference to the global object. */\nvar root = __WEBPACK_IMPORTED_MODULE_0__freeGlobal_js__[\"a\" /* default */] || freeSelf || Function('return this')();\n\n/* harmony default export */ __webpack_exports__[\"a\"] = (root);\n\n/***/ }),\n/* 25 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/**\n * Checks if `value` is object-like. A value is object-like if it's not `null`\n * and has a `typeof` result of \"object\".\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is object-like, else `false`.\n * @example\n *\n * _.isObjectLike({});\n * // => true\n *\n * _.isObjectLike([1, 2, 3]);\n * // => true\n *\n * _.isObjectLike(_.noop);\n * // => false\n *\n * _.isObjectLike(null);\n * // => false\n */\nfunction isObjectLike(value) {\n  return value != null && typeof value == 'object';\n}\n\n/* harmony default export */ __webpack_exports__[\"a\"] = (isObjectLike);\n\n/***/ }),\n/* 26 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* unused harmony export default */\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__compose__ = __webpack_require__(8);\nvar _extends = Object.assign || function (target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i];for (var key in source) {\n      if (Object.prototype.hasOwnProperty.call(source, key)) {\n        target[key] = source[key];\n      }\n    }\n  }return target;\n};\n\n\n\n/**\n * Creates a store enhancer that applies middleware to the dispatch method\n * of the Redux store. This is handy for a variety of tasks, such as expressing\n * asynchronous actions in a concise manner, or logging every action payload.\n *\n * See `redux-thunk` package as an example of the Redux middleware.\n *\n * Because middleware is potentially asynchronous, this should be the first\n * store enhancer in the composition chain.\n *\n * Note that each middleware will be given the `dispatch` and `getState` functions\n * as named arguments.\n *\n * @param {...Function} middlewares The middleware chain to be applied.\n * @returns {Function} A store enhancer applying the middleware.\n */\nfunction applyMiddleware() {\n  for (var _len = arguments.length, middlewares = Array(_len), _key = 0; _key < _len; _key++) {\n    middlewares[_key] = arguments[_key];\n  }\n\n  return function (createStore) {\n    return function (reducer, preloadedState, enhancer) {\n      var store = createStore(reducer, preloadedState, enhancer);\n      var _dispatch = store.dispatch;\n      var chain = [];\n\n      var middlewareAPI = {\n        getState: store.getState,\n        dispatch: function dispatch(action) {\n          return _dispatch(action);\n        }\n      };\n      chain = middlewares.map(function (middleware) {\n        return middleware(middlewareAPI);\n      });\n      _dispatch = __WEBPACK_IMPORTED_MODULE_0__compose__[\"a\" /* default */].apply(undefined, chain)(store.dispatch);\n\n      return _extends({}, store, {\n        dispatch: _dispatch\n      });\n    };\n  };\n}\n\n/***/ }),\n/* 27 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* unused harmony export default */\nfunction bindActionCreator(actionCreator, dispatch) {\n  return function () {\n    return dispatch(actionCreator.apply(undefined, arguments));\n  };\n}\n\n/**\n * Turns an object whose values are action creators, into an object with the\n * same keys, but with every function wrapped into a `dispatch` call so they\n * may be invoked directly. This is just a convenience method, as you can call\n * `store.dispatch(MyActionCreators.doSomething())` yourself just fine.\n *\n * For convenience, you can also pass a single function as the first argument,\n * and get a function in return.\n *\n * @param {Function|Object} actionCreators An object whose values are action\n * creator functions. One handy way to obtain it is to use ES6 `import * as`\n * syntax. You may also pass a single function.\n *\n * @param {Function} dispatch The `dispatch` function available on your Redux\n * store.\n *\n * @returns {Function|Object} The object mimicking the original object, but with\n * every action creator wrapped into the `dispatch` call. If you passed a\n * function as `actionCreators`, the return value will also be a single\n * function.\n */\nfunction bindActionCreators(actionCreators, dispatch) {\n  if (typeof actionCreators === 'function') {\n    return bindActionCreator(actionCreators, dispatch);\n  }\n\n  if (typeof actionCreators !== 'object' || actionCreators === null) {\n    throw new Error('bindActionCreators expected an object or a function, instead received ' + (actionCreators === null ? 'null' : typeof actionCreators) + '. ' + 'Did you write \"import ActionCreators from\" instead of \"import * as ActionCreators from\"?');\n  }\n\n  var keys = Object.keys(actionCreators);\n  var boundActionCreators = {};\n  for (var i = 0; i < keys.length; i++) {\n    var key = keys[i];\n    var actionCreator = actionCreators[key];\n    if (typeof actionCreator === 'function') {\n      boundActionCreators[key] = bindActionCreator(actionCreator, dispatch);\n    }\n  }\n  return boundActionCreators;\n}\n\n/***/ }),\n/* 28 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* unused harmony export default */\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__createStore__ = __webpack_require__(9);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_lodash_es_isPlainObject__ = __webpack_require__(7);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__utils_warning__ = __webpack_require__(10);\n\n\n\n\nfunction getUndefinedStateErrorMessage(key, action) {\n  var actionType = action && action.type;\n  var actionName = actionType && '\"' + actionType.toString() + '\"' || 'an action';\n\n  return 'Given action ' + actionName + ', reducer \"' + key + '\" returned undefined. ' + 'To ignore an action, you must explicitly return the previous state.';\n}\n\nfunction getUnexpectedStateShapeWarningMessage(inputState, reducers, action, unexpectedKeyCache) {\n  var reducerKeys = Object.keys(reducers);\n  var argumentName = action && action.type === __WEBPACK_IMPORTED_MODULE_0__createStore__[\"b\" /* ActionTypes */].INIT ? 'preloadedState argument passed to createStore' : 'previous state received by the reducer';\n\n  if (reducerKeys.length === 0) {\n    return 'Store does not have a valid reducer. Make sure the argument passed ' + 'to combineReducers is an object whose values are reducers.';\n  }\n\n  if (!__webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1_lodash_es_isPlainObject__[\"a\" /* default */])(inputState)) {\n    return 'The ' + argumentName + ' has unexpected type of \"' + {}.toString.call(inputState).match(/\\s([a-z|A-Z]+)/)[1] + '\". Expected argument to be an object with the following ' + ('keys: \"' + reducerKeys.join('\", \"') + '\"');\n  }\n\n  var unexpectedKeys = Object.keys(inputState).filter(function (key) {\n    return !reducers.hasOwnProperty(key) && !unexpectedKeyCache[key];\n  });\n\n  unexpectedKeys.forEach(function (key) {\n    unexpectedKeyCache[key] = true;\n  });\n\n  if (unexpectedKeys.length > 0) {\n    return 'Unexpected ' + (unexpectedKeys.length > 1 ? 'keys' : 'key') + ' ' + ('\"' + unexpectedKeys.join('\", \"') + '\" found in ' + argumentName + '. ') + 'Expected to find one of the known reducer keys instead: ' + ('\"' + reducerKeys.join('\", \"') + '\". Unexpected keys will be ignored.');\n  }\n}\n\nfunction assertReducerSanity(reducers) {\n  Object.keys(reducers).forEach(function (key) {\n    var reducer = reducers[key];\n    var initialState = reducer(undefined, { type: __WEBPACK_IMPORTED_MODULE_0__createStore__[\"b\" /* ActionTypes */].INIT });\n\n    if (typeof initialState === 'undefined') {\n      throw new Error('Reducer \"' + key + '\" returned undefined during initialization. ' + 'If the state passed to the reducer is undefined, you must ' + 'explicitly return the initial state. The initial state may ' + 'not be undefined.');\n    }\n\n    var type = '@@redux/PROBE_UNKNOWN_ACTION_' + Math.random().toString(36).substring(7).split('').join('.');\n    if (typeof reducer(undefined, { type: type }) === 'undefined') {\n      throw new Error('Reducer \"' + key + '\" returned undefined when probed with a random type. ' + ('Don\\'t try to handle ' + __WEBPACK_IMPORTED_MODULE_0__createStore__[\"b\" /* ActionTypes */].INIT + ' or other actions in \"redux/*\" ') + 'namespace. They are considered private. Instead, you must return the ' + 'current state for any unknown actions, unless it is undefined, ' + 'in which case you must return the initial state, regardless of the ' + 'action type. The initial state may not be undefined.');\n    }\n  });\n}\n\n/**\n * Turns an object whose values are different reducer functions, into a single\n * reducer function. It will call every child reducer, and gather their results\n * into a single state object, whose keys correspond to the keys of the passed\n * reducer functions.\n *\n * @param {Object} reducers An object whose values correspond to different\n * reducer functions that need to be combined into one. One handy way to obtain\n * it is to use ES6 `import * as reducers` syntax. The reducers may never return\n * undefined for any action. Instead, they should return their initial state\n * if the state passed to them was undefined, and the current state for any\n * unrecognized action.\n *\n * @returns {Function} A reducer function that invokes every reducer inside the\n * passed object, and builds a state object with the same shape.\n */\nfunction combineReducers(reducers) {\n  var reducerKeys = Object.keys(reducers);\n  var finalReducers = {};\n  for (var i = 0; i < reducerKeys.length; i++) {\n    var key = reducerKeys[i];\n\n    if (false) {\n      if (typeof reducers[key] === 'undefined') {\n        warning('No reducer provided for key \"' + key + '\"');\n      }\n    }\n\n    if (typeof reducers[key] === 'function') {\n      finalReducers[key] = reducers[key];\n    }\n  }\n  var finalReducerKeys = Object.keys(finalReducers);\n\n  if (false) {\n    var unexpectedKeyCache = {};\n  }\n\n  var sanityError;\n  try {\n    assertReducerSanity(finalReducers);\n  } catch (e) {\n    sanityError = e;\n  }\n\n  return function combination() {\n    var state = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];\n    var action = arguments[1];\n\n    if (sanityError) {\n      throw sanityError;\n    }\n\n    if (false) {\n      var warningMessage = getUnexpectedStateShapeWarningMessage(state, finalReducers, action, unexpectedKeyCache);\n      if (warningMessage) {\n        warning(warningMessage);\n      }\n    }\n\n    var hasChanged = false;\n    var nextState = {};\n    for (var i = 0; i < finalReducerKeys.length; i++) {\n      var key = finalReducerKeys[i];\n      var reducer = finalReducers[key];\n      var previousStateForKey = state[key];\n      var nextStateForKey = reducer(previousStateForKey, action);\n      if (typeof nextStateForKey === 'undefined') {\n        var errorMessage = getUndefinedStateErrorMessage(key, action);\n        throw new Error(errorMessage);\n      }\n      nextState[key] = nextStateForKey;\n      hasChanged = hasChanged || nextStateForKey !== previousStateForKey;\n    }\n    return hasChanged ? nextState : state;\n  };\n}\n\n/***/ }),\n/* 29 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__createStore__ = __webpack_require__(9);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__combineReducers__ = __webpack_require__(28);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__bindActionCreators__ = __webpack_require__(27);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__applyMiddleware__ = __webpack_require__(26);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__compose__ = __webpack_require__(8);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__utils_warning__ = __webpack_require__(10);\n/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, \"a\", function() { return __WEBPACK_IMPORTED_MODULE_0__createStore__[\"a\"]; });\n/* unused harmony reexport combineReducers */\n/* unused harmony reexport bindActionCreators */\n/* unused harmony reexport applyMiddleware */\n/* unused harmony reexport compose */\n\n\n\n\n\n\n\n/*\n* This is a dummy function to check if the function name has been altered by minification.\n* If the function has been minified and NODE_ENV !== 'production', warn the user.\n*/\nfunction isCrushed() {}\n\nif (false) {\n  warning('You are currently using minified code outside of NODE_ENV === \\'production\\'. ' + 'This means that you are running a slower development build of Redux. ' + 'You can use loose-envify (https://github.com/zertosh/loose-envify) for browserify ' + 'or DefinePlugin for webpack (http://stackoverflow.com/questions/30030031) ' + 'to ensure you have the correct code for your production build.');\n}\n\n\n\n/***/ }),\n/* 30 */\n/***/ (function(module, exports, __webpack_require__) {\n\nmodule.exports = __webpack_require__(31);\n\n/***/ }),\n/* 31 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n/* WEBPACK VAR INJECTION */(function(global, module) {\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _ponyfill = __webpack_require__(32);\n\nvar _ponyfill2 = _interopRequireDefault(_ponyfill);\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : { 'default': obj };\n}\n\nvar root; /* global window */\n\nif (typeof self !== 'undefined') {\n  root = self;\n} else if (typeof window !== 'undefined') {\n  root = window;\n} else if (typeof global !== 'undefined') {\n  root = global;\n} else if (true) {\n  root = module;\n} else {\n  root = Function('return this')();\n}\n\nvar result = (0, _ponyfill2['default'])(root);\nexports['default'] = result;\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(14), __webpack_require__(45)(module)))\n\n/***/ }),\n/* 32 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n\tvalue: true\n});\nexports['default'] = symbolObservablePonyfill;\nfunction symbolObservablePonyfill(root) {\n\tvar result;\n\tvar _Symbol = root.Symbol;\n\n\tif (typeof _Symbol === 'function') {\n\t\tif (_Symbol.observable) {\n\t\t\tresult = _Symbol.observable;\n\t\t} else {\n\t\t\tresult = _Symbol('observable');\n\t\t\t_Symbol.observable = result;\n\t\t}\n\t} else {\n\t\tresult = '@@observable';\n\t}\n\n\treturn result;\n};\n\n/***/ }),\n/* 33 */\n/***/ (function(module, exports) {\n\n/*__wc__loader*/!function (a) {\n  var b = \"<dom-module id=\\\"fake-app\\\"><template><style>:host{display:block;width:80%;margin:30px auto;background-color:white;padding:10px 20px 30px;box-shadow:0px 10px 20px rgba(0,0,0,0.2);}</style><slot></slot><p><small>Running on Polymer [[version]]</small></p><list-data></list-data></template></dom-module>\";if (a.body) {\n    var c = a.body,\n        d = a.createElement(\"div\");for (d.innerHTML = b; d.children.length > 0;) c.appendChild(d.children[0]);\n  } else a.write(b);\n}(document);\n\n/***/ }),\n/* 34 */\n/***/ (function(module, exports) {\n\n/*__wc__loader*/!function (a) {\n  var b = \"<dom-module id=\\\"list-data\\\"><template><style>li{margin:10px 0;transition:all 0.6s ease;}ul:hover li{opacity:0.3;}ul:hover li:hover{cursor:pointer;opacity:1;}</style><ul><dom-repeat items=\\\"[[data]]\\\"><template><li data-id$=\\\"[[item.id]]\\\" data-user$=\\\"[[item.userId]]\\\"><strong>[[item.title]]</strong> - <small>[[item.body]]</small></li></template></dom-repeat></ul></template></dom-module>\";if (a.body) {\n    var c = a.body,\n        d = a.createElement(\"div\");for (d.innerHTML = b; d.children.length > 0;) c.appendChild(d.children[0]);\n  } else a.write(b);\n}(document);\n\n/***/ }),\n/* 35 */\n/***/ (function(module, exports, __webpack_require__) {\n\n/*__wc__loader*/\n__webpack_require__(0);\n\n__webpack_require__(3);\n\n(function () {\n  'use strict';\n\n  let modules = {};\n  let lcModules = {};\n  function findModule(id) {\n    return modules[id] || lcModules[id.toLowerCase()];\n  }\n\n  function styleOutsideTemplateCheck(inst) {\n    if (inst.querySelector('style')) {\n      console.warn('dom-module %s has style outside template', inst.id);\n    }\n  }\n\n  /**\n   * The `dom-module` element registers the dom it contains to the name given\n   * by the module's id attribute. It provides a unified database of dom\n   * accessible via its static `import` API.\n   *\n   * A key use case of `dom-module` is for providing custom element `<template>`s\n   * via HTML imports that are parsed by the native HTML parser, that can be\n   * relocated during a bundling pass and still looked up by `id`.\n   *\n   * Example:\n   *\n   *     <dom-module id=\"foo\">\n   *       <img src=\"stuff.png\">\n   *     </dom-module>\n   *\n   * Then in code in some other location that cannot access the dom-module above\n   *\n   *     let img = document.createElement('dom-module').import('foo', 'img');\n   *\n   * @extends HTMLElement\n   * @memberof Polymer\n   * @summary Custom element that provides a registry of relocatable DOM content\n   *   by `id` that is agnostic to bundling.\n   */\n  class DomModule extends HTMLElement {\n\n    static get observedAttributes() {\n      return ['id'];\n    }\n\n    /**\n     * Retrieves the element specified by the css `selector` in the module\n     * registered by `id`. For example, this.import('foo', 'img');\n     * @param {string} id The id of the dom-module in which to search.\n     * @param {string=} selector The css selector by which to find the element.\n     * @return {Element} Returns the element which matches `selector` in the\n     * module registered at the specified `id`.\n     */\n    static import(id, selector) {\n      if (id) {\n        let m = findModule(id);\n        if (m && selector) {\n          return m.querySelector(selector);\n        }\n        return m;\n      }\n      return null;\n    }\n\n    attributeChangedCallback(name, old, value) {\n      if (old !== value) {\n        this.register();\n      }\n    }\n\n    /**\n     * The absolute URL of the original location of this `dom-module`.\n     *\n     * This value will differ from this element's `ownerDocument` in the\n     * following ways:\n     * - Takes into account any `assetpath` attribute added during bundling\n     *   to indicate the original location relative to the bundled location\n     * - Uses the HTMLImports polyfill's `importForElement` API to ensure\n     *   the path is relative to the import document's location since\n     *   `ownerDocument` is not currently polyfilled\n     */\n    get assetpath() {\n      // Don't override existing assetpath.\n      if (!this.__assetpath) {\n        // note: assetpath set via an attribute must be relative to this\n        // element's location; accomodate polyfilled HTMLImports\n        const owner = window.HTMLImports && HTMLImports.importForElement ? HTMLImports.importForElement(this) || document : this.ownerDocument;\n        const url = Polymer.ResolveUrl.resolveUrl(this.getAttribute('assetpath') || '', owner.baseURI);\n        this.__assetpath = Polymer.ResolveUrl.pathFromUrl(url);\n      }\n      return this.__assetpath;\n    }\n\n    /**\n     * Registers the dom-module at a given id. This method should only be called\n     * when a dom-module is imperatively created. For\n     * example, `document.createElement('dom-module').register('foo')`.\n     * @param {string=} id The id at which to register the dom-module.\n     */\n    register(id) {\n      id = id || this.id;\n      if (id) {\n        this.id = id;\n        // store id separate from lowercased id so that\n        // in all cases mixedCase id will stored distinctly\n        // and lowercase version is a fallback\n        modules[id] = this;\n        lcModules[id.toLowerCase()] = this;\n        styleOutsideTemplateCheck(this);\n      }\n    }\n  }\n\n  DomModule.prototype['modules'] = modules;\n\n  customElements.define('dom-module', DomModule);\n\n  // export\n  Polymer.DomModule = DomModule;\n})();\n\n/***/ }),\n/* 36 */\n/***/ (function(module, exports, __webpack_require__) {\n\n/*__wc__loader*/\n__webpack_require__(4);\n\n__webpack_require__(44);\n\n__webpack_require__(40);\n\n__webpack_require__(41);\n\n__webpack_require__(11);\n\n(function () {\n  'use strict';\n\n  /**\n   * @constructor\n   * @implements {Polymer_OptionalMutableData}\n   * @extends {Polymer.Element}\n   */\n\n  const domRepeatBase = Polymer.OptionalMutableData(Polymer.Element);\n\n  /**\n   * The `<dom-repeat>` element will automatically stamp and binds one instance\n   * of template content to each object in a user-provided array.\n   * `dom-repeat` accepts an `items` property, and one instance of the template\n   * is stamped for each item into the DOM at the location of the `dom-repeat`\n   * element.  The `item` property will be set on each instance's binding\n   * scope, thus templates should bind to sub-properties of `item`.\n   *\n   * Example:\n   *\n   * ```html\n   * <dom-module id=\"employee-list\">\n   *\n   *   <template>\n   *\n   *     <div> Employee list: </div>\n   *     <template is=\"dom-repeat\" items=\"{{employees}}\">\n   *         <div>First name: <span>{{item.first}}</span></div>\n   *         <div>Last name: <span>{{item.last}}</span></div>\n   *     </template>\n   *\n   *   </template>\n   *\n   *   <script>\n   *     Polymer({\n   *       is: 'employee-list',\n   *       ready: function() {\n   *         this.employees = [\n   *             {first: 'Bob', last: 'Smith'},\n   *             {first: 'Sally', last: 'Johnson'},\n   *             ...\n   *         ];\n   *       }\n   *     });\n   *   < /script>\n   *\n   * </dom-module>\n   * ```\n   *\n   * Notifications for changes to items sub-properties will be forwarded to template\n   * instances, which will update via the normal structured data notification system.\n   *\n   * Mutations to the `items` array itself should me made using the Array\n   * mutation API's on `Polymer.Base` (`push`, `pop`, `splice`, `shift`,\n   * `unshift`), and template instances will be kept in sync with the data in the\n   * array.\n   *\n   * Events caught by event handlers within the `dom-repeat` template will be\n   * decorated with a `model` property, which represents the binding scope for\n   * each template instance.  The model is an instance of Polymer.Base, and should\n   * be used to manipulate data on the instance, for example\n   * `event.model.set('item.checked', true);`.\n   *\n   * Alternatively, the model for a template instance for an element stamped by\n   * a `dom-repeat` can be obtained using the `modelForElement` API on the\n   * `dom-repeat` that stamped it, for example\n   * `this.$.domRepeat.modelForElement(event.target).set('item.checked', true);`.\n   * This may be useful for manipulating instance data of event targets obtained\n   * by event handlers on parents of the `dom-repeat` (event delegation).\n   *\n   * A view-specific filter/sort may be applied to each `dom-repeat` by supplying a\n   * `filter` and/or `sort` property.  This may be a string that names a function on\n   * the host, or a function may be assigned to the property directly.  The functions\n   * should implemented following the standard `Array` filter/sort API.\n   *\n   * In order to re-run the filter or sort functions based on changes to sub-fields\n   * of `items`, the `observe` property may be set as a space-separated list of\n   * `item` sub-fields that should cause a re-filter/sort when modified.  If\n   * the filter or sort function depends on properties not contained in `items`,\n   * the user should observe changes to those properties and call `render` to update\n   * the view based on the dependency change.\n   *\n   * For example, for an `dom-repeat` with a filter of the following:\n   *\n   * ```js\n   * isEngineer: function(item) {\n   *     return item.type == 'engineer' || item.manager.type == 'engineer';\n   * }\n   * ```\n   *\n   * Then the `observe` property should be configured as follows:\n   *\n   * ```html\n   * <template is=\"dom-repeat\" items=\"{{employees}}\"\n   *           filter=\"isEngineer\" observe=\"type manager.type\">\n   * ```\n   *\n   * @polymerElement\n   * @memberof Polymer\n   * @extends Polymer.Element\n   * @mixes Polymer.MutableData\n   * @summary Custom element for stamping instance of a template bound to\n   *   items in an array.\n   */\n  class DomRepeat extends domRepeatBase {\n\n    // Not needed to find template; can be removed once the analyzer\n    // can find the tag name from customElements.define call\n    static get is() {\n      return 'dom-repeat';\n    }\n\n    static get template() {\n      return null;\n    }\n\n    static get properties() {\n\n      /**\n       * Fired whenever DOM is added or removed by this template (by\n       * default, rendering occurs lazily).  To force immediate rendering, call\n       * `render`.\n       *\n       * @event dom-change\n       */\n      return {\n\n        /**\n         * An array containing items determining how many instances of the template\n         * to stamp and that that each template instance should bind to.\n         */\n        items: {\n          type: Array\n        },\n\n        /**\n         * The name of the variable to add to the binding scope for the array\n         * element associated with a given template instance.\n         */\n        as: {\n          type: String,\n          value: 'item'\n        },\n\n        /**\n         * The name of the variable to add to the binding scope with the index\n         * of the instance in the sorted and filtered list of rendered items.\n         * Note, for the index in the `this.items` array, use the value of the\n         * `itemsIndexAs` property.\n         */\n        indexAs: {\n          type: String,\n          value: 'index'\n        },\n\n        /**\n         * The name of the variable to add to the binding scope with the index\n         * of the instance in the `this.items` array. Note, for the index of\n         * this instance in the sorted and filtered list of rendered items,\n         * use the value of the `indexAs` property.\n         */\n        itemsIndexAs: {\n          type: String,\n          value: 'itemsIndex'\n        },\n\n        /**\n         * A function that should determine the sort order of the items.  This\n         * property should either be provided as a string, indicating a method\n         * name on the element's host, or else be an actual function.  The\n         * function should match the sort function passed to `Array.sort`.\n         * Using a sort function has no effect on the underlying `items` array.\n         */\n        sort: {\n          type: Function,\n          observer: '__sortChanged'\n        },\n\n        /**\n         * A function that can be used to filter items out of the view.  This\n         * property should either be provided as a string, indicating a method\n         * name on the element's host, or else be an actual function.  The\n         * function should match the sort function passed to `Array.filter`.\n         * Using a filter function has no effect on the underlying `items` array.\n         */\n        filter: {\n          type: Function,\n          observer: '__filterChanged'\n        },\n\n        /**\n         * When using a `filter` or `sort` function, the `observe` property\n         * should be set to a space-separated list of the names of item\n         * sub-fields that should trigger a re-sort or re-filter when changed.\n         * These should generally be fields of `item` that the sort or filter\n         * function depends on.\n         */\n        observe: {\n          type: String,\n          observer: '__observeChanged'\n        },\n\n        /**\n         * When using a `filter` or `sort` function, the `delay` property\n         * determines a debounce time after a change to observed item\n         * properties that must pass before the filter or sort is re-run.\n         * This is useful in rate-limiting shuffing of the view when\n         * item changes may be frequent.\n         */\n        delay: Number,\n\n        /**\n         * Count of currently rendered items after `filter` (if any) has been applied.\n         * If \"chunking mode\" is enabled, `renderedItemCount` is updated each time a\n         * set of template instances is rendered.\n         *\n         */\n        renderedItemCount: {\n          type: Number,\n          notify: true,\n          readOnly: true\n        },\n\n        /**\n         * Defines an initial count of template instances to render after setting\n         * the `items` array, before the next paint, and puts the `dom-repeat`\n         * into \"chunking mode\".  The remaining items will be created and rendered\n         * incrementally at each animation frame therof until all instances have\n         * been rendered.\n         */\n        initialCount: {\n          type: Number,\n          observer: '__initializeChunking'\n        },\n\n        /**\n         * When `initialCount` is used, this property defines a frame rate to\n         * target by throttling the number of instances rendered each frame to\n         * not exceed the budget for the target frame rate.  Setting this to a\n         * higher number will allow lower latency and higher throughput for\n         * things like event handlers, but will result in a longer time for the\n         * remaining items to complete rendering.\n         */\n        targetFramerate: {\n          type: Number,\n          value: 20\n        },\n\n        _targetFrameTime: {\n          type: Number,\n          computed: '__computeFrameTime(targetFramerate)'\n        }\n\n      };\n    }\n\n    static get observers() {\n      return ['__itemsChanged(items.*)'];\n    }\n\n    constructor() {\n      super();\n      this.__instances = [];\n      this.__limit = Infinity;\n      this.__pool = [];\n      this.__renderDebouncer = null;\n      this.__itemsIdxToInstIdx = {};\n      this.__chunkCount = null;\n      this.__lastChunkTime = null;\n      this.__needFullRefresh = false;\n      this.__sortFn = null;\n      this.__filterFn = null;\n      this.__observePaths = null;\n      this.__ctor = null;\n    }\n\n    disconnectedCallback() {\n      super.disconnectedCallback();\n      this.__isDetached = true;\n      for (let i = 0; i < this.__instances.length; i++) {\n        this.__detachInstance(i);\n      }\n    }\n\n    connectedCallback() {\n      super.connectedCallback();\n      // only perform attachment if the element was previously detached.\n      if (this.__isDetached) {\n        this.__isDetached = false;\n        let parent = this.parentNode;\n        for (let i = 0; i < this.__instances.length; i++) {\n          this.__attachInstance(i, parent);\n        }\n      }\n    }\n\n    __ensureTemplatized() {\n      // Templatizing (generating the instance constructor) needs to wait\n      // until ready, since won't have its template content handed back to\n      // it until then\n      if (!this.__ctor) {\n        let template = this.template = this.querySelector('template');\n        if (!template) {\n          // // Wait until childList changes and template should be there by then\n          let observer = new MutationObserver(() => {\n            if (this.querySelector('template')) {\n              observer.disconnect();\n              this.__render();\n            } else {\n              throw new Error('dom-repeat requires a <template> child');\n            }\n          });\n          observer.observe(this, { childList: true });\n          return false;\n        }\n        // Template instance props that should be excluded from forwarding\n        let instanceProps = {};\n        instanceProps[this.as] = true;\n        instanceProps[this.indexAs] = true;\n        instanceProps[this.itemsIndexAs] = true;\n        this.__ctor = Polymer.Templatize.templatize(template, this, {\n          mutableData: this.mutableData,\n          parentModel: true,\n          instanceProps: instanceProps,\n          forwardHostProp: function (prop, value) {\n            let i$ = this.__instances;\n            for (let i = 0, inst; i < i$.length && (inst = i$[i]); i++) {\n              inst.forwardHostProp(prop, value);\n            }\n          },\n          notifyInstanceProp: function (inst, prop, value) {\n            if (Polymer.Path.matches(this.as, prop)) {\n              let idx = inst[this.itemsIndexAs];\n              if (prop == this.as) {\n                this.items[idx] = value;\n              }\n              let path = Polymer.Path.translate(this.as, 'items.' + idx, prop);\n              this.notifyPath(path, value);\n            }\n          }\n        });\n      }\n      return true;\n    }\n\n    __getMethodHost() {\n      // Technically this should be the owner of the outermost template.\n      // In shadow dom, this is always getRootNode().host, but we can\n      // approximate this via cooperation with our dataHost always setting\n      // `_methodHost` as long as there were bindings (or id's) on this\n      // instance causing it to get a dataHost.\n      return this.__dataHost._methodHost || this.__dataHost;\n    }\n\n    __sortChanged(sort) {\n      let methodHost = this.__getMethodHost();\n      this.__sortFn = sort && (typeof sort == 'function' ? sort : function () {\n        return methodHost[sort].apply(methodHost, arguments);\n      });\n      this.__needFullRefresh = true;\n      if (this.items) {\n        this.__debounceRender(this.__render);\n      }\n    }\n\n    __filterChanged(filter) {\n      let methodHost = this.__getMethodHost();\n      this.__filterFn = filter && (typeof filter == 'function' ? filter : function () {\n        return methodHost[filter].apply(methodHost, arguments);\n      });\n      this.__needFullRefresh = true;\n      if (this.items) {\n        this.__debounceRender(this.__render);\n      }\n    }\n\n    __computeFrameTime(rate) {\n      return Math.ceil(1000 / rate);\n    }\n\n    __initializeChunking() {\n      if (this.initialCount) {\n        this.__limit = this.initialCount;\n        this.__chunkCount = this.initialCount;\n        this.__lastChunkTime = performance.now();\n      }\n    }\n\n    __tryRenderChunk() {\n      // Debounced so that multiple calls through `_render` between animation\n      // frames only queue one new rAF (e.g. array mutation & chunked render)\n      if (this.items && this.__limit < this.items.length) {\n        this.__debounceRender(this.__requestRenderChunk);\n      }\n    }\n\n    __requestRenderChunk() {\n      requestAnimationFrame(() => this.__renderChunk());\n    }\n\n    __renderChunk() {\n      // Simple auto chunkSize throttling algorithm based on feedback loop:\n      // measure actual time between frames and scale chunk count by ratio\n      // of target/actual frame time\n      let currChunkTime = performance.now();\n      let ratio = this._targetFrameTime / (currChunkTime - this.__lastChunkTime);\n      this.__chunkCount = Math.round(this.__chunkCount * ratio) || 1;\n      this.__limit += this.__chunkCount;\n      this.__lastChunkTime = currChunkTime;\n      this.__debounceRender(this.__render);\n    }\n\n    __observeChanged() {\n      this.__observePaths = this.observe && this.observe.replace('.*', '.').split(' ');\n    }\n\n    __itemsChanged(change) {\n      if (this.items && !Array.isArray(this.items)) {\n        console.warn('dom-repeat expected array for `items`, found', this.items);\n      }\n      // If path was to an item (e.g. 'items.3' or 'items.3.foo'), forward the\n      // path to that instance synchronously (retuns false for non-item paths)\n      if (!this.__handleItemPath(change.path, change.value)) {\n        // Otherwise, the array was reset ('items') or spliced ('items.splices'),\n        // so queue a full refresh\n        this.__needFullRefresh = true;\n        this.__initializeChunking();\n        this.__debounceRender(this.__render);\n      }\n    }\n\n    __handleObservedPaths(path) {\n      if (this.__observePaths) {\n        path = path.substring(path.indexOf('.') + 1);\n        let paths = this.__observePaths;\n        for (let i = 0; i < paths.length; i++) {\n          if (path.indexOf(paths[i]) === 0) {\n            this.__needFullRefresh = true;\n            this.__debounceRender(this.__render, this.delay);\n            return true;\n          }\n        }\n      }\n    }\n\n    /**\n     * @param {function()} fn Function to debounce.\n     * @param {number=} delay Delay in ms to debounce by.\n     */\n    __debounceRender(fn, delay) {\n      this.__renderDebouncer = Polymer.Debouncer.debounce(this.__renderDebouncer, delay > 0 ? Polymer.Async.timeOut.after(delay) : Polymer.Async.microTask, fn.bind(this));\n      Polymer.enqueueDebouncer(this.__renderDebouncer);\n    }\n\n    /**\n     * Forces the element to render its content. Normally rendering is\n     * asynchronous to a provoking change. This is done for efficiency so\n     * that multiple changes trigger only a single render. The render method\n     * should be called if, for example, template rendering is required to\n     * validate application state.\n     */\n    render() {\n      // Queue this repeater, then flush all in order\n      this.__needFullRefresh = true;\n      this.__debounceRender(this.__render);\n      Polymer.flush();\n    }\n\n    __render() {\n      if (!this.__ensureTemplatized()) {\n        // No template found yet\n        return;\n      }\n      this.__applyFullRefresh();\n      // Reset the pool\n      // TODO(kschaaf): Reuse pool across turns and nested templates\n      // Now that objects/arrays are re-evaluated when set, we can safely\n      // reuse pooled instances across turns, however we still need to decide\n      // semantics regarding how long to hold, how many to hold, etc.\n      this.__pool.length = 0;\n      // Set rendered item count\n      this._setRenderedItemCount(this.__instances.length);\n      // Notify users\n      this.dispatchEvent(new CustomEvent('dom-change', {\n        bubbles: true,\n        composed: true\n      }));\n      // Check to see if we need to render more items\n      this.__tryRenderChunk();\n    }\n\n    __applyFullRefresh() {\n      const items = this.items || [];\n      let isntIdxToItemsIdx = new Array(items.length);\n      for (let i = 0; i < items.length; i++) {\n        isntIdxToItemsIdx[i] = i;\n      }\n      // Apply user filter\n      if (this.__filterFn) {\n        isntIdxToItemsIdx = isntIdxToItemsIdx.filter((i, idx, array) => this.__filterFn(items[i], idx, array));\n      }\n      // Apply user sort\n      if (this.__sortFn) {\n        isntIdxToItemsIdx.sort((a, b) => this.__sortFn(items[a], items[b]));\n      }\n      // items->inst map kept for item path forwarding\n      const itemsIdxToInstIdx = this.__itemsIdxToInstIdx = {};\n      let instIdx = 0;\n      // Generate instances and assign items\n      const limit = Math.min(isntIdxToItemsIdx.length, this.__limit);\n      for (; instIdx < limit; instIdx++) {\n        let inst = this.__instances[instIdx];\n        let itemIdx = isntIdxToItemsIdx[instIdx];\n        let item = items[itemIdx];\n        itemsIdxToInstIdx[itemIdx] = instIdx;\n        if (inst && instIdx < this.__limit) {\n          inst._setPendingProperty(this.as, item);\n          inst._setPendingProperty(this.indexAs, instIdx);\n          inst._setPendingProperty(this.itemsIndexAs, itemIdx);\n          inst._flushProperties();\n        } else {\n          this.__insertInstance(item, instIdx, itemIdx);\n        }\n      }\n      // Remove any extra instances from previous state\n      for (let i = this.__instances.length - 1; i >= instIdx; i--) {\n        this.__detachAndRemoveInstance(i);\n      }\n    }\n\n    __detachInstance(idx) {\n      let inst = this.__instances[idx];\n      for (let i = 0; i < inst.children.length; i++) {\n        let el = inst.children[i];\n        inst.root.appendChild(el);\n      }\n      return inst;\n    }\n\n    __attachInstance(idx, parent) {\n      let inst = this.__instances[idx];\n      parent.insertBefore(inst.root, this);\n    }\n\n    __detachAndRemoveInstance(idx) {\n      let inst = this.__detachInstance(idx);\n      if (inst) {\n        this.__pool.push(inst);\n      }\n      this.__instances.splice(idx, 1);\n    }\n\n    __stampInstance(item, instIdx, itemIdx) {\n      let model = {};\n      model[this.as] = item;\n      model[this.indexAs] = instIdx;\n      model[this.itemsIndexAs] = itemIdx;\n      return new this.__ctor(model);\n    }\n\n    __insertInstance(item, instIdx, itemIdx) {\n      let inst = this.__pool.pop();\n      if (inst) {\n        // TODO(kschaaf): If the pool is shared across turns, hostProps\n        // need to be re-set to reused instances in addition to item\n        inst._setPendingProperty(this.as, item);\n        inst._setPendingProperty(this.indexAs, instIdx);\n        inst._setPendingProperty(this.itemsIndexAs, itemIdx);\n        inst._flushProperties();\n      } else {\n        inst = this.__stampInstance(item, instIdx, itemIdx);\n      }\n      let beforeRow = this.__instances[instIdx + 1];\n      let beforeNode = beforeRow ? beforeRow.children[0] : this;\n      this.parentNode.insertBefore(inst.root, beforeNode);\n      this.__instances[instIdx] = inst;\n      return inst;\n    }\n\n    // Implements extension point from Templatize mixin\n    _showHideChildren(hidden) {\n      for (let i = 0; i < this.__instances.length; i++) {\n        this.__instances[i]._showHideChildren(hidden);\n      }\n    }\n\n    // Called as a side effect of a host items.<key>.<path> path change,\n    // responsible for notifying item.<path> changes to inst for key\n    __handleItemPath(path, value) {\n      let itemsPath = path.slice(6); // 'items.'.length == 6\n      let dot = itemsPath.indexOf('.');\n      let itemsIdx = dot < 0 ? itemsPath : itemsPath.substring(0, dot);\n      // If path was index into array...\n      if (itemsIdx == parseInt(itemsIdx, 10)) {\n        let itemSubPath = dot < 0 ? '' : itemsPath.substring(dot + 1);\n        // See if the item subpath should trigger a full refresh...\n        if (!this.__handleObservedPaths(itemSubPath)) {\n          // If not, forward to the instance for that index\n          let instIdx = this.__itemsIdxToInstIdx[itemsIdx];\n          let inst = this.__instances[instIdx];\n          if (inst) {\n            let itemPath = this.as + (itemSubPath ? '.' + itemSubPath : '');\n            // This is effectively `notifyPath`, but avoids some of the overhead\n            // of the public API\n            inst._setPendingPropertyOrPath(itemPath, value, false, true);\n            inst._flushProperties();\n          }\n        }\n        return true;\n      }\n    }\n\n    /**\n     * Returns the item associated with a given element stamped by\n     * this `dom-repeat`.\n     *\n     * Note, to modify sub-properties of the item,\n     * `modelForElement(el).set('item.<sub-prop>', value)`\n     * should be used.\n     *\n     * @param {HTMLElement} el Element for which to return the item.\n     * @return {*} Item associated with the element.\n     */\n    itemForElement(el) {\n      let instance = this.modelForElement(el);\n      return instance && instance[this.as];\n    }\n\n    /**\n     * Returns the inst index for a given element stamped by this `dom-repeat`.\n     * If `sort` is provided, the index will reflect the sorted order (rather\n     * than the original array order).\n     *\n     * @param {HTMLElement} el Element for which to return the index.\n     * @return {*} Row index associated with the element (note this may\n     *   not correspond to the array index if a user `sort` is applied).\n     */\n    indexForElement(el) {\n      let instance = this.modelForElement(el);\n      return instance && instance[this.indexAs];\n    }\n\n    /**\n     * Returns the template \"model\" associated with a given element, which\n     * serves as the binding scope for the template instance the element is\n     * contained in. A template model is an instance of `Polymer.Base`, and\n     * should be used to manipulate data associated with this template instance.\n     *\n     * Example:\n     *\n     *   let model = modelForElement(el);\n     *   if (model.index < 10) {\n     *     model.set('item.checked', true);\n     *   }\n     *\n     * @param {HTMLElement} el Element for which to return a template model.\n     * @return {TemplateInstanceBase} Model representing the binding scope for\n     *   the element.\n     */\n    modelForElement(el) {\n      return Polymer.Templatize.modelForElement(this.template, el);\n    }\n\n  }\n\n  customElements.define(DomRepeat.is, DomRepeat);\n\n  Polymer.DomRepeat = DomRepeat;\n})();\n\n/***/ }),\n/* 37 */\n/***/ (function(module, exports, __webpack_require__) {\n\n/*__wc__loader*/\n__webpack_require__(0);\n\n__webpack_require__(1);\n\n__webpack_require__(2);\n\n__webpack_require__(43);\n\n__webpack_require__(3);\n\n__webpack_require__(35);\n\n__webpack_require__(12);\n\n(function () {\n  'use strict';\n  /**\n   * @typedef Object<string, {\n   *   value: *,\n   *   type: (Function | undefined),\n   *   readOnly: (boolean | undefined),\n   *   computed: (string | undefined),\n   *   reflectToAttribute: (boolean | undefined),\n   *   notify: (boolean | undefined),\n   *   observer: (string | undefined)\n   * }>)\n   */\n\n  let PolymerElementProperties; // eslint-disable-line no-unused-vars\n\n  /** @record */\n  let PolymerElementConstructor = function () {}; // eslint-disable-line no-unused-vars\n  /** @type {(string | undefined)} */\n  PolymerElementConstructor.is;\n  /** @type {(string | undefined)} */\n  PolymerElementConstructor.extends;\n  /** @type {(!PolymerElementProperties | undefined)} */\n  PolymerElementConstructor.properties;\n  /** @type {(!Array<string> | undefined)} */\n  PolymerElementConstructor.observers;\n  /** @type {(!HTMLTemplateElement | string | undefined)} */\n  PolymerElementConstructor.template;\n\n  /**\n   * Element class mixin that provides the core API for Polymer's meta-programming\n   * features including template stamping, data-binding, attribute deserialization,\n   * and property change observation.\n   *\n   * Subclassers may provide the following static getters to return metadata\n   * used to configure Polymer's features for the class:\n   *\n   * - `static get is()`: When the template is provided via a `dom-module`,\n   *   users should return the `dom-module` id from a static `is` getter.  If\n   *   no template is needed or the template is provided directly via the\n   *   `template` getter, there is no need to define `is` for the element.\n   *\n   * - `static get template()`: Users may provide the template directly (as\n   *   opposed to via `dom-module`) by implementing a static `template` getter.\n   *   The getter may return an `HTMLTemplateElement` or a string, which will\n   *   automatically be parsed into a template.\n   *\n   * - `static get properties()`: Should return an object describing\n   *   property-related metadata used by Polymer features (key: property name\n   *   value: object containing property metadata). Valid keys in per-property\n   *   metadata include:\n   *   - `type` (String|Number|Object|Array|...): Used by\n   *     `attributeChangedCallback` to determine how string-based attributes\n   *     are deserialized to JavaScript property values.\n   *   - `notify` (boolean): Causes a change in the property to fire a\n   *     non-bubbling event called `<property>-changed`. Elements that have\n   *     enabled two-way binding to the property use this event to observe changes.\n   *   - `readOnly` (boolean): Creates a getter for the property, but no setter.\n   *     To set a read-only property, use the private setter method\n   *     `_setProperty(property, value)`.\n   *   - `observer` (string): Observer method name that will be called when\n   *     the property changes. The arguments of the method are\n   *     `(value, previousValue)`.\n   *   - `computed` (string): String describing method and dependent properties\n   *     for computing the value of this property (e.g. `'computeFoo(bar, zot)'`).\n   *     Computed properties are read-only by default and can only be changed\n   *     via the return value of the computing method.\n   *\n   * - `static get observers()`: Array of strings describing multi-property\n   *   observer methods and their dependent properties (e.g.\n   *   `'observeABC(a, b, c)'`).\n   *\n   * The base class provides default implementations for the following standard\n   * custom element lifecycle callbacks; users may override these, but should\n   * call the super method to ensure\n   * - `constructor`: Run when the element is created or upgraded\n   * - `connectedCallback`: Run each time the element is connected to the\n   *   document\n   * - `disconnectedCallback`: Run each time the element is disconnected from\n   *   the document\n   * - `attributeChangedCallback`: Run each time an attribute in\n   *   `observedAttributes` is set or removed (note: this element's default\n   *   `observedAttributes` implementation will automatically return an array\n   *   of dash-cased attributes based on `properties`)\n   *\n   * @polymerMixin\n   * @mixes Polymer.PropertyEffects\n   * @memberof Polymer\n   * @property rootPath {string} Set to the value of `Polymer.rootPath`,\n   *   which defaults to the main document path\n   * @property importPath {string} Set to the value of the class's static\n   *   `importPath` property, which defaults to the path of this element's\n   *   `dom-module` (when `is` is used), but can be overridden for other\n   *   import strategies.\n   * @summary Element class mixin that provides the core API for Polymer's\n   * meta-programming features.\n   */\n  Polymer.ElementMixin = Polymer.dedupingMixin(base => {\n\n    /**\n     * @constructor\n     * @extends {base}\n     * @implements {Polymer_PropertyEffects}\n     */\n    const polymerElementBase = Polymer.PropertyEffects(base);\n\n    let caseMap = Polymer.CaseMap;\n\n    /**\n     * Returns the `properties` object specifically on `klass`. Use for:\n     * (1) super chain mixes togther to make `propertiesForClass` which is\n     * then used to make `observedAttributes`.\n     * (2) properties effects and observers are created from it at `finalize` time.\n     *\n     * @param {HTMLElement} klass Element class\n     * @return {Object} Object containing own properties for this class\n     * @private\n     */\n    function ownPropertiesForClass(klass) {\n      if (!klass.hasOwnProperty(JSCompiler_renameProperty('__ownProperties', klass))) {\n        klass.__ownProperties = klass.hasOwnProperty(JSCompiler_renameProperty('properties', klass)) ? klass.properties : {};\n      }\n      return klass.__ownProperties;\n    }\n\n    /**\n     * Returns the `observers` array specifically on `klass`. Use for\n     * setting up observers.\n     *\n     * @param {HTMLElement} klass Element class\n     * @return {Array} Array containing own observers for this class\n     * @private\n     */\n    function ownObserversForClass(klass) {\n      if (!klass.hasOwnProperty(JSCompiler_renameProperty('__ownObservers', klass))) {\n        klass.__ownObservers = klass.hasOwnProperty(JSCompiler_renameProperty('observers', klass)) ? klass.observers : [];\n      }\n      return klass.__ownObservers;\n    }\n\n    /**\n     * Mixes `props` into `flattenedProps` but upgrades shorthand type\n     * syntax to { type: Type}.\n     *\n     * @param {Object} flattenedProps Bag to collect flattened properties into\n     * @param {Object} props Bag of properties to add to `flattenedProps`\n     * @return {Objecg} The input `flattenedProps` bag\n     * @private\n     */\n    function flattenProperties(flattenedProps, props) {\n      for (let p in props) {\n        let o = props[p];\n        if (typeof o == 'function') {\n          o = { type: o };\n        }\n        flattenedProps[p] = o;\n      }\n      return flattenedProps;\n    }\n\n    /**\n     * Returns a flattened list of properties mixed together from the chain of all\n     * constructor's `config.properties`. This list is used to create\n     * (1) observedAttributes,\n     * (2) class property default values\n     *\n     * @param {HTMLElement} klass Element class\n     * @return {PolymerElementProperties} Flattened properties for this class\n     * @private\n     */\n    function propertiesForClass(klass) {\n      if (!klass.hasOwnProperty(JSCompiler_renameProperty('__classProperties', klass))) {\n        klass.__classProperties = flattenProperties({}, ownPropertiesForClass(klass));\n        let superCtor = Object.getPrototypeOf(klass.prototype).constructor;\n        if (superCtor.prototype instanceof PolymerElement) {\n          klass.__classProperties = Object.assign(Object.create(propertiesForClass(superCtor)), klass.__classProperties);\n        }\n      }\n      return klass.__classProperties;\n    }\n\n    /**\n     * Returns a list of properties with default values.\n     * This list is created as an optimization since it is a subset of\n     * the list returned from `propertiesForClass`.\n     * This list is used in `_initializeProperties` to set property defaults.\n     *\n     * @param {HTMLElement} klass Element class\n     * @return {PolymerElementProperties} Flattened properties for this class\n     *   that have default values\n     * @private\n     */\n    function propertyDefaultsForClass(klass) {\n      if (!klass.hasOwnProperty(JSCompiler_renameProperty('__classPropertyDefaults', klass))) {\n        klass.__classPropertyDefaults = null;\n        let props = propertiesForClass(klass);\n        for (let p in props) {\n          let info = props[p];\n          if ('value' in info) {\n            klass.__classPropertyDefaults = klass.__classPropertyDefaults || {};\n            klass.__classPropertyDefaults[p] = info;\n          }\n        }\n      }\n      return klass.__classPropertyDefaults;\n    }\n\n    /**\n     * Returns true if a `klass` has finalized. Called in `ElementClass.finalize()`\n     * @param {HTMLElement} klass Element class\n     * @return {boolean} True if all metaprogramming for this class has been\n     *   completed\n     * @private\n     */\n    function hasClassFinalized(klass) {\n      return klass.hasOwnProperty(JSCompiler_renameProperty('__finalized', klass));\n    }\n\n    /**\n     * Called by `ElementClass.finalize()`. Ensures this `klass` and\n     * *all superclasses* are finalized by traversing the prototype chain\n     * and calling `klass.finalize()`.\n     *\n     * @param {HTMLElement} klass Element class\n     * @private\n     */\n    function finalizeClassAndSuper(klass) {\n      let proto = klass.prototype;\n      let superCtor = Object.getPrototypeOf(proto).constructor;\n      if (superCtor.prototype instanceof PolymerElement) {\n        superCtor.finalize();\n      }\n      finalizeClass(klass);\n    }\n\n    /**\n     * Configures a `klass` based on a staic `klass.config` object and\n     * a `template`. This includes creating accessors and effects\n     * for properties in `config` and the `template` as well as preparing the\n     * `template` for stamping.\n     *\n     * @param {HTMLElement} klass Element class\n     * @private\n     */\n    function finalizeClass(klass) {\n      klass.__finalized = true;\n      let proto = klass.prototype;\n      if (klass.hasOwnProperty(JSCompiler_renameProperty('is', klass)) && klass.is) {\n        Polymer.telemetry.register(proto);\n      }\n      let props = ownPropertiesForClass(klass);\n      if (props) {\n        finalizeProperties(proto, props);\n      }\n      let observers = ownObserversForClass(klass);\n      if (observers) {\n        finalizeObservers(proto, observers, props);\n      }\n      // note: create \"working\" template that is finalized at instance time\n      let template = klass.template;\n      if (template) {\n        if (typeof template === 'string') {\n          let t = document.createElement('template');\n          t.innerHTML = template;\n          template = t;\n        } else {\n          template = template.cloneNode(true);\n        }\n        proto._template = template;\n      }\n    }\n\n    /**\n     * Configures a `proto` based on a `properties` object.\n     * Leverages `PropertyEffects` to create property accessors and effects\n     * supporting, observers, reflecting to attributes, change notification,\n     * computed properties, and read only properties.\n     * @param {HTMLElement} proto Element class prototype to add accessors\n     *    and effects to\n     * @param {Object} properties Flattened bag of property descriptors for\n     *    this class\n     * @private\n     */\n    function finalizeProperties(proto, properties) {\n      for (let p in properties) {\n        createPropertyFromConfig(proto, p, properties[p], properties);\n      }\n    }\n\n    /**\n     * Configures a `proto` based on a `observers` array.\n     * Leverages `PropertyEffects` to create observers.\n     * @param {HTMLElement} proto Element class prototype to add accessors\n     *   and effects to\n     * @param {Object} observers Flattened array of observer descriptors for\n     *   this class\n     * @param {Object} dynamicFns Object containing keys for any properties\n     *   that are functions and should trigger the effect when the function\n     *   reference is changed\n     * @private\n     */\n    function finalizeObservers(proto, observers, dynamicFns) {\n      for (let i = 0; i < observers.length; i++) {\n        proto._createMethodObserver(observers[i], dynamicFns);\n      }\n    }\n\n    /**\n     * Creates effects for a property.\n     *\n     * Note, once a property has been set to\n     * `readOnly`, `computed`, `reflectToAttribute`, or `notify`\n     * these values may not be changed. For example, a subclass cannot\n     * alter these settings. However, additional `observers` may be added\n     * by subclasses.\n     *\n     * The info object should may contain property metadata as follows:\n     *\n     * * `type`: {function} type to which an attribute matching the property\n     * is deserialized. Note the property is camel-cased from a dash-cased\n     * attribute. For example, 'foo-bar' attribute is dersialized to a\n     * property named 'fooBar'.\n     *\n     * * `readOnly`: {boolean} creates a readOnly property and\n     * makes a private setter for the private of the form '_setFoo' for a\n     * property 'foo',\n     *\n     * * `computed`: {string} creates a computed property. A computed property\n     * also automatically is set to `readOnly: true`. The value is calculated\n     * by running a method and arguments parsed from the given string. For\n     * example 'compute(foo)' will compute a given property when the\n     * 'foo' property changes by executing the 'compute' method. This method\n     * must return the computed value.\n     *\n     * * `reflectToAttriute`: {boolean} If true, the property value is reflected\n     * to an attribute of the same name. Note, the attribute is dash-cased\n     * so a property named 'fooBar' is reflected as 'foo-bar'.\n     *\n     * * `notify`: {boolean} sends a non-bubbling notification event when\n     * the property changes. For example, a property named 'foo' sends an\n     * event named 'foo-changed' with `event.detail` set to the value of\n     * the property.\n     *\n     * * observer: {string} name of a method that runs when the property\n     * changes. The arguments of the method are (value, previousValue).\n     *\n     * Note: Users may want control over modifying property\n     * effects via subclassing. For example, a user might want to make a\n     * reflectToAttribute property not do so in a subclass. We've chosen to\n     * disable this because it leads to additional complication.\n     * For example, a readOnly effect generates a special setter. If a subclass\n     * disables the effect, the setter would fail unexpectedly.\n     * Based on feedback, we may want to try to make effects more malleable\n     * and/or provide an advanced api for manipulating them.\n     * Also consider adding warnings when an effect cannot be changed.\n     *\n     * @param {HTMLElement} proto Element class prototype to add accessors\n     *   and effects to\n     * @param {string} name Name of the property.\n     * @param {Object} info Info object from which to create property effects.\n     * Supported keys:\n     * @param {Object} allProps Flattened map of all properties defined in this\n     *   element (including inherited properties)\n     * @private\n     */\n    function createPropertyFromConfig(proto, name, info, allProps) {\n      // computed forces readOnly...\n      if (info.computed) {\n        info.readOnly = true;\n      }\n      // Note, since all computed properties are readOnly, this prevents\n      // adding additional computed property effects (which leads to a confusing\n      // setup where multiple triggers for setting a property)\n      // While we do have `hasComputedEffect` this is set on the property's\n      // dependencies rather than itself.\n      if (info.computed && !proto._hasReadOnlyEffect(name)) {\n        proto._createComputedProperty(name, info.computed, allProps);\n      }\n      if (info.readOnly && !proto._hasReadOnlyEffect(name)) {\n        proto._createReadOnlyProperty(name, !info.computed);\n      }\n      if (info.reflectToAttribute && !proto._hasReflectEffect(name)) {\n        proto._createReflectedProperty(name);\n      }\n      if (info.notify && !proto._hasNotifyEffect(name)) {\n        proto._createNotifyingProperty(name);\n      }\n      // always add observer\n      if (info.observer) {\n        proto._createPropertyObserver(name, info.observer, allProps[info.observer]);\n      }\n    }\n\n    /**\n     * Configures an element `proto` to function with a given `template`.\n     * The element name `is` and extends `ext` must be specified for ShadyCSS\n     * style scoping.\n     *\n     * @param {HTMLElement} proto Element class prototype to add accessors\n     *   and effects to\n     * @param {HTMLTemplateElement} template Template to process and bind\n     * @param {string} baseURI URL against which to resolve urls in\n     *   style element cssText\n     * @param {string} is Tag name (or type extension name) for this element\n     * @param {string=} ext For type extensions, the tag name that was extended\n     * @private\n     */\n    function finalizeTemplate(proto, template, baseURI, is, ext) {\n      // support `include=\"module-name\"`\n      let cssText = Polymer.StyleGather.cssFromTemplate(template, baseURI) + Polymer.StyleGather.cssFromModuleImports(is);\n      if (cssText) {\n        let style = document.createElement('style');\n        style.textContent = cssText;\n        template.content.insertBefore(style, template.content.firstChild);\n      }\n      if (window.ShadyCSS) {\n        window.ShadyCSS.prepareTemplate(template, is, ext);\n      }\n      proto._bindTemplate(template);\n    }\n\n    /**\n     * @polymerMixinClass\n     * @unrestricted\n     * @implements {Polymer_ElementMixin}\n     */\n    class PolymerElement extends polymerElementBase {\n\n      /**\n       * Standard Custom Elements V1 API.  The default implementation returns\n       * a list of dash-cased attributes based on a flattening of all properties\n       * declared in `static get properties()` for this element and any\n       * superclasses.\n       *\n       * @return {Array} Observed attribute list\n       */\n      static get observedAttributes() {\n        if (!this.hasOwnProperty(JSCompiler_renameProperty('__observedAttributes', this))) {\n          let list = [];\n          let properties = propertiesForClass(this);\n          for (let prop in properties) {\n            list.push(Polymer.CaseMap.camelToDashCase(prop));\n          }\n          this.__observedAttributes = list;\n        }\n        return this.__observedAttributes;\n      }\n\n      /**\n       * Called automatically when the first element instance is created to\n       * ensure that class finalization work has been completed.\n       * May be called by users to eagerly perform class finalization work\n       * prior to the creation of the first element instance.\n       *\n       * Class finalization work generally includes meta-programming such as\n       * creating property accessors and any property effect metadata needed for\n       * the features used.\n       *\n       * @public\n       */\n      static finalize() {\n        if (!hasClassFinalized(this)) {\n          finalizeClassAndSuper(this);\n        }\n      }\n\n      /**\n       * Returns the template that will be stamped into this element's shadow root.\n       *\n       * If a `static get is()` getter is defined, the default implementation\n       * will return the first `<template>` in a `dom-module` whose `id`\n       * matches this element's `is`.\n       *\n       * Users may override this getter to return an arbitrary template\n       * (in which case the `is` getter is unnecessary). The template returned\n       * may be either an `HTMLTemplateElement` or a string that will be\n       * automatically parsed into a template.\n       *\n       * Note that when subclassing, if the super class overrode the default\n       * implementation and the subclass would like to provide an alternate\n       * template via a `dom-module`, it should override this getter and\n       * return `Polymer.DomModule.import(this.is, 'template')`.\n       *\n       * If a subclass would like to modify the super class template, it should\n       * clone it rather than modify it in place.  If the getter does expensive\n       * work such as cloning/modifying a template, it should memoize the\n       * template for maximum performance:\n       *\n       *   let memoizedTemplate;\n       *   class MySubClass extends MySuperClass {\n       *     static get template() {\n       *       if (!memoizedTemplate) {\n       *         memoizedTemplate = super.template.cloneNode(true);\n       *         let subContent = document.createElement('div');\n       *         subContent.textContent = 'This came from MySubClass';\n       *         memoizedTemplate.content.appendChild(subContent);\n       *       }\n       *       return memoizedTemplate;\n       *     }\n       *   }\n       *\n       * @return {HTMLTemplateElement|string} Template to be stamped\n       */\n      static get template() {\n        if (!this.hasOwnProperty(JSCompiler_renameProperty('_template', this))) {\n          this._template = Polymer.DomModule.import(this.is, 'template') ||\n          // note: implemented so a subclass can retrieve the super\n          // template; call the super impl this way so that `this` points\n          // to the superclass.\n          Object.getPrototypeOf(this.prototype).constructor.template;\n        }\n        return this._template;\n      }\n\n      /**\n       * Path matching the url from which the element was imported.\n       * This path is used to resolve url's in template style cssText.\n       * The `importPath` property is also set on element instances and can be\n       * used to create bindings relative to the import path.\n       * Defaults to the path matching the url containing a `dom-module` element\n       * matching this element's static `is` property.\n       * Note, this path should contain a trailing `/`.\n       *\n       * @return {string} The import path for this element class\n       */\n      static get importPath() {\n        if (!this.hasOwnProperty(JSCompiler_renameProperty('_importPath', this))) {\n          const module = Polymer.DomModule.import(this.is);\n          this._importPath = module ? module.assetpath : '' || Object.getPrototypeOf(this.prototype).constructor.importPath;\n        }\n        return this._importPath;\n      }\n\n      /**\n       * Overrides the default `Polymer.PropertyAccessors` to ensure class\n       * metaprogramming related to property accessors and effects has\n       * completed (calls `finalize`).\n       *\n       * It also initializes any property defaults provided via `value` in\n       * `properties` metadata.\n       *\n       * @override\n       */\n      _initializeProperties() {\n        Polymer.telemetry.instanceCount++;\n        this.constructor.finalize();\n        const importPath = this.constructor.importPath;\n        // note: finalize template when we have access to `localName` to\n        // avoid dependence on `is` for polyfilling styling.\n        if (this._template && !this._template.__polymerFinalized) {\n          this._template.__polymerFinalized = true;\n          const baseURI = importPath ? Polymer.ResolveUrl.resolveUrl(importPath) : '';\n          finalizeTemplate(this.__proto__, this._template, baseURI, this.localName);\n        }\n        super._initializeProperties();\n        // set path defaults\n        this.rootPath = Polymer.rootPath;\n        this.importPath = importPath;\n        // apply property defaults...\n        let p$ = propertyDefaultsForClass(this.constructor);\n        if (!p$) {\n          return;\n        }\n        for (let p in p$) {\n          let info = p$[p];\n          // Don't set default value if there is already an own property, which\n          // happens when a `properties` property with default but no effects had\n          // a property set (e.g. bound) by its host before upgrade\n          if (!this.hasOwnProperty(p)) {\n            let value = typeof info.value == 'function' ? info.value.call(this) : info.value;\n            // Set via `_setProperty` if there is an accessor, to enable\n            // initializing readOnly property defaults\n            if (this._hasAccessor(p)) {\n              this._setPendingProperty(p, value, true);\n            } else {\n              this[p] = value;\n            }\n          }\n        }\n      }\n\n      /**\n       * Provides a default implementation of the standard Custom Elements\n       * `connectedCallback`.\n       *\n       * The default implementation enables the property effects system and\n       * flushes any pending properties, and updates shimmed CSS properties\n       * when using the ShadyCSS scoping/custom properties polyfill.\n       *\n       * @override\n       */\n      connectedCallback() {\n        if (window.ShadyCSS && this._template) {\n          window.ShadyCSS.styleElement(this);\n        }\n        this._enableProperties();\n      }\n\n      /**\n       * Provides a default implementation of the standard Custom Elements\n       * `disconnectedCallback`.\n       *\n       * @override\n       */\n      disconnectedCallback() {}\n\n      /**\n       * Stamps the element template.\n       *\n       * @override\n       */\n      ready() {\n        if (this._template) {\n          this.root = this._stampTemplate(this._template);\n          this.$ = this.root.$;\n        }\n        super.ready();\n      }\n\n      /**\n       * Implements `PropertyEffects`'s `_readyClients` call. Attaches\n       * element dom by calling `_attachDom` with the dom stamped from the\n       * element's template via `_stampTemplate`. Note that this allows\n       * client dom to be attached to the element prior to any observers\n       * running.\n       *\n       * @override\n       */\n      _readyClients() {\n        if (this._template) {\n          this.root = this._attachDom(this.root);\n        }\n        // The super._readyClients here sets the clients initialized flag.\n        // We must wait to do this until after client dom is created/attached\n        // so that this flag can be checked to prevent notifications fired\n        // during this process from being handled before clients are ready.\n        super._readyClients();\n      }\n\n      /**\n       * Attaches an element's stamped dom to itself. By default,\n       * this method creates a `shadowRoot` and adds the dom to it.\n       * However, this method may be overridden to allow an element\n       * to put its dom in another location.\n       *\n       * @throws {Error}\n       * @suppress {missingReturn}\n       * @param {NodeList} dom to attach to the element.\n       * @return {Node} node to which the dom has been attached.\n       */\n      _attachDom(dom) {\n        if (this.attachShadow) {\n          if (dom) {\n            if (!this.shadowRoot) {\n              this.attachShadow({ mode: 'open' });\n            }\n            this.shadowRoot.appendChild(dom);\n            return this.shadowRoot;\n          }\n        } else {\n          throw new Error('ShadowDOM not available. ' +\n          // TODO(sorvell): move to compile-time conditional when supported\n          'Polymer.Element can create dom as children instead of in ' + 'ShadowDOM by setting `this.root = this;\\` before \\`ready\\`.');\n        }\n      }\n\n      /**\n       * Provides a default implementation of the standard Custom Elements\n       * `attributeChangedCallback`.\n       *\n       * By default, attributes declared in `properties` metadata are\n       * deserialized using their `type` information to properties of the\n       * same name.  \"Dash-cased\" attributes are deserialzed to \"camelCase\"\n       * properties.\n       *\n       * @override\n       */\n      attributeChangedCallback(name, old, value) {\n        if (old !== value) {\n          let property = caseMap.dashToCamelCase(name);\n          let type = propertiesForClass(this.constructor)[property].type;\n          if (!this._hasReadOnlyEffect(property)) {\n            this._attributeToProperty(name, value, type);\n          }\n        }\n      }\n\n      /**\n       * When using the ShadyCSS scoping and custom property shim, causes all\n       * shimmed styles in this element (and its subtree) to be updated\n       * based on current custom property values.\n       *\n       * The optional parameter overrides inline custom property styles with an\n       * object of properties where the keys are CSS properties, and the values\n       * are strings.\n       *\n       * Example: `this.updateStyles({'--color': 'blue'})`\n       *\n       * These properties are retained unless a value of `null` is set.\n       *\n       * @param {Object=} properties Bag of custom property key/values to\n       *   apply to this element.\n       */\n      updateStyles(properties) {\n        if (window.ShadyCSS) {\n          window.ShadyCSS.styleSubtree(this, properties);\n        }\n      }\n\n      /**\n       * Rewrites a given URL relative to a base URL. The base URL defaults to\n       * the original location of the document containing the `dom-module` for\n       * this element. This method will return the same URL before and after\n       * bundling.\n       *\n       * @param {string} url URL to resolve.\n       * @param {string=} base Optional base URL to resolve against, defaults\n       * to the element's `importPath`\n       * @return {string} Rewritten URL relative to base\n       */\n      resolveUrl(url, base) {\n        if (!base && this.importPath) {\n          base = Polymer.ResolveUrl.resolveUrl(this.importPath);\n        }\n        return Polymer.ResolveUrl.resolveUrl(url, base);\n      }\n\n      /**\n       * Overrides `PropertyAccessors` to add map of dynamic functions on\n       * template info, for consumption by `PropertyEffects` template binding\n       * code. This map determines which method templates should have accessors\n       * created for them.\n       *\n       * @override\n       */\n      static _parseTemplateContent(template, templateInfo, nodeInfo) {\n        templateInfo.dynamicFns = templateInfo.dynamicFns || propertiesForClass(this);\n        return super._parseTemplateContent(template, templateInfo, nodeInfo);\n      }\n\n    }\n\n    return PolymerElement;\n  });\n\n  /**\n   * Provides basic tracking of element definitions (registrations) and\n   * instance counts.\n   *\n   * @namespace\n   * @summary Provides basic tracking of element definitions (registrations) and\n   * instance counts.\n   */\n  Polymer.telemetry = {\n    /**\n     * Total number of Polymer element instances created.\n     * @type {number}\n     */\n    instanceCount: 0,\n    /**\n     * Array of Polymer element classes that have been finalized.\n     * @type {Array<Polymer.Element>}\n     */\n    registrations: [],\n    /**\n     * @param {HTMLElement} prototype Element prototype to log\n     * @private\n     */\n    _regLog: function (prototype) {\n      console.log('[' + prototype.is + ']: registered');\n    },\n    /**\n     * Registers a class prototype for telemetry purposes.\n     * @param {HTMLElement} prototype Element prototype to register\n     * @protected\n     */\n    register: function (prototype) {\n      this.registrations.push(prototype);\n      Polymer.log && this._regLog(prototype);\n    },\n    /**\n     * Logs all elements registered with an `is` to the console.\n     * @public\n     */\n    dumpRegistrations: function () {\n      this.registrations.forEach(this._regLog);\n    }\n  };\n\n  /**\n   * When using the ShadyCSS scoping and custom property shim, causes all\n   * shimmed `styles` (via `custom-style`) in the document (and its subtree)\n   * to be updated based on current custom property values.\n   *\n   * The optional parameter overrides inline custom property styles with an\n   * object of properties where the keys are CSS properties, and the values\n   * are strings.\n   *\n   * Example: `Polymer.updateStyles({'--color': 'blue'})`\n   *\n   * These properties are retained unless a value of `null` is set.\n   *\n   * @param {Object=} props Bag of custom property key/values to\n   *   apply to the document.\n   */\n  Polymer.updateStyles = function (props) {\n    if (window.ShadyCSS) {\n      window.ShadyCSS.styleDocument(props);\n    }\n  };\n\n  /**\n   * Globally settable property that is automatically assigned to\n   * `Polymer.ElementMixin` instances, useful for binding in templates to\n   * make URL's relative to an application's root.  Defaults to the main\n   * document URL, but can be overridden by users.  It may be useful to set\n   * `Polymer.rootPath` to provide a stable application mount path when\n   * using client side routing.\n   *\n   * @memberof Polymer\n   */\n  Polymer.rootPath = Polymer.rootPath || Polymer.ResolveUrl.pathFromUrl(document.baseURI || window.location.href);\n})();\n\n/***/ }),\n/* 38 */\n/***/ (function(module, exports, __webpack_require__) {\n\n/*__wc__loader*/\n__webpack_require__(0);\n\n__webpack_require__(1);\n\n__webpack_require__(2);\n\n__webpack_require__(13);\n\n(function () {\n\n  'use strict';\n\n  let caseMap = Polymer.CaseMap;\n\n  let microtask = Polymer.Async.microTask;\n\n  // Save map of native properties; this forms a blacklist or properties\n  // that won't have their values \"saved\" by `saveAccessorValue`, since\n  // reading from an HTMLElement accessor from the context of a prototype throws\n  const nativeProperties = {};\n  let proto = HTMLElement.prototype;\n  while (proto) {\n    let props = Object.getOwnPropertyNames(proto);\n    for (let i = 0; i < props.length; i++) {\n      nativeProperties[props[i]] = true;\n    }\n    proto = Object.getPrototypeOf(proto);\n  }\n\n  /**\n   * Used to save the value of a property that will be overridden with\n   * an accessor. If the `model` is a prototype, the values will be saved\n   * in `__dataProto`, and it's up to the user (or downstream mixin) to\n   * decide how/when to set these values back into the accessors.\n   * If `model` is already an instance (it has a `__data` property), then\n   * the value will be set as a pending property, meaning the user should\n   * call `_invalidateProperties` or `_flushProperties` to take effect\n   *\n   * @param {Object} model Prototype or instance\n   * @param {string} property Name of property\n   * @private\n   */\n  function saveAccessorValue(model, property) {\n    // Don't read/store value for any native properties since they could throw\n    if (!nativeProperties[property]) {\n      let value = model[property];\n      if (value !== undefined) {\n        if (model.__data) {\n          // Adding accessor to instance; update the property\n          // It is the user's responsibility to call _flushProperties\n          model._setPendingProperty(property, value);\n        } else {\n          // Adding accessor to proto; save proto's value for instance-time use\n          if (!model.__dataProto) {\n            model.__dataProto = {};\n          } else if (!model.hasOwnProperty(JSCompiler_renameProperty('__dataProto', model))) {\n            model.__dataProto = Object.create(model.__dataProto);\n          }\n          model.__dataProto[property] = value;\n        }\n      }\n    }\n  }\n\n  /**\n   * Element class mixin that provides basic meta-programming for creating one\n   * or more property accessors (getter/setter pair) that enqueue an async\n   * (batched) `_propertiesChanged` callback.\n   *\n   * For basic usage of this mixin, simply declare attributes to observe via\n   * the standard `static get observedAttributes()`, implement `_propertiesChanged`\n   * on the class, and then call `MyClass.createPropertiesForAttributes()` once\n   * on the class to generate property accessors for each observed attribute\n   * prior to instancing.  Last, call `this._flushProperties()` once to enable\n   * the accessors.\n   *\n   * Any `observedAttributes` will automatically be\n   * deserialized via `attributeChangedCallback` and set to the associated\n   * property using `dash-case`-to-`camelCase` convention.\n   *\n   * @polymerMixin\n   * @memberof Polymer\n   * @summary Element class mixin for reacting to property changes from\n   *   generated property accessors.\n   */\n  Polymer.PropertyAccessors = Polymer.dedupingMixin(superClass => {\n\n    /**\n     * @polymerMixinClass\n     * @implements {Polymer_PropertyAccessors}\n     * @unrestricted\n     */\n    class PropertyAccessors extends superClass {\n\n      /**\n       * Generates property accessors for all attributes in the standard\n       * static `observedAttributes` array.\n       *\n       * Attribute names are mapped to property names using the `dash-case` to\n       * `camelCase` convention\n       *\n       */\n      static createPropertiesForAttributes() {\n        let a$ = this.observedAttributes;\n        for (let i = 0; i < a$.length; i++) {\n          this.prototype._createPropertyAccessor(caseMap.dashToCamelCase(a$[i]));\n        }\n      }\n\n      constructor() {\n        super();\n        this._initializeProperties();\n      }\n\n      attributeChangedCallback(name, old, value) {\n        if (old !== value) {\n          this._attributeToProperty(name, value);\n        }\n      }\n\n      /**\n       * Initializes the local storage for property accessors.\n       *\n       * Provided as an override point for performing any setup work prior\n       * to initializing the property accessor system.\n       *\n       * @protected\n       */\n      _initializeProperties() {\n        this.__serializing = false;\n        this.__dataCounter = 0;\n        this.__dataEnabled = false;\n        this.__dataReady = false;\n        this.__dataInvalid = false;\n        // initialize data with prototype values saved when creating accessors\n        this.__data = {};\n        this.__dataPending = null;\n        this.__dataOld = null;\n        if (this.__dataProto) {\n          this._initializeProtoProperties(this.__dataProto);\n          this.__dataProto = null;\n        }\n        // Capture instance properties; these will be set into accessors\n        // during first flush. Don't set them here, since we want\n        // these to overwrite defaults/constructor assignments\n        for (let p in this.__dataHasAccessor) {\n          if (this.hasOwnProperty(p)) {\n            this.__dataInstanceProps = this.__dataInstanceProps || {};\n            this.__dataInstanceProps[p] = this[p];\n            delete this[p];\n          }\n        }\n      }\n\n      /**\n       * Called at instance time with bag of properties that were overwritten\n       * by accessors on the prototype when accessors were created.\n       *\n       * The default implementation sets these properties back into the\n       * setter at instance time.  This method is provided as an override\n       * point for customizing or providing more efficient initialization.\n       *\n       * @param {Object} props Bag of property values that were overwritten\n       *   when creating property accessors.\n       * @protected\n       */\n      _initializeProtoProperties(props) {\n        for (let p in props) {\n          this._setProperty(p, props[p]);\n        }\n      }\n\n      /**\n       * Called at ready time with bag of instance properties that overwrote\n       * accessors when the element upgraded.\n       *\n       * The default implementation sets these properties back into the\n       * setter at ready time.  This method is provided as an override\n       * point for customizing or providing more efficient initialization.\n       *\n       * @param {Object} props Bag of property values that were overwritten\n       *   when creating property accessors.\n       * @protected\n       */\n      _initializeInstanceProperties(props) {\n        Object.assign(this, props);\n      }\n\n      /**\n       * Ensures the element has the given attribute. If it does not,\n       * assigns the given value to the attribute.\n       *\n       *\n       * @param {string} attribute Name of attribute to ensure is set.\n       * @param {string} value of the attribute.\n       */\n      _ensureAttribute(attribute, value) {\n        if (!this.hasAttribute(attribute)) {\n          this._valueToNodeAttribute(this, value, attribute);\n        }\n      }\n\n      /**\n       * Deserializes an attribute to its associated property.\n       *\n       * This method calls the `_deserializeValue` method to convert the string to\n       * a typed value.\n       *\n       * @param {string} attribute Name of attribute to deserialize.\n       * @param {string} value of the attribute.\n       * @param {*} type type to deserialize to.\n       */\n      _attributeToProperty(attribute, value, type) {\n        // Don't deserialize back to property if currently reflecting\n        if (!this.__serializing) {\n          let property = caseMap.dashToCamelCase(attribute);\n          this[property] = this._deserializeValue(value, type);\n        }\n      }\n\n      /**\n       * Serializes a property to its associated attribute.\n       *\n       * @param {string} property Property name to reflect.\n       * @param {string=} attribute Attribute name to reflect.\n       * @param {*=} value Property value to refect.\n       */\n      _propertyToAttribute(property, attribute, value) {\n        this.__serializing = true;\n        value = arguments.length < 3 ? this[property] : value;\n        this._valueToNodeAttribute(this, value, attribute || caseMap.camelToDashCase(property));\n        this.__serializing = false;\n      }\n\n      /**\n       * Sets a typed value to an HTML attribute on a node.\n       *\n       * This method calls the `_serializeValue` method to convert the typed\n       * value to a string.  If the `_serializeValue` method returns `undefined`,\n       * the attribute will be removed (this is the default for boolean\n       * type `false`).\n       *\n       * @param {Element} node Element to set attribute to.\n       * @param {*} value Value to serialize.\n       * @param {string} attribute Attribute name to serialize to.\n       */\n      _valueToNodeAttribute(node, value, attribute) {\n        let str = this._serializeValue(value);\n        if (str === undefined) {\n          node.removeAttribute(attribute);\n        } else {\n          node.setAttribute(attribute, str);\n        }\n      }\n\n      /**\n       * Converts a typed JavaScript value to a string.\n       *\n       * This method is called by Polymer when setting JS property values to\n       * HTML attributes.  Users may override this method on Polymer element\n       * prototypes to provide serialization for custom types.\n       *\n       * @param {*} value Property value to serialize.\n       * @return {string | undefined} String serialized from the provided property value.\n       */\n      _serializeValue(value) {\n        /* eslint-disable no-fallthrough */\n        switch (typeof value) {\n          case 'boolean':\n            return value ? '' : undefined;\n\n          case 'object':\n            if (value instanceof Date) {\n              return value.toString();\n            } else if (value) {\n              try {\n                return JSON.stringify(value);\n              } catch (x) {\n                return '';\n              }\n            }\n\n          default:\n            return value != null ? value.toString() : undefined;\n        }\n      }\n\n      /**\n       * Converts a string to a typed JavaScript value.\n       *\n       * This method is called by Polymer when reading HTML attribute values to\n       * JS properties.  Users may override this method on Polymer element\n       * prototypes to provide deserialization for custom `type`s.  Note,\n       * the `type` argument is the value of the `type` field provided in the\n       * `properties` configuration object for a given property, and is\n       * by convention the constructor for the type to deserialize.\n       *\n       * Note: The return value of `undefined` is used as a sentinel value to\n       * indicate the attribute should be removed.\n       *\n       * @param {string} value Attribute value to deserialize.\n       * @param {*} type Type to deserialize the string to.\n       * @return {*} Typed value deserialized from the provided string.\n       */\n      _deserializeValue(value, type) {\n        /**\n         * @type {*}\n         */\n        let outValue;\n        switch (type) {\n          case Number:\n            outValue = Number(value);\n            break;\n\n          case Boolean:\n            outValue = value !== null;\n            break;\n\n          case Object:\n            try {\n              outValue = JSON.parse(value);\n            } catch (x) {\n              // allow non-JSON literals like Strings and Numbers\n            }\n            break;\n\n          case Array:\n            try {\n              outValue = JSON.parse(value);\n            } catch (x) {\n              outValue = null;\n              console.warn(`Polymer::Attributes: couldn't decode Array as JSON: ${value}`);\n            }\n            break;\n\n          case Date:\n            outValue = new Date(value);\n            break;\n\n          case String:\n          default:\n            outValue = value;\n            break;\n        }\n\n        return outValue;\n      }\n      /* eslint-enable no-fallthrough */\n\n      /**\n       * Creates a setter/getter pair for the named property with its own\n       * local storage.  The getter returns the value in the local storage,\n       * and the setter calls `_setProperty`, which updates the local storage\n       * for the property and enqueues a `_propertiesChanged` callback.\n       *\n       * This method may be called on a prototype or an instance.  Calling\n       * this method may overwrite a property value that already exists on\n       * the prototype/instance by creating the accessor.  When calling on\n       * a prototype, any overwritten values are saved in `__dataProto`,\n       * and it is up to the subclasser to decide how/when to set those\n       * properties back into the accessor.  When calling on an instance,\n       * the overwritten value is set via `_setPendingProperty`, and the\n       * user should call `_invalidateProperties` or `_flushProperties`\n       * for the values to take effect.\n       *\n       * @param {string} property Name of the property\n       * @param {boolean=} readOnly When true, no setter is created; the\n       *   protected `_setProperty` function must be used to set the property\n       * @protected\n       */\n      _createPropertyAccessor(property, readOnly) {\n        if (!this.hasOwnProperty('__dataHasAccessor')) {\n          this.__dataHasAccessor = Object.assign({}, this.__dataHasAccessor);\n        }\n        if (!this.__dataHasAccessor[property]) {\n          this.__dataHasAccessor[property] = true;\n          saveAccessorValue(this, property);\n          Object.defineProperty(this, property, {\n            get: function () {\n              return this.__data[property];\n            },\n            set: readOnly ? function () {} : function (value) {\n              this._setProperty(property, value);\n            }\n          });\n        }\n      }\n\n      /**\n       * Returns true if this library created an accessor for the given property.\n       *\n       * @param {string} property Property name\n       * @return {boolean} True if an accessor was created\n       */\n      _hasAccessor(property) {\n        return this.__dataHasAccessor && this.__dataHasAccessor[property];\n      }\n\n      /**\n       * Updates the local storage for a property (via `_setPendingProperty`)\n       * and enqueues a `_proeprtiesChanged` callback.\n       *\n       * @param {string} property Name of the property\n       * @param {*} value Value to set\n       * @protected\n       */\n      _setProperty(property, value) {\n        if (this._setPendingProperty(property, value)) {\n          this._invalidateProperties();\n        }\n      }\n\n      /**\n       * Updates the local storage for a property, records the previous value,\n       * and adds it to the set of \"pending changes\" that will be passed to the\n       * `_propertiesChanged` callback.  This method does not enqueue the\n       * `_propertiesChanged` callback.\n       *\n       * @param {string} property Name of the property\n       * @param {*} value Value to set\n       * @return {boolean} Returns true if the property changed\n       * @protected\n       */\n      _setPendingProperty(property, value) {\n        let old = this.__data[property];\n        if (this._shouldPropertyChange(property, value, old)) {\n          if (!this.__dataPending) {\n            this.__dataPending = {};\n            this.__dataOld = {};\n          }\n          // Ensure old is captured from the last turn\n          if (!(property in this.__dataOld)) {\n            this.__dataOld[property] = old;\n          }\n          this.__data[property] = value;\n          this.__dataPending[property] = value;\n          return true;\n        }\n      }\n\n      /**\n       * Returns true if the specified property has a pending change.\n       *\n       * @param {string} prop Property name\n       * @return {boolean} True if property has a pending change\n       * @protected\n       */\n      _isPropertyPending(prop) {\n        return this.__dataPending && prop in this.__dataPending;\n      }\n\n      /**\n       * Marks the properties as invalid, and enqueues an async\n       * `_propertiesChanged` callback.\n       *\n       * @protected\n       */\n      _invalidateProperties() {\n        if (!this.__dataInvalid && this.__dataReady) {\n          this.__dataInvalid = true;\n          microtask.run(() => {\n            if (this.__dataInvalid) {\n              this.__dataInvalid = false;\n              this._flushProperties();\n            }\n          });\n        }\n      }\n\n      /**\n       * Call to enable property accessor processing. Before this method is\n       * called accessor values will be set but side effects are\n       * queued. When called, any pending side effects occur immediately.\n       * For elements, generally `connectedCallback` is a normal spot to do so.\n       * It is safe to call this method multiple times as it only turns on\n       * property accessors once.\n       */\n      _enableProperties() {\n        if (!this.__dataEnabled) {\n          this.__dataEnabled = true;\n          if (this.__dataInstanceProps) {\n            this._initializeInstanceProperties(this.__dataInstanceProps);\n            this.__dataInstanceProps = null;\n          }\n          this.ready();\n        }\n      }\n\n      /**\n       * Calls the `_propertiesChanged` callback with the current set of\n       * pending changes (and old values recorded when pending changes were\n       * set), and resets the pending set of changes. Generally, this method\n       * should not be called in user code.\n       *\n       *\n       * @protected\n       */\n      _flushProperties() {\n        if (this.__dataPending) {\n          let changedProps = this.__dataPending;\n          this.__dataPending = null;\n          this.__dataCounter++;\n          this._propertiesChanged(this.__data, changedProps, this.__dataOld);\n          this.__dataCounter--;\n        }\n      }\n\n      /**\n       * Lifecycle callback called the first time properties are being flushed.\n       * Prior to `ready`, all property sets through accessors are queued and\n       * their effects are flushed after this method returns.\n       *\n       * Users may override this function to implement behavior that is\n       * dependent on the element having its properties initialized, e.g.\n       * from defaults (initialized from `constructor`, `_initializeProperties`),\n       * `attributeChangedCallback`, or values propagated from host e.g. via\n       * bindings.  `super.ready()` must be called to ensure the data system\n       * becomes enabled.\n       *\n       * @public\n       */\n      ready() {\n        this.__dataReady = true;\n        // Run normal flush\n        this._flushProperties();\n      }\n\n      /**\n       * Callback called when any properties with accessors created via\n       * `_createPropertyAccessor` have been set.\n       *\n       * @param {Object} currentProps Bag of all current accessor values\n       * @param {Object} changedProps Bag of properties changed since the last\n       *   call to `_propertiesChanged`\n       * @param {Object} oldProps Bag of previous values for each property\n       *   in `changedProps`\n       * @protected\n       */\n      _propertiesChanged(currentProps, changedProps, oldProps) {} // eslint-disable-line no-unused-vars\n\n\n      /**\n       * Method called to determine whether a property value should be\n       * considered as a change and cause the `_propertiesChanged` callback\n       * to be enqueued.\n       *\n       * The default implementation returns `true` for primitive types if a\n       * strict equality check fails, and returns `true` for all Object/Arrays.\n       * The method always returns false for `NaN`.\n       *\n       * Override this method to e.g. provide stricter checking for\n       * Objects/Arrays when using immutable patterns.\n       *\n       * @param {string} property Property name\n       * @param {*} value New property value\n       * @param {*} old Previous property value\n       * @return {boolean} Whether the property should be considered a change\n       *   and enqueue a `_proeprtiesChanged` callback\n       * @protected\n       */\n      _shouldPropertyChange(property, value, old) {\n        return (\n          // Strict equality check\n          old !== value && (\n          // This ensures (old==NaN, value==NaN) always returns false\n          old === old || value === value)\n        );\n      }\n\n    }\n\n    return PropertyAccessors;\n  });\n})();\n\n/***/ }),\n/* 39 */\n/***/ (function(module, exports, __webpack_require__) {\n\n/*__wc__loader*/\n__webpack_require__(0);\n\n__webpack_require__(1);\n\n(function () {\n\n  'use strict';\n\n  // 1.x backwards-compatible auto-wrapper for template type extensions\n  // This is a clear layering violation and gives favored-nation status to\n  // dom-if and dom-repeat templates.  This is a conceit we're choosing to keep\n  // a.) to ease 1.x backwards-compatibility due to loss of `is`, and\n  // b.) to maintain if/repeat capability in parser-constrained elements\n  //     (e.g. table, select) in lieu of native CE type extensions without\n  //     massive new invention in this space (e.g. directive system)\n\n  const templateExtensions = {\n    'dom-if': true,\n    'dom-repeat': true\n  };\n  function wrapTemplateExtension(node) {\n    let is = node.getAttribute('is');\n    if (is && templateExtensions[is]) {\n      let t = node;\n      t.removeAttribute('is');\n      node = t.ownerDocument.createElement(is);\n      t.parentNode.replaceChild(node, t);\n      node.appendChild(t);\n      while (t.attributes.length) {\n        node.setAttribute(t.attributes[0].name, t.attributes[0].value);\n        t.removeAttribute(t.attributes[0].name);\n      }\n    }\n    return node;\n  }\n\n  function findTemplateNode(root, nodeInfo) {\n    // recursively ascend tree until we hit root\n    let parent = nodeInfo.parentInfo && findTemplateNode(root, nodeInfo.parentInfo);\n    // unwind the stack, returning the indexed node at each level\n    if (parent) {\n      // note: marginally faster than indexing via childNodes\n      // (http://jsperf.com/childnodes-lookup)\n      for (let n = parent.firstChild, i = 0; n; n = n.nextSibling) {\n        if (nodeInfo.parentIndex === i++) {\n          return n;\n        }\n      }\n    } else {\n      return root;\n    }\n  }\n\n  // construct `$` map (from id annotations)\n  function applyIdToMap(inst, map, node, nodeInfo) {\n    if (nodeInfo.id) {\n      map[nodeInfo.id] = node;\n    }\n  }\n\n  // install event listeners (from event annotations)\n  function applyEventListener(inst, node, nodeInfo) {\n    if (nodeInfo.events && nodeInfo.events.length) {\n      for (let j = 0, e$ = nodeInfo.events, e; j < e$.length && (e = e$[j]); j++) {\n        inst._addMethodEventListenerToNode(node, e.name, e.value, inst);\n      }\n    }\n  }\n\n  // push configuration references at configure time\n  function applyTemplateContent(inst, node, nodeInfo) {\n    if (nodeInfo.templateInfo) {\n      node._templateInfo = nodeInfo.templateInfo;\n    }\n  }\n\n  function createNodeEventHandler(context, eventName, methodName) {\n    // Instances can optionally have a _methodHost which allows redirecting where\n    // to find methods. Currently used by `templatize`.\n    context = context._methodHost || context;\n    let handler = function (e) {\n      if (context[methodName]) {\n        context[methodName](e, e.detail);\n      } else {\n        console.warn('listener method `' + methodName + '` not defined');\n      }\n    };\n    return handler;\n  }\n\n  /**\n   * Element mixin that provides basic template parsing and stamping, including\n   * the following template-related features for stamped templates:\n   *\n   * - Declarative event listeners (`on-eventname=\"listener\"`)\n   * - Map of node id's to stamped node instances (`this.$.id`)\n   * - Nested template content caching/removal and re-installation (performance\n   *   optimization)\n   *\n   * @polymerMixin\n   * @memberof Polymer\n   * @summary Element class mixin that provides basic template parsing and stamping\n   */\n  Polymer.TemplateStamp = Polymer.dedupingMixin(superClass => {\n\n    /**\n     * @polymerMixinClass\n     * @implements {Polymer_TemplateStamp}\n     */\n    class TemplateStamp extends superClass {\n\n      /**\n       * Scans a template to produce template metadata.\n       *\n       * Template-specific metadata are stored in the object returned, and node-\n       * specific metadata are stored in objects in its flattened `nodeInfoList`\n       * array.  Only nodes in the template that were parsed as nodes of\n       * interest contain an object in `nodeInfoList`.  Each `nodeInfo` object\n       * contains an `index` (`childNodes` index in parent) and optionally\n       * `parent`, which points to node info of its parent (including its index).\n       *\n       * The template metadata object returned from this method has the following\n       * structure (many fields optional):\n       *\n       * ```js\n       *   {\n       *     // Flattened list of node metadata (for nodes that generated metadata)\n       *     nodeInfoList: [\n       *       {\n       *         // `id` attribute for any nodes with id's for generating `$` map\n       *         id: {string},\n       *         // `on-event=\"handler\"` metadata\n       *         events: [\n       *           {\n       *             name: {string},   // event name\n       *             value: {string},  // handler method name\n       *           }, ...\n       *         ],\n       *         // Notes when the template contained a `<slot>` for shady DOM\n       *         // optimization purposes\n       *         hasInsertionPoint: {boolean},\n       *         // For nested `<template>`` nodes, nested template metadata\n       *         templateInfo: {object}, // nested template metadata\n       *         // Metadata to allow efficient retrieval of instanced node\n       *         // corresponding to this metadata\n       *         parentInfo: {number},   // reference to parent nodeInfo>\n       *         parentIndex: {number},  // index in parent's `childNodes` collection\n       *         infoIndex: {number},    // index of this `nodeInfo` in `templateInfo.nodeInfoList`\n       *       },\n       *       ...\n       *     ],\n       *     // When true, the template had the `strip-whitespace` attribute\n       *     // or was nested in a template with that setting\n       *     stripWhitespace: {boolean},\n       *     // For nested templates, nested template content is moved into\n       *     // a document fragment stored here; this is an optimization to\n       *     // avoid the cost of nested template cloning\n       *     content: {DocumentFragment}\n       *   }\n       * ```\n       *\n       * This method kicks off a recursive treewalk as follows:\n       *\n       * ```\n       *    _parseTemplate <---------------------+\n       *      _parseTemplateContent              |\n       *        _parseTemplateNode  <------------|--+\n       *          _parseTemplateNestedTemplate --+  |\n       *          _parseTemplateChildNodes ---------+\n       *          _parseTemplateNodeAttributes\n       *            _parseTemplateNodeAttribute\n       *\n       * ```\n       *\n       * These methods may be overridden to add custom metadata about templates\n       * to either `templateInfo` or `nodeInfo`.\n       *\n       * Note that this method may be destructive to the template, in that\n       * e.g. event annotations may be removed after being noted in the\n       * template metadata.\n       *\n       * @param {HTMLTemplateElement} template Template to parse\n       * @param {Object=} outerTemplateInfo Template metadata from the outer\n       *   template, for parsing nested templates\n       * @return {Object} Parsed template metadata\n       */\n      static _parseTemplate(template, outerTemplateInfo) {\n        // since a template may be re-used, memo-ize metadata\n        if (!template._templateInfo) {\n          let templateInfo = template._templateInfo = {};\n          templateInfo.nodeInfoList = [];\n          templateInfo.stripWhiteSpace = outerTemplateInfo && outerTemplateInfo.stripWhiteSpace || template.hasAttribute('strip-whitespace');\n          this._parseTemplateContent(template, templateInfo, { parent: null });\n        }\n        return template._templateInfo;\n      }\n\n      static _parseTemplateContent(template, templateInfo, nodeInfo) {\n        return this._parseTemplateNode(template.content, templateInfo, nodeInfo);\n      }\n\n      /**\n       * Parses template node and adds template and node metadata based on\n       * the current node, and its `childNodes` and `attributes`.\n       *\n       * This method may be overridden to add custom node or template specific\n       * metadata based on this node.\n       *\n       * @param {Node} node Node to parse\n       * @param {Object} templateInfo Template metadata for current template\n       * @param {Object} nodeInfo Node metadata for current template.\n       * @return {boolean} `true` if the visited node added node-specific\n       *   metadata to `nodeInfo`\n       */\n      static _parseTemplateNode(node, templateInfo, nodeInfo) {\n        let noted;\n        if (node.localName == 'template' && !node.hasAttribute('preserve-content')) {\n          noted = this._parseTemplateNestedTemplate(node, templateInfo, nodeInfo) || noted;\n        } else if (node.localName === 'slot') {\n          // For ShadyDom optimization, indicating there is an insertion point\n          templateInfo.hasInsertionPoint = true;\n        }\n        if (node.firstChild) {\n          noted = this._parseTemplateChildNodes(node, templateInfo, nodeInfo) || noted;\n        }\n        if (node.hasAttributes && node.hasAttributes()) {\n          noted = this._parseTemplateNodeAttributes(node, templateInfo, nodeInfo) || noted;\n        }\n        return noted;\n      }\n\n      /**\n       * Parses template child nodes for the given root node.\n       *\n       * This method also wraps whitelisted legacy template extensions\n       * (`is=\"dom-if\"` and `is=\"dom-repeat\"`) with their equivalent element\n       * wrappers, collapses text nodes, and strips whitespace from the template\n       * if the `templateInfo.stripWhitespace` setting was provided.\n       *\n       * @param {Node} root Root node whose `childNodes` will be parsed\n       * @param {Object} templateInfo Template metadata for current template\n       * @param {Object} nodeInfo Node metadata for current template.\n       */\n      static _parseTemplateChildNodes(root, templateInfo, nodeInfo) {\n        for (let node = root.firstChild, parentIndex = 0, next; node; node = next) {\n          // Wrap templates\n          if (node.localName == 'template') {\n            node = wrapTemplateExtension(node);\n          }\n          // collapse adjacent textNodes: fixes an IE issue that can cause\n          // text nodes to be inexplicably split =(\n          // note that root.normalize() should work but does not so we do this\n          // manually.\n          next = node.nextSibling;\n          if (node.nodeType === Node.TEXT_NODE) {\n            let n = next;\n            while (n && n.nodeType === Node.TEXT_NODE) {\n              node.textContent += n.textContent;\n              next = n.nextSibling;\n              root.removeChild(n);\n              n = next;\n            }\n            // optionally strip whitespace\n            if (templateInfo.stripWhiteSpace && !node.textContent.trim()) {\n              root.removeChild(node);\n              continue;\n            }\n          }\n          let childInfo = { parentIndex, parentInfo: nodeInfo };\n          if (this._parseTemplateNode(node, templateInfo, childInfo)) {\n            childInfo.infoIndex = templateInfo.nodeInfoList.push(childInfo) - 1;\n          }\n          // Increment if not removed\n          if (node.parentNode) {\n            parentIndex++;\n          }\n        }\n      }\n\n      /**\n       * Parses template content for the given nested `<template>`.\n       *\n       * Nested template info is stored as `templateInfo` in the current node's\n       * `nodeInfo`. `template.content` is removed and stored in `templateInfo`.\n       * It will then be the responsibility of the host to set it back to the\n       * template and for users stamping nested templates to use the\n       * `_contentForTemplate` method to retrieve the content for this template\n       * (an optimization to avoid the cost of cloning nested template content).\n       *\n       * @param {HTMLTemplateElement} node Node to parse (a <template>)\n       * @param {Object} outerTemplateInfo Template metadata for current template\n       *   that includes the template `node`\n       * @param {Object} nodeInfo Node metadata for current template.\n       * @return {boolean} `true` if the visited node added node-specific\n       *   metadata to `nodeInfo`\n       */\n      static _parseTemplateNestedTemplate(node, outerTemplateInfo, nodeInfo) {\n        let templateInfo = this._parseTemplate(node, outerTemplateInfo);\n        let content = templateInfo.content = node.content.ownerDocument.createDocumentFragment();\n        content.appendChild(node.content);\n        nodeInfo.templateInfo = templateInfo;\n        return true;\n      }\n\n      /**\n       * Parses template node attributes and adds node metadata to `nodeInfo`\n       * for nodes of interest.\n       *\n       * @param {Node} node Node to parse\n       * @param {Object} templateInfo Template metadata for current template\n       * @param {Object} nodeInfo Node metadata for current template.\n       * @return {boolean} `true` if the visited node added node-specific\n       *   metadata to `nodeInfo`\n       */\n      static _parseTemplateNodeAttributes(node, templateInfo, nodeInfo) {\n        // Make copy of original attribute list, since the order may change\n        // as attributes are added and removed\n        let noted;\n        let attrs = Array.from(node.attributes);\n        for (let i = attrs.length - 1, a; a = attrs[i]; i--) {\n          noted = this._parseTemplateNodeAttribute(node, templateInfo, nodeInfo, a.name, a.value) || noted;\n        }\n        return noted;\n      }\n\n      /**\n       * Parses a single template node attribute and adds node metadata to\n       * `nodeInfo` for attributes of interest.\n       *\n       * This implementation adds metadata for `on-event=\"handler\"` attributes\n       * and `id` attributes.\n       *\n       * @param {Node} node Node to parse\n       * @param {Object} templateInfo Template metadata for current template\n       * @param {Object} nodeInfo Node metadata for current template.\n       * @param {string} name Attribute name\n       * @param {*} value Attribute value\n       * @return {boolean} `true` if the visited node added node-specific\n       *   metadata to `nodeInfo`\n       */\n      static _parseTemplateNodeAttribute(node, templateInfo, nodeInfo, name, value) {\n        // events (on-*)\n        if (name.slice(0, 3) === 'on-') {\n          node.removeAttribute(name);\n          nodeInfo.events = nodeInfo.events || [];\n          nodeInfo.events.push({\n            name: name.slice(3),\n            value\n          });\n          return true;\n        }\n        // static id\n        else if (name === 'id') {\n            nodeInfo.id = value;\n            return true;\n          }\n      }\n\n      /**\n       * Returns the `content` document fragment for a given template.\n       *\n       * For nested templates, Polymer performs an optimization to cache nested\n       * template content to avoid the cost of cloning deeply nested templates.\n       * This method retrieves the cached content for a given template.\n       *\n       * @param {HTMLTemplateElement} template Template to retrieve `content` for\n       * @return {DocumentFragment} Content fragment\n       */\n      static _contentForTemplate(template) {\n        let templateInfo = template.__templateInfo;\n        return templateInfo && templateInfo.content || template.content;\n      }\n\n      /**\n       * Clones the provided template content and returns a document fragment\n       * containing the cloned dom.\n       *\n       * The template is parsed (once and memoized) using this library's\n       * template parsing features, and provides the following value-added\n       * features:\n       * * Adds declarative event listeners for `on-event=\"handler\"` attributes\n       * * Generates an \"id map\" for all nodes with id's under `$` on returned\n       *   document fragment\n       * * Passes template info including `content` back to templates as\n       *   `_templateInfo` (a performance optimization to avoid deep template\n       *   cloning)\n       *\n       * Note that the memoized template parsing process is destructive to the\n       * template: attributes for bindings and declarative event listeners are\n       * removed after being noted in notes, and any nested `<template>.content`\n       * is removed and stored in notes as well.\n       *\n       * @param {HTMLTemplateElement} template Template to stamp\n       * @return {DocumentFragment} Cloned template content\n       */\n      _stampTemplate(template) {\n        // Polyfill support: bootstrap the template if it has not already been\n        if (template && !template.content && window.HTMLTemplateElement && HTMLTemplateElement.decorate) {\n          HTMLTemplateElement.decorate(template);\n        }\n        let templateInfo = this.constructor._parseTemplate(template);\n        let nodeInfo = templateInfo.nodeInfoList;\n        let content = templateInfo.content || template.content;\n        let dom = document.importNode(content, true);\n        // NOTE: ShadyDom optimization indicating there is an insertion point\n        dom.__noInsertionPoint = !templateInfo.hasInsertionPoint;\n        let nodes = dom.nodeList = new Array(nodeInfo.length);\n        dom.$ = {};\n        for (let i = 0, l = nodeInfo.length, info; i < l && (info = nodeInfo[i]); i++) {\n          let node = nodes[i] = findTemplateNode(dom, info);\n          applyIdToMap(this, dom.$, node, info);\n          applyTemplateContent(this, node, info);\n          applyEventListener(this, node, info);\n        }\n        return dom;\n      }\n\n      /**\n       * Adds an event listener by method name for the event provided.\n       *\n       * This method generates a handler function that looks up the method\n       * name at handling time.\n       *\n       * @param {Node} node Node to add listener on\n       * @param {string} eventName Name of event\n       * @param {string} methodName Name of method\n       * @param {*=} context Context the method will be called on (defaults\n       *   to `node`)\n       * @return {Function} Generated handler function\n       */\n      _addMethodEventListenerToNode(node, eventName, methodName, context) {\n        context = context || node;\n        let handler = createNodeEventHandler(context, eventName, methodName);\n        this._addEventListenerToNode(node, eventName, handler);\n        return handler;\n      }\n\n      /**\n       * Override point for adding custom or simulated event handling.\n       *\n       * @param {Node} node Node to add event listener to\n       * @param {string} eventName Name of event\n       * @param {Function} handler Listener function to add\n       */\n      _addEventListenerToNode(node, eventName, handler) {\n        node.addEventListener(eventName, handler);\n      }\n\n      /**\n       * Override point for adding custom or simulated event handling.\n       *\n       * @param {Node} node Node to remove event listener from\n       * @param {string} eventName Name of event\n       * @param {Function} handler Listener function to remove\n       */\n      _removeEventListenerFromNode(node, eventName, handler) {\n        node.removeEventListener(eventName, handler);\n      }\n\n    }\n\n    return TemplateStamp;\n  });\n})();\n\n/***/ }),\n/* 40 */\n/***/ (function(module, exports, __webpack_require__) {\n\n/*__wc__loader*/\n__webpack_require__(0);\n\n__webpack_require__(1);\n\n__webpack_require__(13);\n\n(function () {\n  'use strict';\n\n  /** @typedef {{run: function(function(), number=):number, cancel: function(number)}} */\n\n  let AsyncModule; // eslint-disable-line no-unused-vars\n\n  class Debouncer {\n    constructor() {\n      this._asyncModule = null;\n      this._callback = null;\n      this._timer = null;\n    }\n    /**\n     * Sets the scheduler; that is, a module with the Async interface,\n     * a callback and optional arguments to be passed to the run function\n     * from the async module.\n     *\n     * @param {!AsyncModule} asyncModule Object with Async interface.\n     * @param {function()} callback Callback to run.\n     */\n    setConfig(asyncModule, callback) {\n      this._asyncModule = asyncModule;\n      this._callback = callback;\n      this._timer = this._asyncModule.run(() => {\n        this._timer = null;\n        this._callback();\n      });\n    }\n    /**\n     * Cancels an active debouncer and returns a reference to itself.\n     */\n    cancel() {\n      if (this.isActive()) {\n        this._asyncModule.cancel(this._timer);\n        this._timer = null;\n      }\n    }\n    /**\n     * Flushes an active debouncer and returns a reference to itself.\n     */\n    flush() {\n      if (this.isActive()) {\n        this.cancel();\n        this._callback();\n      }\n    }\n    /**\n     * Returns true if the debouncer is active.\n     *\n     * @return {boolean} True if active.\n     */\n    isActive() {\n      return this._timer != null;\n    }\n    /**\n     * Creates a debouncer if no debouncer is passed as a parameter\n     * or it cancels an active debouncer otherwise. The following\n     * example shows how a debouncer can be called multiple times within a\n     * microtask and \"debounced\" such that the provided callback function is\n     * called once. Add this method to a custom element:\n     *\n     * _debounceWork() {\n     *   this._debounceJob = Polymer.Debouncer.debounce(this._debounceJob,\n     *       Polymer.Async.microTask, () => {\n     *     this._doWork();\n     *   });\n     * }\n     *\n     * If the `_debounceWork` method is called multiple times within the same\n     * microtask, the `_doWork` function will be called only once at the next\n     * microtask checkpoint.\n     *\n     * Note: In testing it is often convenient to avoid asynchrony. To accomplish\n     * this with a debouncer, you can use `Polymer.enqueueDebouncer` and\n     * `Polymer.flush`. For example, extend the above example by adding\n     * `Polymer.enqueueDebouncer(this._debounceJob)` at the end of the\n     * `_debounceWork` method. Then in a test, call `Polymer.flush` to ensure\n     * the debouncer has completed.\n     *\n     * @param {Polymer.Debouncer?} debouncer Debouncer object.\n     * @param {!AsyncModule} asyncModule Object with Async interface\n     * @param {function()} callback Callback to run.\n     * @return {!Debouncer} Returns a debouncer object.\n     */\n    static debounce(debouncer, asyncModule, callback) {\n      if (debouncer instanceof Debouncer) {\n        debouncer.cancel();\n      } else {\n        debouncer = new Debouncer();\n      }\n      debouncer.setConfig(asyncModule, callback);\n      return debouncer;\n    }\n  }\n\n  /**\n   * @memberof Polymer\n   */\n  Polymer.Debouncer = Debouncer;\n})();\n\n/***/ }),\n/* 41 */\n/***/ (function(module, exports, __webpack_require__) {\n\n/*__wc__loader*/\n__webpack_require__(0);\n\n(function () {\n  'use strict';\n\n  let debouncerQueue = [];\n\n  /**\n   * Adds a `Polymer.Debouncer` to a list of globally flushable tasks.\n   *\n   * @memberof Polymer\n   * @param {Polymer.Debouncer} debouncer Debouncer to enqueue\n   */\n  Polymer.enqueueDebouncer = function (debouncer) {\n    debouncerQueue.push(debouncer);\n  };\n\n  function flushDebouncers() {\n    const didFlush = Boolean(debouncerQueue.length);\n    while (debouncerQueue.length) {\n      try {\n        debouncerQueue.shift().flush();\n      } catch (e) {\n        setTimeout(() => {\n          throw e;\n        });\n      }\n    }\n    return didFlush;\n  }\n\n  /**\n   * Forces several classes of asynchronously queued tasks to flush:\n   * - Debouncers added via `enqueueDebouncer`\n   * - ShadyDOM distribution\n   *\n   * @memberof Polymer\n   */\n  Polymer.flush = function () {\n    let shadyDOM, debouncers;\n    do {\n      shadyDOM = window.ShadyDOM && ShadyDOM.flush();\n      if (window.ShadyCSS && window.ShadyCSS.ScopingShim) {\n        window.ShadyCSS.ScopingShim.flush();\n      }\n      debouncers = flushDebouncers();\n    } while (shadyDOM || debouncers);\n  };\n})();\n\n/***/ }),\n/* 42 */\n/***/ (function(module, exports, __webpack_require__) {\n\n/*__wc__loader*/\n__webpack_require__(0);\n\n(function () {\n  'use strict';\n\n  /**\n   * Module with utilities for manipulating structured data path strings.\n   *\n   * @namespace\n   * @memberof Polymer\n   * @summary Module with utilities for manipulating structured data path strings.\n   */\n\n  const Path = {\n\n    /**\n     * Returns true if the given string is a structured data path (has dots).\n     *\n     * Example:\n     *\n     * ```\n     * Polymer.Path.isPath('foo.bar.baz') // true\n     * Polymer.Path.isPath('foo')         // false\n     * ```\n     *\n     * @memberof Polymer.Path\n     * @param {string} path Path string\n     * @return {boolean} True if the string contained one or more dots\n     */\n    isPath: function (path) {\n      return path.indexOf('.') >= 0;\n    },\n\n    /**\n     * Returns the root property name for the given path.\n     *\n     * Example:\n     *\n     * ```\n     * Polymer.Path.root('foo.bar.baz') // 'foo'\n     * Polymer.Path.root('foo')         // 'foo'\n     * ```\n     *\n     * @memberof Polymer.Path\n     * @param {string} path Path string\n     * @return {string} Root property name\n     */\n    root: function (path) {\n      let dotIndex = path.indexOf('.');\n      if (dotIndex === -1) {\n        return path;\n      }\n      return path.slice(0, dotIndex);\n    },\n\n    /**\n     * Given `base` is `foo.bar`, `foo` is an ancestor, `foo.bar` is not\n     * Returns true if the given path is an ancestor of the base path.\n     *\n     * Example:\n     *\n     * ```\n     * Polymer.Path.isAncestor('foo.bar', 'foo')         // true\n     * Polymer.Path.isAncestor('foo.bar', 'foo.bar')     // false\n     * Polymer.Path.isAncestor('foo.bar', 'foo.bar.baz') // false\n     * ```\n     *\n     * @memberof Polymer.Path\n     * @param {string} base Path string to test against.\n     * @param {string} path Path string to test.\n     * @return {boolean} True if `path` is an ancestor of `base`.\n     */\n    isAncestor: function (base, path) {\n      //     base.startsWith(path + '.');\n      return base.indexOf(path + '.') === 0;\n    },\n\n    /**\n     * Given `base` is `foo.bar`, `foo.bar.baz` is an descendant\n     *\n     * Example:\n     *\n     * ```\n     * Polymer.Path.isDescendant('foo.bar', 'foo.bar.baz') // true\n     * Polymer.Path.isDescendant('foo.bar', 'foo.bar')     // false\n     * Polymer.Path.isDescendant('foo.bar', 'foo')         // false\n     * ```\n     *\n     * @memberof Polymer.Path\n     * @param {string} base Path string to test against.\n     * @param {string} path Path string to test.\n     * @return {boolean} True if `path` is a descendant of `base`.\n     */\n    isDescendant: function (base, path) {\n      //     path.startsWith(base + '.');\n      return path.indexOf(base + '.') === 0;\n    },\n\n    /**\n     * Replaces a previous base path with a new base path, preserving the\n     * remainder of the path.\n     *\n     * User must ensure `path` has a prefix of `base`.\n     *\n     * Example:\n     *\n     * ```\n     * Polymer.Path.translate('foo.bar', 'zot' 'foo.bar.baz') // 'zot.baz'\n     * ```\n     *\n     * @memberof Polymer.Path\n     * @param {string} base Current base string to remove\n     * @param {string} newBase New base string to replace with\n     * @param {string} path Path to translate\n     * @return {string} Translated string\n     */\n    translate: function (base, newBase, path) {\n      return newBase + path.slice(base.length);\n    },\n\n    matches: function (base, path) {\n      return base === path || this.isAncestor(base, path) || this.isDescendant(base, path);\n    },\n\n    /**\n     * Converts array-based paths to flattened path.  String-based paths\n     * are returned as-is.\n     *\n     * Example:\n     *\n     * ```\n     * Polymer.Path.normalize(['foo.bar', 0, 'baz'])  // 'foo.bar.0.baz'\n     * Polymer.Path.normalize('foo.bar.0.baz')        // 'foo.bar.0.baz'\n     * ```\n     *\n     * @memberof Polymer.Path\n     * @param {string | !Array<string|number>} path Input path\n     * @return {string} Flattened path\n     */\n    normalize: function (path) {\n      if (Array.isArray(path)) {\n        let parts = [];\n        for (let i = 0; i < path.length; i++) {\n          let args = path[i].toString().split('.');\n          for (let j = 0; j < args.length; j++) {\n            parts.push(args[j]);\n          }\n        }\n        return parts.join('.');\n      } else {\n        return path;\n      }\n    },\n\n    /**\n     * Splits a path into an array of property names. Accepts either arrays\n     * of path parts or strings.\n     *\n     * Example:\n     *\n     * ```\n     * Polymer.Path.split(['foo.bar', 0, 'baz'])  // ['foo', 'bar', '0', 'baz']\n     * Polymer.Path.split('foo.bar.0.baz')        // ['foo', 'bar', '0', 'baz']\n     * ```\n     *\n     * @memberof Polymer.Path\n     * @param {string | !Array<string|number>} path Input path\n     * @return {!Array<string>} Array of path parts\n     */\n    split: function (path) {\n      if (Array.isArray(path)) {\n        return this.normalize(path).split('.');\n      }\n      return path.toString().split('.');\n    },\n\n    /**\n     * Reads a value from a path.  If any sub-property in the path is `undefined`,\n     * this method returns `undefined` (will never throw.\n     *\n     * @memberof Polymer.Path\n     * @param {Object} root Object from which to dereference path from\n     * @param {string | !Array<string|number>} path Path to read\n     * @param {Object=} info If an object is provided to `info`, the normalized\n     *  (flattened) path will be set to `info.path`.\n     * @return {*} Value at path, or `undefined` if the path could not be\n     *  fully dereferenced.\n     */\n    get: function (root, path, info) {\n      let prop = root;\n      let parts = this.split(path);\n      // Loop over path parts[0..n-1] and dereference\n      for (let i = 0; i < parts.length; i++) {\n        if (!prop) {\n          return;\n        }\n        let part = parts[i];\n        prop = prop[part];\n      }\n      if (info) {\n        info.path = parts.join('.');\n      }\n      return prop;\n    },\n\n    /**\n     * Sets a value to a path.  If any sub-property in the path is `undefined`,\n     * this method will no-op.\n     *\n     * @memberof Polymer.Path\n     * @param {Object} root Object from which to dereference path from\n     * @param {string | !Array<string|number>} path Path to set\n     * @param {*} value Value to set to path\n     * @return {string | undefined} The normalized version of the input path\n     */\n    set: function (root, path, value) {\n      let prop = root;\n      let parts = this.split(path);\n      let last = parts[parts.length - 1];\n      if (parts.length > 1) {\n        // Loop over path parts[0..n-2] and dereference\n        for (let i = 0; i < parts.length - 1; i++) {\n          let part = parts[i];\n          prop = prop[part];\n          if (!prop) {\n            return;\n          }\n        }\n        // Set value to object at end of path\n        prop[last] = value;\n      } else {\n        // Simple property set\n        prop[path] = value;\n      }\n      return parts.join('.');\n    }\n\n  };\n\n  /**\n   * Returns true if the given string is a structured data path (has dots).\n   *\n   * This function is deprecated.  Use `Polymer.Path.isPath` instead.\n   *\n   * Example:\n   *\n   * ```\n   * Polymer.Path.isDeep('foo.bar.baz') // true\n   * Polymer.Path.isDeep('foo')         // false\n   * ```\n   *\n   * @deprecated\n   * @memberof Polymer.Path\n   * @param {string} path Path string\n   * @return {boolean} True if the string contained one or more dots\n   */\n  Path.isDeep = Path.isPath;\n\n  Polymer.Path = Path;\n})();\n\n/***/ }),\n/* 43 */\n/***/ (function(module, exports, __webpack_require__) {\n\n/*__wc__loader*/\n__webpack_require__(3);\n\n(function () {\n  'use strict';\n\n  const MODULE_STYLE_LINK_SELECTOR = 'link[rel=import][type~=css]';\n  const INCLUDE_ATTR = 'include';\n\n  function importModule(moduleId) {\n    if (!Polymer.DomModule) {\n      return null;\n    }\n    return Polymer.DomModule.import(moduleId);\n  }\n\n  /**\n   * Module with utilities for collection CSS text from `<templates>`, external\n   * stylesheets, and `dom-module`s.\n   *\n   * @namespace\n   * @memberof Polymer\n   * @summary Module with utilities for collection CSS text from various sources.\n   */\n  const StyleGather = {\n\n    /**\n     * Returns CSS text of styles in a space-separated list of `dom-module`s.\n     *\n     * @memberof Polymer.StyleGather\n     * @param {string} moduleIds List of dom-module id's within which to\n     * search for css.\n     * @return {string} Concatenated CSS content from specified `dom-module`s\n     */\n    cssFromModules(moduleIds) {\n      let modules = moduleIds.trim().split(' ');\n      let cssText = '';\n      for (let i = 0; i < modules.length; i++) {\n        cssText += this.cssFromModule(modules[i]);\n      }\n      return cssText;\n    },\n\n    /**\n     * Returns CSS text of styles in a given `dom-module`.  CSS in a `dom-module`\n     * can come either from `<style>`s within the first `<template>`, or else\n     * from one or more `<link rel=\"import\" type=\"css\">` links outside the\n     * template.\n     *\n     * Any `<styles>` processed are removed from their original location.\n     *\n     * @memberof Polymer.StyleGather\n     * @param {string} moduleId dom-module id to gather styles from\n     * @return {string} Concatenated CSS content from specified `dom-module`\n     */\n    cssFromModule(moduleId) {\n      let m = importModule(moduleId);\n      if (m && m._cssText === undefined) {\n        let cssText = '';\n        // include css from the first template in the module\n        let t = m.querySelector('template');\n        if (t) {\n          cssText += this.cssFromTemplate(t, m.assetpath);\n        }\n        // module imports: <link rel=\"import\" type=\"css\">\n        cssText += this.cssFromModuleImports(moduleId);\n        m._cssText = cssText || null;\n      }\n      if (!m) {\n        console.warn('Could not find style data in module named', moduleId);\n      }\n      return m && m._cssText || '';\n    },\n\n    /**\n     * Returns CSS text of `<styles>` within a given template.\n     *\n     * Any `<styles>` processed are removed from their original location.\n     *\n     * @memberof Polymer.StyleGather\n     * @param {HTMLTemplateElement} template Template to gather styles from\n     * @param {string} baseURI Base URI to resolve the URL against\n     * @return {string} Concatenated CSS content from specified template\n     */\n    cssFromTemplate(template, baseURI) {\n      let cssText = '';\n      // if element is a template, get content from its .content\n      let e$ = template.content.querySelectorAll('style');\n      for (let i = 0; i < e$.length; i++) {\n        let e = e$[i];\n        // support style sharing by allowing styles to \"include\"\n        // other dom-modules that contain styling\n        let include = e.getAttribute(INCLUDE_ATTR);\n        if (include) {\n          cssText += this.cssFromModules(include);\n        }\n        e.parentNode.removeChild(e);\n        cssText += baseURI ? Polymer.ResolveUrl.resolveCss(e.textContent, baseURI) : e.textContent;\n      }\n      return cssText;\n    },\n\n    /**\n     * Returns CSS text from stylsheets loaded via `<link rel=\"import\" type=\"css\">`\n     * links within the specified `dom-module`.\n     *\n     * @memberof Polymer.StyleGather\n     * @param {string} moduleId Id of `dom-module` to gather CSS from\n     * @return {string} Concatenated CSS content from links in specified `dom-module`\n     */\n    cssFromModuleImports(moduleId) {\n      let cssText = '';\n      let m = importModule(moduleId);\n      if (!m) {\n        return cssText;\n      }\n      let p$ = m.querySelectorAll(MODULE_STYLE_LINK_SELECTOR);\n      for (let i = 0; i < p$.length; i++) {\n        let p = p$[i];\n        if (p.import) {\n          let importDoc = p.import;\n          // NOTE: polyfill affordance.\n          // under the HTMLImports polyfill, there will be no 'body',\n          // but the import pseudo-doc can be used directly.\n          let container = importDoc.body ? importDoc.body : importDoc;\n          cssText += Polymer.ResolveUrl.resolveCss(container.textContent, importDoc.baseURI);\n        }\n      }\n      return cssText;\n    }\n  };\n\n  Polymer.StyleGather = StyleGather;\n})();\n\n/***/ }),\n/* 44 */\n/***/ (function(module, exports, __webpack_require__) {\n\n/*__wc__loader*/\n__webpack_require__(0);\n\n__webpack_require__(12);\n\n__webpack_require__(11);\n\n(function () {\n  'use strict';\n\n  // Base class for HTMLTemplateElement extension that has property effects\n  // machinery for propagating host properties to children. This is an ES5\n  // class only because Babel (incorrectly) requires super() in the class\n  // constructor even though no `this` is used and it returns an instance.\n\n  let newInstance = null;\n  function HTMLTemplateElementExtension() {\n    return newInstance;\n  }\n  HTMLTemplateElementExtension.prototype = Object.create(HTMLTemplateElement.prototype, {\n    constructor: {\n      value: HTMLTemplateElementExtension,\n      writable: true\n    }\n  });\n  const DataTemplate = Polymer.PropertyEffects(HTMLTemplateElementExtension);\n  const MutableDataTemplate = Polymer.MutableData(DataTemplate);\n\n  // Applies a DataTemplate subclass to a <template> instance\n  function upgradeTemplate(template, constructor) {\n    newInstance = template;\n    Object.setPrototypeOf(template, constructor.prototype);\n    new constructor();\n    newInstance = null;\n  }\n\n  // Base class for TemplateInstance's\n  /**\n   * @constructor\n   * @implements {Polymer_PropertyEffects}\n   */\n  const base = Polymer.PropertyEffects(class {});\n  class TemplateInstanceBase extends base {\n    constructor(props) {\n      super();\n      this._configureProperties(props);\n      this.root = this._stampTemplate(this.__dataHost);\n      // Save list of stamped children\n      let children = this.children = [];\n      for (let n = this.root.firstChild; n; n = n.nextSibling) {\n        children.push(n);\n        n.__templatizeInstance = this;\n      }\n      if (this.__templatizeOwner.__hideTemplateChildren__) {\n        this._showHideChildren(true);\n      }\n      // Flush props only when props are passed if instance props exist\n      // or when there isn't instance props.\n      let options = this.__templatizeOptions;\n      if (props && options.instanceProps || !options.instanceProps) {\n        this._enableProperties();\n      }\n    }\n    /**\n     * Configure the given `props` by calling `_setPendingProperty`. Also\n     * sets any properties stored in `__hostProps`.\n     * @private\n     * @param {Object} props Object of property name-value pairs to set.\n     */\n    _configureProperties(props) {\n      let options = this.__templatizeOptions;\n      if (props) {\n        for (let iprop in options.instanceProps) {\n          if (iprop in props) {\n            this._setPendingProperty(iprop, props[iprop]);\n          }\n        }\n      }\n      for (let hprop in this.__hostProps) {\n        this._setPendingProperty(hprop, this.__dataHost['_host_' + hprop]);\n      }\n    }\n    /**\n     * Forwards a host property to this instance.  This method should be\n     * called on instances from the `options.forwardHostProp` callback\n     * to propagate changes of host properties to each instance.\n     *\n     * Note this method enqueues the change, which are flushed as a batch.\n     *\n     * @param {string} prop Property or path name\n     * @param {*} value Value of the property to forward\n     */\n    forwardHostProp(prop, value) {\n      if (this._setPendingPropertyOrPath(prop, value, false, true)) {\n        this.__dataHost._enqueueClient(this);\n      }\n    }\n    /**\n     * @override\n     */\n    _addEventListenerToNode(node, eventName, handler) {\n      if (this._methodHost && this.__templatizeOptions.parentModel) {\n        // If this instance should be considered a parent model, decorate\n        // events this template instance as `model`\n        this._methodHost._addEventListenerToNode(node, eventName, e => {\n          e.model = this;\n          handler(e);\n        });\n      } else {\n        // Otherwise delegate to the template's host (which could be)\n        // another template instance\n        let templateHost = this.__dataHost.__dataHost;\n        if (templateHost) {\n          templateHost._addEventListenerToNode(node, eventName, handler);\n        }\n      }\n    }\n    /**\n     * Shows or hides the template instance top level child elements. For\n     * text nodes, `textContent` is removed while \"hidden\" and replaced when\n     * \"shown.\"\n     * @param {boolean} hide Set to true to hide the children;\n     * set to false to show them.\n     * @protected\n     */\n    _showHideChildren(hide) {\n      let c = this.children;\n      for (let i = 0; i < c.length; i++) {\n        let n = c[i];\n        // Ignore non-changes\n        if (Boolean(hide) != Boolean(n.__hideTemplateChildren__)) {\n          if (n.nodeType === Node.TEXT_NODE) {\n            if (hide) {\n              n.__polymerTextContent__ = n.textContent;\n              n.textContent = '';\n            } else {\n              n.textContent = n.__polymerTextContent__;\n            }\n          } else if (n.style) {\n            if (hide) {\n              n.__polymerDisplay__ = n.style.display;\n              n.style.display = 'none';\n            } else {\n              n.style.display = n.__polymerDisplay__;\n            }\n          }\n        }\n        n.__hideTemplateChildren__ = hide;\n        if (n._showHideChildren) {\n          n._showHideChildren(hide);\n        }\n      }\n    }\n    /**\n     * Overrides default property-effects implementation to intercept\n     * textContent bindings while children are \"hidden\" and cache in\n     * private storage for later retrieval.\n     *\n     * @override\n     */\n    _setUnmanagedPropertyToNode(node, prop, value) {\n      if (node.__hideTemplateChildren__ && node.nodeType == Node.TEXT_NODE && prop == 'textContent') {\n        node.__polymerTextContent__ = value;\n      } else {\n        super._setUnmanagedPropertyToNode(node, prop, value);\n      }\n    }\n    /**\n     * Find the parent model of this template instance.  The parent model\n     * is either another templatize instance that had option `parentModel: true`,\n     * or else the host element.\n     *\n     * @return {Polymer.PropertyEffectsInterface} The parent model of this instance\n     */\n    get parentModel() {\n      let model = this.__parentModel;\n      if (!model) {\n        let options;\n        model = this;\n        do {\n          // A template instance's `__dataHost` is a <template>\n          // `model.__dataHost.__dataHost` is the template's host\n          model = model.__dataHost.__dataHost;\n        } while ((options = model.__templatizeOptions) && !options.parentModel);\n        this.__parentModel = model;\n      }\n      return model;\n    }\n  }\n\n  const MutableTemplateInstanceBase = Polymer.MutableData(TemplateInstanceBase);\n\n  function findMethodHost(template) {\n    // Technically this should be the owner of the outermost template.\n    // In shadow dom, this is always getRootNode().host, but we can\n    // approximate this via cooperation with our dataHost always setting\n    // `_methodHost` as long as there were bindings (or id's) on this\n    // instance causing it to get a dataHost.\n    let templateHost = template.__dataHost;\n    return templateHost && templateHost._methodHost || templateHost;\n  }\n\n  function createTemplatizerClass(template, templateInfo, options) {\n    // Anonymous class created by the templatize\n    /**\n     * @unrestricted\n     */\n    let base = options.mutableData ? MutableTemplateInstanceBase : TemplateInstanceBase;\n    let klass = class extends base {};\n    klass.prototype.__templatizeOptions = options;\n    klass.prototype._bindTemplate(template);\n    addNotifyEffects(klass, template, templateInfo, options);\n    return klass;\n  }\n\n  function addPropagateEffects(template, templateInfo, options) {\n    let userForwardHostProp = options.forwardHostProp;\n    if (userForwardHostProp) {\n      // Provide data API and property effects on memoized template class\n      let klass = templateInfo.templatizeTemplateClass;\n      if (!klass) {\n        let base = options.mutableData ? MutableDataTemplate : DataTemplate;\n        klass = templateInfo.templatizeTemplateClass = class TemplatizedTemplate extends base {};\n        // Add template - >instances effects\n        // and host <- template effects\n        let hostProps = templateInfo.hostProps;\n        for (let prop in hostProps) {\n          klass.prototype._addPropertyEffect('_host_' + prop, klass.prototype.PROPERTY_EFFECT_TYPES.PROPAGATE, { fn: createForwardHostPropEffect(prop, userForwardHostProp) });\n          klass.prototype._createNotifyingProperty('_host_' + prop);\n        }\n      }\n      upgradeTemplate(template, klass);\n      // Mix any pre-bound data into __data; no need to flush this to\n      // instances since they pull from the template at instance-time\n      if (template.__dataProto) {\n        // Note, generally `__dataProto` could be chained, but it's guaranteed\n        // to not be since this is a vanilla template we just added effects to\n        Object.assign(template.__data, template.__dataProto);\n      }\n      // Clear any pending data for performance\n      template.__dataTemp = {};\n      template.__dataPending = null;\n      template.__dataOld = null;\n      template._enableProperties();\n    }\n  }\n\n  function createForwardHostPropEffect(hostProp, userForwardHostProp) {\n    return function forwardHostProp(template, prop, props) {\n      userForwardHostProp.call(template.__templatizeOwner, prop.substring('_host_'.length), props[prop]);\n    };\n  }\n\n  function addNotifyEffects(klass, template, templateInfo, options) {\n    let hostProps = templateInfo.hostProps || {};\n    for (let iprop in options.instanceProps) {\n      delete hostProps[iprop];\n      let userNotifyInstanceProp = options.notifyInstanceProp;\n      if (userNotifyInstanceProp) {\n        klass.prototype._addPropertyEffect(iprop, klass.prototype.PROPERTY_EFFECT_TYPES.NOTIFY, { fn: createNotifyInstancePropEffect(iprop, userNotifyInstanceProp) });\n      }\n    }\n    if (options.forwardHostProp && template.__dataHost) {\n      for (let hprop in hostProps) {\n        klass.prototype._addPropertyEffect(hprop, klass.prototype.PROPERTY_EFFECT_TYPES.NOTIFY, { fn: createNotifyHostPropEffect() });\n      }\n    }\n  }\n\n  function createNotifyInstancePropEffect(instProp, userNotifyInstanceProp) {\n    return function notifyInstanceProp(inst, prop, props) {\n      userNotifyInstanceProp.call(inst.__templatizeOwner, inst, prop, props[prop]);\n    };\n  }\n\n  function createNotifyHostPropEffect() {\n    return function notifyHostProp(inst, prop, props) {\n      inst.__dataHost._setPendingPropertyOrPath('_host_' + prop, props[prop], true, true);\n    };\n  }\n\n  /**\n   * Module for preparing and stamping instances of templates that utilize\n   * Polymer's data-binding and declarative event listener features.\n   *\n   * Example:\n   *\n   *     // Get a template from somewhere, e.g. light DOM\n   *     let template = this.querySelector('template');\n   *     // Prepare the template\n   *     let TemplateClass = Polymer.Templatize.templatize(template);\n   *     // Instance the template with an initial data model\n   *     let instance = new TemplateClass({myProp: 'initial'});\n   *     // Insert the instance's DOM somewhere, e.g. element's shadow DOM\n   *     this.shadowRoot.appendChild(instance.root);\n   *     // Changing a property on the instance will propagate to bindings\n   *     // in the template\n   *     instance.myProp = 'new value';\n   *\n   * The `options` dictionary passed to `templatize` allows for customizing\n   * features of the generated template class, including how outer-scope host\n   * properties should be forwarded into template instances, how any instance\n   * properties added into the template's scope should be notified out to\n   * the host, and whether the instance should be decorated as a \"parent model\"\n   * of any event handlers.\n   *\n   *     // Customze property forwarding and event model decoration\n   *     let TemplateClass = Polymer.Tempaltize.templatize(template, this, {\n   *       parentModel: true,\n   *       instanceProps: {...},\n   *       forwardHostProp(property, value) {...},\n   *       notifyInstanceProp(instance, property, value) {...},\n   *     });\n   *\n   *\n   * @namespace\n   * @memberof Polymer\n   * @summary Module for preparing and stamping instances of templates\n   *   utilizing Polymer templating features.\n   */\n  const Templatize = {\n\n    /**\n     * Returns an anonymous `Polymer.PropertyEffects` class bound to the\n     * `<template>` provided.  Instancing the class will result in the\n     * template being stamped into document fragment stored as the instance's\n     * `root` property, after which it can be appended to the DOM.\n     *\n     * Templates may utilize all Polymer data-binding features as well as\n     * declarative event listeners.  Event listeners and inline computing\n     * functions in the template will be called on the host of the template.\n     *\n     * The constructor returned takes a single argument dictionary of initial\n     * property values to propagate into template bindings.  Additionally\n     * host properties can be forwarded in, and instance properties can be\n     * notified out by providing optional callbacks in the `options` dictionary.\n     *\n     * Valid configuration in `options` are as follows:\n     *\n     * - `forwardHostProp(property, value)`: Called when a property referenced\n     *   in the template changed on the template's host. As this library does\n     *   not retain references to templates instanced by the user, it is the\n     *   templatize owner's responsibility to forward host property changes into\n     *   user-stamped instances.  The `instance.forwardHostProp(property, value)`\n     *    method on the generated class should be called to forward host\n     *   properties into the template to prevent unnecessary property-changed\n     *   notifications. Any properties referenced in the template that are not\n     *   defined in `instanceProps` will be notified up to the template's host\n     *   automatically.\n     * - `instanceProps`: Dictionary of property names that will be added\n     *   to the instance by the templatize owner.  These properties shadow any\n     *   host properties, and changes within the template to these properties\n     *   will result in `notifyInstanceProp` being called.\n     * - `mutableData`: When `true`, the generated class will skip strict\n     *   dirty-checking for objects and arrays (always consider them to be\n     *   \"dirty\").\n     * - `notifyInstanceProp(instance, property, value)`: Called when\n     *   an instance property changes.  Users may choose to call `notifyPath`\n     *   on e.g. the owner to notify the change.\n     * - `parentModel`: When `true`, events handled by declarative event listeners\n     *   (`on-event=\"handler\"`) will be decorated with a `model` property pointing\n     *   to the template instance that stamped it.  It will also be returned\n     *   from `instance.parentModel` in cases where template instance nesting\n     *   causes an inner model to shadow an outer model.\n     *\n     * Note that the class returned from `templatize` is generated only once\n     * for a given `<template>` using `options` from the first call for that\n     * template, and the cached class is returned for all subsequent calls to\n     * `templatize` for that template.  As such, `options` callbacks should not\n     * close over owner-specific properties since only the first `options` is\n     * used; rather, callbacks are called bound to the `owner`, and so context\n     * needed from the callbacks (such as references to `instances` stamped)\n     * should be stored on the `owner` such that they can be retrieved via `this`.\n     *\n     * @memberof Polymer.Templatize\n     * @param {HTMLTemplateElement} template Template to templatize\n     * @param {*} owner Owner of the template instances; any optional callbacks\n     *   will be bound to this owner.\n     * @param {*=} options Options dictionary (see summary for details)\n     * @return {TemplateInstanceBase} Generated class bound to the template\n     *   provided\n     */\n    templatize(template, owner, options) {\n      options = options || {};\n      if (template.__templatizeOwner) {\n        throw new Error('A <template> can only be templatized once');\n      }\n      template.__templatizeOwner = owner;\n      let templateInfo = owner.constructor._parseTemplate(template);\n      // Get memoized base class for the prototypical template, which\n      // includes property effects for binding template & forwarding\n      let baseClass = templateInfo.templatizeInstanceClass;\n      if (!baseClass) {\n        baseClass = createTemplatizerClass(template, templateInfo, options);\n        templateInfo.templatizeInstanceClass = baseClass;\n      }\n      // Host property forwarding must be installed onto template instance\n      addPropagateEffects(template, templateInfo, options);\n      // Subclass base class and add reference for this specific template\n      let klass = class TemplateInstance extends baseClass {};\n      klass.prototype._methodHost = findMethodHost(template);\n      klass.prototype.__dataHost = template;\n      klass.prototype.__templatizeOwner = owner;\n      klass.prototype.__hostProps = templateInfo.hostProps;\n      return klass;\n    },\n\n    /**\n     * Returns the template \"model\" associated with a given element, which\n     * serves as the binding scope for the template instance the element is\n     * contained in. A template model is an instance of\n     * `TemplateInstanceBase`, and should be used to manipulate data\n     * associated with this template instance.\n     *\n     * Example:\n     *\n     *   let model = modelForElement(el);\n     *   if (model.index < 10) {\n     *     model.set('item.checked', true);\n     *   }\n     *\n     * @memberof Polymer.Templatize\n     * @param {HTMLTemplateElement} template The model will be returned for\n     *   elements stamped from this template\n     * @param {HTMLElement} el Element for which to return a template model.\n     * @return {TemplateInstanceBase} Template instance representing the\n     *   binding scope for the element\n     */\n    modelForElement(template, el) {\n      let model;\n      while (el) {\n        // An element with a __templatizeInstance marks the top boundary\n        // of a scope; walk up until we find one, and then ensure that\n        // its __dataHost matches `this`, meaning this dom-repeat stamped it\n        if (model = el.__templatizeInstance) {\n          // Found an element stamped by another template; keep walking up\n          // from its __dataHost\n          if (model.__dataHost != template) {\n            el = model.__dataHost;\n          } else {\n            return model;\n          }\n        } else {\n          // Still in a template scope, keep going up until\n          // a __templatizeInstance is found\n          el = el.parentNode;\n        }\n      }\n      return null;\n    }\n  };\n\n  Polymer.Templatize = Templatize;\n})();\n\n/***/ }),\n/* 45 */\n/***/ (function(module, exports) {\n\nmodule.exports = function (module) {\n\tif (!module.webpackPolyfill) {\n\t\tmodule.deprecate = function () {};\n\t\tmodule.paths = [];\n\t\t// module.parent = undefined by default\n\t\tif (!module.children) module.children = [];\n\t\tObject.defineProperty(module, \"loaded\", {\n\t\t\tenumerable: true,\n\t\t\tget: function () {\n\t\t\t\treturn module.l;\n\t\t\t}\n\t\t});\n\t\tObject.defineProperty(module, \"id\", {\n\t\t\tenumerable: true,\n\t\t\tget: function () {\n\t\t\t\treturn module.i;\n\t\t\t}\n\t\t});\n\t\tmodule.webpackPolyfill = 1;\n\t}\n\treturn module;\n};\n\n/***/ }),\n/* 46 */\n/***/ (function(module, exports, __webpack_require__) {\n\nmodule.exports = __webpack_require__(15);\n\n\n/***/ })\n/******/ ]);\n\n\n// WEBPACK FOOTER //\n// bundle.js"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// identity function for calling harmony imports with the correct context\n \t__webpack_require__.i = function(value) { return value; };\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 46);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap d3852852b6569872b94d","/*__wc__loader*/\n\n(function() {\n  'use strict';\n\n  const userPolymer = window.Polymer;\n\n  /**\n   * @namespace Polymer\n   * @summary Polymer is a lightweight library built on top of the web\n   * standards-based Web Components API's, and makes it easy to build your\n   * own custom HTML elements.\n   * @param {Object} info Prototype for the custom element. It must contain\n   * an `is` property to specify the element name. Other properties populate\n   * the element prototype. The `properties`, `observers`, `hostAttributes`,\n   * and `listeners` properties are processed to create element features.\n   * @return {Object} Returns a custom element class for the given provided\n   * prototype `info` object. The name of the element if given by `info.is`.\n   */\n  window.Polymer = function(info) {\n    return window.Polymer._polymerFn(info);\n  }\n\n  // support user settings on the Polymer object\n  if (userPolymer) {\n    Object.assign(Polymer, userPolymer);\n  }\n\n  // To be plugged by legacy implementation if loaded\n  /**\n   * @param {Object} info Prototype for the custom element. It must contain\n   * an `is` property to specify the element name. Other properties populate\n   * the element prototype. The `properties`, `observers`, `hostAttributes`,\n   * and `listeners` properties are processed to create element features.\n   */\n  window.Polymer._polymerFn = function(info) { // eslint-disable-line no-unused-vars\n    throw new Error('Load polymer.html to use the Polymer() function.');\n  }\n  window.Polymer.version = '2.0.1';\n\n  /* eslint-disable no-unused-vars */\n  /*\n  When using Closure Compiler, JSCompiler_renameProperty(property, object) is replaced by the munged name for object[property]\n  We cannot alias this function, so we have to use a small shim that has the same behavior when not compiling.\n  */\n  window.JSCompiler_renameProperty = function(prop, obj) {\n    return prop;\n  }\n  /* eslint-enable */\n\n})();\n\n\n\n\n// WEBPACK FOOTER //\n// ./~/@polymer/polymer/lib/utils/boot.html","/*__wc__loader*/\nrequire('./boot.html');\n\n\n\n(function() {\n\n  'use strict';\n\n  // unique global id for deduping mixins.\n  let dedupeId = 0;\n\n  /**\n   * Given a mixin producing function, memoize applications of mixin to base\n   * @private\n   * @param {Function} mixin Mixin for which to create a caching mixin.\n   * @return {Function} Returns a mixin which when applied multiple times to the\n   * same base will always return the same extended class.\n   */\n  function cachingMixin(mixin) {\n    return function(base) {\n      if (!mixin.__mixinApplications) {\n        mixin.__mixinApplications = new WeakMap();\n      }\n      let map = mixin.__mixinApplications;\n      let application = map.get(base);\n      if (!application) {\n        application = mixin(base);\n        map.set(base, application);\n      }\n      return application;\n    };\n  }\n\n  /**\n   * Wraps an ES6 class expression mixin such that the mixin is only applied\n   * if it has not already been applied its base argument.  Also memoizes mixin\n   * applications.\n   *\n   * @memberof Polymer\n   * @param {Function} mixin ES6 class expression mixin to wrap\n   * @return {Function} Wrapped mixin that deduplicates and memoizes\n   *   mixin applications to base\n   */\n  Polymer.dedupingMixin = function(mixin) {\n    mixin = cachingMixin(mixin);\n    // maintain a unique id for each mixin\n    mixin.__dedupeId = ++dedupeId;\n    return function(base) {\n      let baseSet = base.__mixinSet;\n      if (baseSet && baseSet[mixin.__dedupeId]) {\n        return base;\n      }\n      let extended = mixin(base);\n      // copy inherited mixin set from the extended class, or the base class\n      // NOTE: we avoid use of Set here because some browser (IE11)\n      // cannot extend a base Set via the constructor.\n      extended.__mixinSet =\n        Object.create(extended.__mixinSet || baseSet || null);\n      extended.__mixinSet[mixin.__dedupeId] = true;\n      return extended;\n    }\n  };\n\n})();\n\n\n\n\n\n// WEBPACK FOOTER //\n// ./~/@polymer/polymer/lib/utils/mixin.html","/*__wc__loader*/\nrequire('./boot.html');\n\n\n(function() {\n  'use strict';\n\n  const caseMap = {};\n  const DASH_TO_CAMEL = /-[a-z]/g;\n  const CAMEL_TO_DASH = /([A-Z])/g;\n\n  /**\n   * Module with utilities for converting between \"dash-case\" and \"camelCase\"\n   * identifiers.\n   *\n   * @namespace\n   * @memberof Polymer\n   * @summary Module that provides utilities for converting between \"dash-case\"\n   *   and \"camelCase\".\n   */\n  const CaseMap = {\n\n    /**\n     * Converts \"dash-case\" identifier (e.g. `foo-bar-baz`) to \"camelCase\"\n     * (e.g. `fooBarBaz`).\n     *\n     * @memberof Polymer.CaseMap\n     * @param {string} dash Dash-case identifier\n     * @return {string} Camel-case representation of the identifier\n     */\n    dashToCamelCase(dash) {\n      return caseMap[dash] || (\n        caseMap[dash] = dash.indexOf('-') < 0 ? dash : dash.replace(DASH_TO_CAMEL,\n          (m) => m[1].toUpperCase()\n        )\n      );\n    },\n\n    /**\n     * Converts \"camelCase\" identifier (e.g. `fooBarBaz`) to \"dash-case\"\n     * (e.g. `foo-bar-baz`).\n     *\n     * @memberof Polymer.CaseMap\n     * @param {string} camel Camel-case identifier\n     * @return {string} Dash-case representation of the identifier\n     */\n    camelToDashCase(camel) {\n      return caseMap[camel] || (\n        caseMap[camel] = camel.replace(CAMEL_TO_DASH, '-$1').toLowerCase()\n      );\n    }\n\n  };\n\n  Polymer.CaseMap = CaseMap;\n})();\n\n\n\n\n// WEBPACK FOOTER //\n// ./~/@polymer/polymer/lib/utils/case-map.html","/*__wc__loader*/\nrequire('./boot.html');\n\n\n\n  (function() {\n    'use strict';\n\n    let CSS_URL_RX = /(url\\()([^)]*)(\\))/g;\n    let ABS_URL = /(^\\/)|(^#)|(^[\\w-\\d]*:)/;\n    let workingURL;\n    let resolveDoc;\n    /**\n     * Resolves the given URL against the provided `baseUri'.\n     *\n     * @memberof Polymer.ResolveUrl\n     * @param {string} url Input URL to resolve\n     * @param {string} baseURI Base URI to resolve the URL against\n     * @return {string} resolved URL\n     */\n    function resolveUrl(url, baseURI) {\n      if (url && ABS_URL.test(url)) {\n        return url;\n      }\n      // Lazy feature detection.\n      if (workingURL === undefined) {\n        workingURL = false;\n        try {\n          const u = new URL('b', 'http://a');\n          u.pathname = 'c%20d';\n          workingURL = (u.href === 'http://a/c%20d');\n        } catch (e) {\n          // silently fail\n        }\n      }\n      if (!baseURI) {\n        baseURI = document.baseURI || window.location.href;\n      }\n      if (workingURL) {\n        return (new URL(url, baseURI)).href;\n      }\n      // Fallback to creating an anchor into a disconnected document.\n      if (!resolveDoc) {\n        resolveDoc = document.implementation.createHTMLDocument('temp');\n        resolveDoc.base = resolveDoc.createElement('base');\n        resolveDoc.head.appendChild(resolveDoc.base);\n        resolveDoc.anchor = resolveDoc.createElement('a');\n        resolveDoc.body.appendChild(resolveDoc.anchor);\n      }\n      resolveDoc.base.href = baseURI;\n      resolveDoc.anchor.href = url;\n      return resolveDoc.anchor.href || url;\n\n    }\n\n    /**\n     * Resolves any relative URL's in the given CSS text against the provided\n     * `ownerDocument`'s `baseURI`.\n     *\n     * @memberof Polymer.ResolveUrl\n     * @param {string} cssText CSS text to process\n     * @param {string} baseURI Base URI to resolve the URL against\n     * @return {string} Processed CSS text with resolved URL's\n     */\n    function resolveCss(cssText, baseURI) {\n      return cssText.replace(CSS_URL_RX, function(m, pre, url, post) {\n        return pre + '\\'' +\n          resolveUrl(url.replace(/[\"']/g, ''), baseURI) +\n          '\\'' + post;\n      });\n    }\n\n    /**\n     * Returns a path from a given `url`. The path includes the trailing\n     * `/` from the url.\n     *\n     * @memberof Polymer.ResolveUrl\n     * @param {string} url Input URL to transform\n     * @return {string} resolved path\n     */\n    function pathFromUrl(url) {\n      return url.substring(0, url.lastIndexOf('/') + 1);\n    }\n\n    /**\n     * Module with utilities for resolving relative URL's.\n     *\n     * @namespace\n     * @memberof Polymer\n     * @summary Module with utilities for resolving relative URL's.\n     */\n    Polymer.ResolveUrl = {\n      resolveCss: resolveCss,\n      resolveUrl: resolveUrl,\n      pathFromUrl: pathFromUrl\n    };\n\n  })();\n\n\n\n\n\n// WEBPACK FOOTER //\n// ./~/@polymer/polymer/lib/utils/resolve-url.html","/*__wc__loader*/\nrequire('./lib/mixins/element-mixin.html');\n\n\n(function() {\n  'use strict';\n\n  /**\n   * Base class that provides the core API for Polymer's meta-programming\n   * features including template stamping, data-binding, attribute deserialization,\n   * and property change observation.\n   *\n   * @polymerElement\n   * @memberof Polymer\n   * @constructor\n   * @implements {Polymer_ElementMixin}\n   * @extends HTMLElement\n   * @mixes Polymer.ElementMixin\n   * @summary Custom element base class that provides the core API for Polymer's\n   *   key meta-programming features including template stamping, data-binding,\n   *   attribute deserialization, and property change observation\n   */\n  const Element = Polymer.ElementMixin(HTMLElement);\n  Polymer.Element = Element;\n})();\n\n\n\n\n// WEBPACK FOOTER //\n// ./~/@polymer/polymer/polymer-element.html","'use strict';\n\nimport { createStore } from 'redux';\n\nconst state = {\n  items: [],\n  selected: null\n}\n\nconst appReducer = (state = 0, action) => {\n  switch (action.type) {\n    case 'SET_ITEMS':\n      return Object.assign({}, state, {items: action.data});\n    case 'SELECTED':\n      return Object.assign({}, state, {selected: action.data});\n    default:\n      return state\n    }\n}\n\nexport const store = createStore(\n  appReducer, \n  window.__REDUX_DEVTOOLS_EXTENSION__ && window.__REDUX_DEVTOOLS_EXTENSION__()\n);\n\n\n// WEBPACK FOOTER //\n// ./components/store.js","import root from './_root.js';\n\n/** Built-in value references. */\nvar Symbol = root.Symbol;\n\nexport default Symbol;\n\n\n\n// WEBPACK FOOTER //\n// ./~/lodash-es/_Symbol.js","import baseGetTag from './_baseGetTag.js';\nimport getPrototype from './_getPrototype.js';\nimport isObjectLike from './isObjectLike.js';\n\n/** `Object#toString` result references. */\nvar objectTag = '[object Object]';\n\n/** Used for built-in method references. */\nvar funcProto = Function.prototype,\n    objectProto = Object.prototype;\n\n/** Used to resolve the decompiled source of functions. */\nvar funcToString = funcProto.toString;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/** Used to infer the `Object` constructor. */\nvar objectCtorString = funcToString.call(Object);\n\n/**\n * Checks if `value` is a plain object, that is, an object created by the\n * `Object` constructor or one with a `[[Prototype]]` of `null`.\n *\n * @static\n * @memberOf _\n * @since 0.8.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a plain object, else `false`.\n * @example\n *\n * function Foo() {\n *   this.a = 1;\n * }\n *\n * _.isPlainObject(new Foo);\n * // => false\n *\n * _.isPlainObject([1, 2, 3]);\n * // => false\n *\n * _.isPlainObject({ 'x': 0, 'y': 0 });\n * // => true\n *\n * _.isPlainObject(Object.create(null));\n * // => true\n */\nfunction isPlainObject(value) {\n  if (!isObjectLike(value) || baseGetTag(value) != objectTag) {\n    return false;\n  }\n  var proto = getPrototype(value);\n  if (proto === null) {\n    return true;\n  }\n  var Ctor = hasOwnProperty.call(proto, 'constructor') && proto.constructor;\n  return typeof Ctor == 'function' && Ctor instanceof Ctor &&\n    funcToString.call(Ctor) == objectCtorString;\n}\n\nexport default isPlainObject;\n\n\n\n// WEBPACK FOOTER //\n// ./~/lodash-es/isPlainObject.js","/**\n * Composes single-argument functions from right to left. The rightmost\n * function can take multiple arguments as it provides the signature for\n * the resulting composite function.\n *\n * @param {...Function} funcs The functions to compose.\n * @returns {Function} A function obtained by composing the argument functions\n * from right to left. For example, compose(f, g, h) is identical to doing\n * (...args) => f(g(h(...args))).\n */\n\nexport default function compose() {\n  for (var _len = arguments.length, funcs = Array(_len), _key = 0; _key < _len; _key++) {\n    funcs[_key] = arguments[_key];\n  }\n\n  if (funcs.length === 0) {\n    return function (arg) {\n      return arg;\n    };\n  }\n\n  if (funcs.length === 1) {\n    return funcs[0];\n  }\n\n  var last = funcs[funcs.length - 1];\n  var rest = funcs.slice(0, -1);\n  return function () {\n    return rest.reduceRight(function (composed, f) {\n      return f(composed);\n    }, last.apply(undefined, arguments));\n  };\n}\n\n\n// WEBPACK FOOTER //\n// ./~/redux/es/compose.js","import isPlainObject from 'lodash-es/isPlainObject';\nimport $$observable from 'symbol-observable';\n\n/**\n * These are private action types reserved by Redux.\n * For any unknown actions, you must return the current state.\n * If the current state is undefined, you must return the initial state.\n * Do not reference these action types directly in your code.\n */\nexport var ActionTypes = {\n  INIT: '@@redux/INIT'\n};\n\n/**\n * Creates a Redux store that holds the state tree.\n * The only way to change the data in the store is to call `dispatch()` on it.\n *\n * There should only be a single store in your app. To specify how different\n * parts of the state tree respond to actions, you may combine several reducers\n * into a single reducer function by using `combineReducers`.\n *\n * @param {Function} reducer A function that returns the next state tree, given\n * the current state tree and the action to handle.\n *\n * @param {any} [preloadedState] The initial state. You may optionally specify it\n * to hydrate the state from the server in universal apps, or to restore a\n * previously serialized user session.\n * If you use `combineReducers` to produce the root reducer function, this must be\n * an object with the same shape as `combineReducers` keys.\n *\n * @param {Function} enhancer The store enhancer. You may optionally specify it\n * to enhance the store with third-party capabilities such as middleware,\n * time travel, persistence, etc. The only store enhancer that ships with Redux\n * is `applyMiddleware()`.\n *\n * @returns {Store} A Redux store that lets you read the state, dispatch actions\n * and subscribe to changes.\n */\nexport default function createStore(reducer, preloadedState, enhancer) {\n  var _ref2;\n\n  if (typeof preloadedState === 'function' && typeof enhancer === 'undefined') {\n    enhancer = preloadedState;\n    preloadedState = undefined;\n  }\n\n  if (typeof enhancer !== 'undefined') {\n    if (typeof enhancer !== 'function') {\n      throw new Error('Expected the enhancer to be a function.');\n    }\n\n    return enhancer(createStore)(reducer, preloadedState);\n  }\n\n  if (typeof reducer !== 'function') {\n    throw new Error('Expected the reducer to be a function.');\n  }\n\n  var currentReducer = reducer;\n  var currentState = preloadedState;\n  var currentListeners = [];\n  var nextListeners = currentListeners;\n  var isDispatching = false;\n\n  function ensureCanMutateNextListeners() {\n    if (nextListeners === currentListeners) {\n      nextListeners = currentListeners.slice();\n    }\n  }\n\n  /**\n   * Reads the state tree managed by the store.\n   *\n   * @returns {any} The current state tree of your application.\n   */\n  function getState() {\n    return currentState;\n  }\n\n  /**\n   * Adds a change listener. It will be called any time an action is dispatched,\n   * and some part of the state tree may potentially have changed. You may then\n   * call `getState()` to read the current state tree inside the callback.\n   *\n   * You may call `dispatch()` from a change listener, with the following\n   * caveats:\n   *\n   * 1. The subscriptions are snapshotted just before every `dispatch()` call.\n   * If you subscribe or unsubscribe while the listeners are being invoked, this\n   * will not have any effect on the `dispatch()` that is currently in progress.\n   * However, the next `dispatch()` call, whether nested or not, will use a more\n   * recent snapshot of the subscription list.\n   *\n   * 2. The listener should not expect to see all state changes, as the state\n   * might have been updated multiple times during a nested `dispatch()` before\n   * the listener is called. It is, however, guaranteed that all subscribers\n   * registered before the `dispatch()` started will be called with the latest\n   * state by the time it exits.\n   *\n   * @param {Function} listener A callback to be invoked on every dispatch.\n   * @returns {Function} A function to remove this change listener.\n   */\n  function subscribe(listener) {\n    if (typeof listener !== 'function') {\n      throw new Error('Expected listener to be a function.');\n    }\n\n    var isSubscribed = true;\n\n    ensureCanMutateNextListeners();\n    nextListeners.push(listener);\n\n    return function unsubscribe() {\n      if (!isSubscribed) {\n        return;\n      }\n\n      isSubscribed = false;\n\n      ensureCanMutateNextListeners();\n      var index = nextListeners.indexOf(listener);\n      nextListeners.splice(index, 1);\n    };\n  }\n\n  /**\n   * Dispatches an action. It is the only way to trigger a state change.\n   *\n   * The `reducer` function, used to create the store, will be called with the\n   * current state tree and the given `action`. Its return value will\n   * be considered the **next** state of the tree, and the change listeners\n   * will be notified.\n   *\n   * The base implementation only supports plain object actions. If you want to\n   * dispatch a Promise, an Observable, a thunk, or something else, you need to\n   * wrap your store creating function into the corresponding middleware. For\n   * example, see the documentation for the `redux-thunk` package. Even the\n   * middleware will eventually dispatch plain object actions using this method.\n   *\n   * @param {Object} action A plain object representing what changed. It is\n   * a good idea to keep actions serializable so you can record and replay user\n   * sessions, or use the time travelling `redux-devtools`. An action must have\n   * a `type` property which may not be `undefined`. It is a good idea to use\n   * string constants for action types.\n   *\n   * @returns {Object} For convenience, the same action object you dispatched.\n   *\n   * Note that, if you use a custom middleware, it may wrap `dispatch()` to\n   * return something else (for example, a Promise you can await).\n   */\n  function dispatch(action) {\n    if (!isPlainObject(action)) {\n      throw new Error('Actions must be plain objects. ' + 'Use custom middleware for async actions.');\n    }\n\n    if (typeof action.type === 'undefined') {\n      throw new Error('Actions may not have an undefined \"type\" property. ' + 'Have you misspelled a constant?');\n    }\n\n    if (isDispatching) {\n      throw new Error('Reducers may not dispatch actions.');\n    }\n\n    try {\n      isDispatching = true;\n      currentState = currentReducer(currentState, action);\n    } finally {\n      isDispatching = false;\n    }\n\n    var listeners = currentListeners = nextListeners;\n    for (var i = 0; i < listeners.length; i++) {\n      listeners[i]();\n    }\n\n    return action;\n  }\n\n  /**\n   * Replaces the reducer currently used by the store to calculate the state.\n   *\n   * You might need this if your app implements code splitting and you want to\n   * load some of the reducers dynamically. You might also need this if you\n   * implement a hot reloading mechanism for Redux.\n   *\n   * @param {Function} nextReducer The reducer for the store to use instead.\n   * @returns {void}\n   */\n  function replaceReducer(nextReducer) {\n    if (typeof nextReducer !== 'function') {\n      throw new Error('Expected the nextReducer to be a function.');\n    }\n\n    currentReducer = nextReducer;\n    dispatch({ type: ActionTypes.INIT });\n  }\n\n  /**\n   * Interoperability point for observable/reactive libraries.\n   * @returns {observable} A minimal observable of state changes.\n   * For more information, see the observable proposal:\n   * https://github.com/zenparsing/es-observable\n   */\n  function observable() {\n    var _ref;\n\n    var outerSubscribe = subscribe;\n    return _ref = {\n      /**\n       * The minimal observable subscription method.\n       * @param {Object} observer Any object that can be used as an observer.\n       * The observer object should have a `next` method.\n       * @returns {subscription} An object with an `unsubscribe` method that can\n       * be used to unsubscribe the observable from the store, and prevent further\n       * emission of values from the observable.\n       */\n      subscribe: function subscribe(observer) {\n        if (typeof observer !== 'object') {\n          throw new TypeError('Expected the observer to be an object.');\n        }\n\n        function observeState() {\n          if (observer.next) {\n            observer.next(getState());\n          }\n        }\n\n        observeState();\n        var unsubscribe = outerSubscribe(observeState);\n        return { unsubscribe: unsubscribe };\n      }\n    }, _ref[$$observable] = function () {\n      return this;\n    }, _ref;\n  }\n\n  // When a store is created, an \"INIT\" action is dispatched so that every\n  // reducer returns their initial state. This effectively populates\n  // the initial state tree.\n  dispatch({ type: ActionTypes.INIT });\n\n  return _ref2 = {\n    dispatch: dispatch,\n    subscribe: subscribe,\n    getState: getState,\n    replaceReducer: replaceReducer\n  }, _ref2[$$observable] = observable, _ref2;\n}\n\n\n// WEBPACK FOOTER //\n// ./~/redux/es/createStore.js","/*__wc__loader*/\nrequire('../utils/mixin.html');\n\n\n(function() {\n  'use strict';\n\n  // Common implementation for mixin & behavior\n  function mutablePropertyChange(inst, property, value, old, mutableData) {\n    let isObject;\n    if (mutableData) {\n      isObject = (typeof value === 'object' && value !== null);\n      // Pull `old` for Objects from temp cache, but treat `null` as a primitive\n      if (isObject) {\n        old = inst.__dataTemp[property];\n      }\n    }\n    // Strict equality check, but return false for NaN===NaN\n    let shouldChange = (old !== value && (old === old || value === value));\n    // Objects are stored in temporary cache (cleared at end of\n    // turn), which is used for dirty-checking\n    if (isObject && shouldChange) {\n      inst.__dataTemp[property] = value;\n    }\n    return shouldChange;\n  }\n\n  /**\n   * Element class mixin to skip strict dirty-checking for objects and arrays\n   * (always consider them to be \"dirty\"), for use on elements utilizing\n   * `Polymer.PropertyEffects`\n   *\n   * By default, `Polymer.PropertyEffects` performs strict dirty checking on\n   * objects, which means that any deep modifications to an object or array will\n   * not be propagated unless \"immutable\" data patterns are used (i.e. all object\n   * references from the root to the mutation were changed).\n   *\n   * Polymer also provides a proprietary data mutation and path notification API\n   * (e.g. `notifyPath`, `set`, and array mutation API's) that allow efficient\n   * mutation and notification of deep changes in an object graph to all elements\n   * bound to the same object graph.\n   *\n   * In cases where neither immutable patterns nor the data mutation API can be\n   * used, applying this mixin will cause Polymer to skip dirty checking for\n   * objects and arrays (always consider them to be \"dirty\").  This allows a\n   * user to make a deep modification to a bound object graph, and then either\n   * simply re-set the object (e.g. `this.items = this.items`) or call `notifyPath`\n   * (e.g. `this.notifyPath('items')`) to update the tree.  Note that all\n   * elements that wish to be updated based on deep mutations must apply this\n   * mixin or otherwise skip strict dirty checking for objects/arrays.\n   *\n   * In order to make the dirty check strategy configurable, see\n   * `Polymer.OptionalMutableData`.\n   *\n   * Note, the performance characteristics of propagating large object graphs\n   * will be worse as opposed to using strict dirty checking with immutable\n   * patterns or Polymer's path notification API.\n   *\n   * @polymerMixin\n   * @memberof Polymer\n   * @summary Element class mixin to skip strict dirty-checking for objects\n   *   and arrays\n   */\n  Polymer.MutableData = Polymer.dedupingMixin(superClass => {\n\n    /**\n     * @polymerMixinClass\n     * @implements {Polymer_MutableData}\n     */\n    class MutableData extends superClass {\n      /**\n       * Overrides `Polymer.PropertyEffects` to provide option for skipping\n       * strict equality checking for Objects and Arrays.\n       *\n       * This method pulls the value to dirty check against from the `__dataTemp`\n       * cache (rather than the normal `__data` cache) for Objects.  Since the temp\n       * cache is cleared at the end of a turn, this implementation allows\n       * side-effects of deep object changes to be processed by re-setting the\n       * same object (using the temp cache as an in-turn backstop to prevent\n       * cycles due to 2-way notification).\n       *\n       * @param {string} property Property name\n       * @param {*} value New property value\n       * @param {*} old Previous property value\n       * @return {boolean} Whether the property should be considered a change\n       * @protected\n       */\n      _shouldPropertyChange(property, value, old) {\n        return mutablePropertyChange(this, property, value, old, true);\n      }\n\n    }\n\n    return MutableData;\n\n  });\n\n  /**\n   * Element class mixin to add the optional ability to skip strict\n   * dirty-checking for objects and arrays (always consider them to be\n   * \"dirty\") by setting a `mutable-data` attribute on an element instance.\n   *\n   * By default, `Polymer.PropertyEffects` performs strict dirty checking on\n   * objects, which means that any deep modifications to an object or array will\n   * not be propagated unless \"immutable\" data patterns are used (i.e. all object\n   * references from the root to the mutation were changed).\n   *\n   * Polymer also provides a proprietary data mutation and path notification API\n   * (e.g. `notifyPath`, `set`, and array mutation API's) that allow efficient\n   * mutation and notification of deep changes in an object graph to all elements\n   * bound to the same object graph.\n   *\n   * In cases where neither immutable patterns nor the data mutation API can be\n   * used, applying this mixin will allow Polymer to skip dirty checking for\n   * objects and arrays (always consider them to be \"dirty\").  This allows a\n   * user to make a deep modification to a bound object graph, and then either\n   * simply re-set the object (e.g. `this.items = this.items`) or call `notifyPath`\n   * (e.g. `this.notifyPath('items')`) to update the tree.  Note that all\n   * elements that wish to be updated based on deep mutations must apply this\n   * mixin or otherwise skip strict dirty checking for objects/arrays.\n   *\n   * While this mixin adds the ability to forgo Object/Array dirty checking,\n   * the `mutableData` flag defaults to false and must be set on the instance.\n   *\n   * Note, the performance characteristics of propagating large object graphs\n   * will be worse by relying on `mutableData: true` as opposed to using\n   * strict dirty checking with immutable patterns or Polymer's path notification\n   * API.\n   *\n   * @polymerMixin\n   * @memberof Polymer\n   * @summary Element class mixin to optionally skip strict dirty-checking\n   *   for objects and arrays\n   */\n  Polymer.OptionalMutableData = Polymer.dedupingMixin(superClass => {\n\n    /**\n     * @polymerMixinClass\n     * @implements {Polymer_OptionalMutableData}\n     */\n    class OptionalMutableData extends superClass {\n\n      static get properties() {\n        return {\n          /**\n           * Instance-level flag for configuring the dirty-checking strategy\n           * for this element.  When true, Objects and Arrays will skip dirty\n           * checking, otherwise strict equality checking will be used.\n           */\n          mutableData: Boolean\n        };\n      }\n\n      /**\n       * Overrides `Polymer.PropertyEffects` to provide option for skipping\n       * strict equality checking for Objects and Arrays.\n       *\n       * When `this.mutableData` is true on this instance, this method\n       * pulls the value to dirty check against from the `__dataTemp` cache\n       * (rather than the normal `__data` cache) for Objects.  Since the temp\n       * cache is cleared at the end of a turn, this implementation allows\n       * side-effects of deep object changes to be processed by re-setting the\n       * same object (using the temp cache as an in-turn backstop to prevent\n       * cycles due to 2-way notification).\n       *\n       * @param {string} property Property name\n       * @param {*} value New property value\n       * @param {*} old Previous property value\n       * @return {boolean} Whether the property should be considered a change\n       * @protected\n       */\n      _shouldPropertyChange(property, value, old) {\n        return mutablePropertyChange(this, property, value, old, this.mutableData);\n      }\n    }\n\n    return OptionalMutableData;\n\n  });\n\n  // Export for use by legacy behavior\n  Polymer.MutableData._mutablePropertyChange = mutablePropertyChange;\n\n})();\n\n\n\n\n// WEBPACK FOOTER //\n// ./~/@polymer/polymer/lib/mixins/mutable-data.html","/*__wc__loader*/\nrequire('../utils/boot.html');\n\nrequire('../utils/mixin.html');\n\nrequire('../utils/path.html');\n\nrequire('../utils/case-map.html');\n\nrequire('./property-accessors.html');\n\nrequire('./template-stamp.html');\n\n\n(function() {\n\n  'use strict';\n\n  /** @const {Object} */\n  const CaseMap = Polymer.CaseMap;\n\n  // Monotonically increasing unique ID used for de-duping effects triggered\n  // from multiple properties in the same turn\n  let dedupeId = 0;\n\n  // Property effect types; effects are stored on the prototype using these keys\n  const TYPES = {\n    COMPUTE: '__computeEffects',\n    REFLECT: '__reflectEffects',\n    NOTIFY: '__notifyEffects',\n    PROPAGATE: '__propagateEffects',\n    OBSERVE: '__observeEffects',\n    READ_ONLY: '__readOnly'\n  }\n\n  /**\n   * Ensures that the model has an own-property map of effects for the given type.\n   * The model may be a prototype or an instance.\n   *\n   * Property effects are stored as arrays of effects by property in a map,\n   * by named type on the model. e.g.\n   *\n   *   __computeEffects: {\n   *     foo: [ ... ],\n   *     bar: [ ... ]\n   *   }\n   *\n   * If the model does not yet have an effect map for the type, one is created\n   * and returned.  If it does, but it is not an own property (i.e. the\n   * prototype had effects), the the map is deeply cloned and the copy is\n   * set on the model and returned, ready for new effects to be added.\n   *\n   * @param {Object} model Prototype or instance\n   * @param {string} type Property effect type\n   * @return {Object} The own-property map of effects for the given type\n   * @private\n   */\n  function ensureOwnEffectMap(model, type) {\n    let effects = model[type];\n    if (!effects) {\n      effects = model[type] = {};\n    } else if (!model.hasOwnProperty(type)) {\n      effects = model[type] = Object.create(model[type]);\n      for (let p in effects) {\n        let protoFx = effects[p];\n        let instFx = effects[p] = Array(protoFx.length);\n        for (let i=0; i<protoFx.length; i++) {\n          instFx[i] = protoFx[i];\n        }\n      }\n    }\n    return effects;\n  }\n\n  // -- effects ----------------------------------------------\n\n  /**\n   * Runs all effects of a given type for the given set of property changes\n   * on an instance.\n   *\n   * @param {Object} inst The instance with effects to run\n   * @param {Object} effects Object map of property-to-Array of effects\n   * @param {Object} props Bag of current property changes\n   * @param {Object=} oldProps Bag of previous values for changed properties\n   * @param {boolean=} hasPaths True with `props` contains one or more paths\n   * @param {*=} extraArgs Additional metadata to pass to effect function\n   * @return {boolean} True if an effect ran for this property\n   * @private\n   */\n  function runEffects(inst, effects, props, oldProps, hasPaths, extraArgs) {\n    if (effects) {\n      let ran = false;\n      let id = dedupeId++;\n      for (let prop in props) {\n        if (runEffectsForProperty(inst, effects, id, prop, props, oldProps, hasPaths, extraArgs)) {\n          ran = true;\n        }\n      }\n      return ran;\n    }\n    return false;\n  }\n\n  /**\n   * Runs a list of effects for a given property.\n   *\n   * @param {Object} inst The instance with effects to run\n   * @param {Object} effects Object map of property-to-Array of effects\n   * @param {number} dedupeId Counter used for de-duping effects\n   * @param {string} prop Name of changed property\n   * @param {*} props Changed properties\n   * @param {*} oldProps Old properties\n   * @param {boolean=} hasPaths True with `props` contains one or more paths\n   * @param {*=} extraArgs Additional metadata to pass to effect function\n   * @return {boolean} True if an effect ran for this property\n   * @private\n   */\n  function runEffectsForProperty(inst, effects, dedupeId, prop, props, oldProps, hasPaths, extraArgs) {\n    let ran = false;\n    let rootProperty = hasPaths ? Polymer.Path.root(prop) : prop;\n    let fxs = effects[rootProperty];\n    if (fxs) {\n      for (let i=0, l=fxs.length, fx; (i<l) && (fx=fxs[i]); i++) {\n        if ((!fx.info || fx.info.lastRun !== dedupeId) &&\n            (!hasPaths || pathMatchesTrigger(prop, fx.trigger))) {\n          if (fx.info) {\n            fx.info.lastRun = dedupeId;\n          }\n          fx.fn(inst, prop, props, oldProps, fx.info, hasPaths, extraArgs);\n          ran = true;\n        }\n      }\n    }\n    return ran;\n  }\n\n  /**\n   * Determines whether a property/path that has changed matches the trigger\n   * criteria for an effect.  A trigger is a descriptor with the following\n   * structure, which matches the descriptors returned from `parseArg`.\n   * e.g. for `foo.bar.*`:\n   * ```\n   * trigger: {\n   *   name: 'a.b',\n   *   structured: true,\n   *   wildcard: true\n   * }\n   * ```\n   * If no trigger is given, the path is deemed to match.\n   *\n   * @param {string} path Path or property that changed\n   * @param {Object} trigger Descriptor\n   * @return {boolean} Whether the path matched the trigger\n   */\n  function pathMatchesTrigger(path, trigger) {\n    if (trigger) {\n      let triggerPath = trigger.name;\n      return (triggerPath == path) ||\n        (trigger.structured && Polymer.Path.isAncestor(triggerPath, path)) ||\n        (trigger.wildcard && Polymer.Path.isDescendant(triggerPath, path));\n    } else {\n      return true;\n    }\n  }\n\n  /**\n   * Implements the \"observer\" effect.\n   *\n   * Calls the method with `info.methodName` on the instance, passing the\n   * new and old values.\n   *\n   * @param {Object} inst The instance the effect will be run on\n   * @param {string} property Name of property\n   * @param {Object} props Bag of current property changes\n   * @param {Object} oldProps Bag of previous values for changed properties\n   * @param {Object} info Effect metadata\n   * @private\n   */\n  function runObserverEffect(inst, property, props, oldProps, info) {\n    let fn = inst[info.methodName];\n    let changedProp = info.property;\n    if (fn) {\n      fn.call(inst, inst.__data[changedProp], oldProps[changedProp]);\n    } else if (!info.dynamicFn) {\n      console.warn('observer method `' + info.methodName + '` not defined');\n    }\n  }\n\n  /**\n   * Runs \"notify\" effects for a set of changed properties.\n   *\n   * This method differs from the generic `runEffects` method in that it\n   * will dispatch path notification events in the case that the property\n   * changed was a path and the root property for that path didn't have a\n   * \"notify\" effect.  This is to maintain 1.0 behavior that did not require\n   * `notify: true` to ensure object sub-property notifications were\n   * sent.\n   *\n   * @param {Element} inst The instance with effects to run\n   * @param {Object} notifyProps Bag of properties to notify\n   * @param {Object} props Bag of current property changes\n   * @param {Object} oldProps Bag of previous values for changed properties\n   * @param {boolean} hasPaths True with `props` contains one or more paths\n   * @private\n   */\n  function runNotifyEffects(inst, notifyProps, props, oldProps, hasPaths) {\n    // Notify\n    let fxs = inst.__notifyEffects;\n    let notified;\n    let id = dedupeId++;\n    // Try normal notify effects; if none, fall back to try path notification\n    for (let prop in notifyProps) {\n      if (notifyProps[prop]) {\n        if (fxs && runEffectsForProperty(inst, fxs, id, prop, props, oldProps, hasPaths)) {\n          notified = true;\n        } else if (hasPaths && notifyPath(inst, prop, props)) {\n          notified = true;\n        }\n      }\n    }\n    // Flush host if we actually notified and host was batching\n    // And the host has already initialized clients; this prevents\n    // an issue with a host observing data changes before clients are ready.\n    let host;\n    if (notified && (host = inst.__dataHost) && host._invalidateProperties) {\n      host._invalidateProperties();\n    }\n  }\n\n  /**\n   * Dispatches {property}-changed events with path information in the detail\n   * object to indicate a sub-path of the property was changed.\n   *\n   * @param {Element} inst The element from which to fire the event\n   * @param {string} path The path that was changed\n   * @param {Object} props Bag of current property changes\n   * @return {boolean} Returns true if the path was notified\n   * @private\n   */\n  function notifyPath(inst, path, props) {\n    let rootProperty = Polymer.Path.root(path);\n    if (rootProperty !== path) {\n      let eventName = Polymer.CaseMap.camelToDashCase(rootProperty) + '-changed';\n      dispatchNotifyEvent(inst, eventName, props[path], path);\n      return true;\n    }\n  }\n\n  /**\n   * Dispatches {property}-changed events to indicate a property (or path)\n   * changed.\n   *\n   * @param {Element} inst The element from which to fire the event\n   * @param {string} eventName The name of the event to send ('{property}-changed')\n   * @param {*} value The value of the changed property\n   * @param {string | null | undefined} path If a sub-path of this property changed, the path\n   *   that changed (optional).\n   * @private\n   */\n  function dispatchNotifyEvent(inst, eventName, value, path) {\n    let detail = {\n      value: value,\n      queueProperty: true\n    };\n    if (path) {\n      detail.path = path;\n    }\n    inst.dispatchEvent(new CustomEvent(eventName, { detail }));\n  }\n\n  /**\n   * Implements the \"notify\" effect.\n   *\n   * Dispatches a non-bubbling event named `info.eventName` on the instance\n   * with a detail object containing the new `value`.\n   *\n   * @param {Element} inst The instance the effect will be run on\n   * @param {string} property Name of property\n   * @param {Object} props Bag of current property changes\n   * @param {Object} oldProps Bag of previous values for changed properties\n   * @param {Object} info Effect metadata\n   * @param {boolean} hasPaths True with `props` contains one or more paths\n   * @private\n   */\n  function runNotifyEffect(inst, property, props, oldProps, info, hasPaths) {\n    let rootProperty = hasPaths ? Polymer.Path.root(property) : property;\n    let path = rootProperty != property ? property : null;\n    let value = path ? Polymer.Path.get(inst, path) : inst.__data[property];\n    if (path && value === undefined) {\n      value = props[property];  // specifically for .splices\n    }\n    dispatchNotifyEvent(inst, info.eventName, value, path);\n  }\n\n  /**\n   * Handler function for 2-way notification events. Receives context\n   * information captured in the `addNotifyListener` closure from the\n   * `__notifyListeners` metadata.\n   *\n   * Sets the value of the notified property to the host property or path.  If\n   * the event contained path information, translate that path to the host\n   * scope's name for that path first.\n   *\n   * @param {Event} event Notification event (e.g. '<property>-changed')\n   * @param {Object} inst Host element instance handling the notification event\n   * @param {string} fromProp Child element property that was bound\n   * @param {string} toPath Host property/path that was bound\n   * @param {boolean} negate Whether the binding was negated\n   * @private\n   */\n  function handleNotification(event, inst, fromProp, toPath, negate) {\n    let value;\n    let detail = event.detail;\n    let fromPath = detail && detail.path;\n    if (fromPath) {\n      toPath = Polymer.Path.translate(fromProp, toPath, fromPath);\n      value = detail && detail.value;\n    } else {\n      value = event.target[fromProp];\n    }\n    value = negate ? !value : value;\n    if (!inst.__readOnly || !inst.__readOnly[toPath]) {\n      if (inst._setPendingPropertyOrPath(toPath, value, true, Boolean(fromPath))\n        && (!detail || !detail.queueProperty)) {\n        inst._invalidateProperties();\n      }\n    }\n  }\n\n  /**\n   * Implements the \"reflect\" effect.\n   *\n   * Sets the attribute named `info.attrName` to the given property value.\n   *\n   * @param {Object} inst The instance the effect will be run on\n   * @param {string} property Name of property\n   * @param {Object} props Bag of current property changes\n   * @param {Object} oldProps Bag of previous values for changed properties\n   * @param {Object} info Effect metadata\n   * @private\n   */\n  function runReflectEffect(inst, property, props, oldProps, info) {\n    let value = inst.__data[property];\n    if (Polymer.sanitizeDOMValue) {\n      value = Polymer.sanitizeDOMValue(value, info.attrName, 'attribute', inst);\n    }\n    inst._propertyToAttribute(property, info.attrName, value);\n  }\n\n  /**\n   * Runs \"computed\" effects for a set of changed properties.\n   *\n   * This method differs from the generic `runEffects` method in that it\n   * continues to run computed effects based on the output of each pass until\n   * there are no more newly computed properties.  This ensures that all\n   * properties that will be computed by the initial set of changes are\n   * computed before other effects (binding propagation, observers, and notify)\n   * run.\n   *\n   * @param {Element} inst The instance the effect will be run on\n   * @param {Object} changedProps Bag of changed properties\n   * @param {Object} oldProps Bag of previous values for changed properties\n   * @param {boolean} hasPaths True with `props` contains one or more paths\n   * @private\n   */\n  function runComputedEffects(inst, changedProps, oldProps, hasPaths) {\n    let computeEffects = inst.__computeEffects;\n    if (computeEffects) {\n      let inputProps = changedProps;\n      while (runEffects(inst, computeEffects, inputProps, oldProps, hasPaths)) {\n        Object.assign(oldProps, inst.__dataOld);\n        Object.assign(changedProps, inst.__dataPending);\n        inputProps = inst.__dataPending;\n        inst.__dataPending = null;\n      }\n    }\n  }\n\n  /**\n   * Implements the \"computed property\" effect by running the method with the\n   * values of the arguments specified in the `info` object and setting the\n   * return value to the computed property specified.\n   *\n   * @param {Object} inst The instance the effect will be run on\n   * @param {string} property Name of property\n   * @param {Object} props Bag of current property changes\n   * @param {Object} oldProps Bag of previous values for changed properties\n   * @param {Object} info Effect metadata\n   * @private\n   */\n  function runComputedEffect(inst, property, props, oldProps, info) {\n    let result = runMethodEffect(inst, property, props, oldProps, info);\n    let computedProp = info.methodInfo;\n    if (inst.__dataHasAccessor && inst.__dataHasAccessor[computedProp]) {\n      inst._setPendingProperty(computedProp, result, true);\n    } else {\n      inst[computedProp] = result;\n    }\n  }\n\n  /**\n   * Computes path changes based on path links set up using the `linkPaths`\n   * API.\n   *\n   * @param {Element} inst The instance whose props are changing\n   * @param {string} path Path that has changed\n   * @param {*} value Value of changed path\n   * @private\n   */\n  function computeLinkedPaths(inst, path, value) {\n    let links = inst.__dataLinkedPaths;\n    if (links) {\n      let link;\n      for (let a in links) {\n        let b = links[a];\n        if (Polymer.Path.isDescendant(a, path)) {\n          link = Polymer.Path.translate(a, b, path);\n          inst._setPendingPropertyOrPath(link, value, true, true);\n        } else if (Polymer.Path.isDescendant(b, path)) {\n          link = Polymer.Path.translate(b, a, path);\n          inst._setPendingPropertyOrPath(link, value, true, true);\n        }\n      }\n    }\n  }\n\n  // -- bindings ----------------------------------------------\n\n  /**\n   * Adds binding metadata to the current `nodeInfo`, and binding effects\n   * for all part dependencies to `templateInfo`.\n   *\n   * @param {Function} constructor Class that `_parseTemplate` is currently\n   *   running on\n   * @param {Object} templateInfo Template metadata for current template\n   * @param {Object} nodeInfo Node metadata for current template node\n   * @param {string} kind Binding kind, either 'property', 'attribute', or 'text'\n   * @param {string} target Target property name\n   * @param {Array<Object>} parts Array of binding part metadata\n   * @param {string} literal Literal text surrounding binding parts (specified\n   *   only for 'property' bindings, since these must be initialized as part\n   *   of boot-up)\n   * @private\n   */\n  function addBinding(constructor, templateInfo, nodeInfo, kind, target, parts, literal) {\n    // Create binding metadata and add to nodeInfo\n    nodeInfo.bindings = nodeInfo.bindings || [];\n    let binding = { kind, target, parts, literal, isCompound: (parts.length !== 1) };\n    nodeInfo.bindings.push(binding);\n    // Add listener info to binding metadata\n    if (shouldAddListener(binding)) {\n      let {event, negate} = binding.parts[0];\n      binding.listenerEvent = event || (CaseMap.camelToDashCase(target) + '-changed');\n      binding.listenerNegate = negate;\n    }\n    // Add \"propagate\" property effects to templateInfo\n    let index = templateInfo.nodeInfoList.length;\n    for (let i=0; i<binding.parts.length; i++) {\n      let part = binding.parts[i];\n      part.compoundIndex = i;\n      addEffectForBindingPart(constructor, templateInfo, binding, part, index);\n    }\n  }\n\n  /**\n   * Adds property effects to the given `templateInfo` for the given binding\n   * part.\n   *\n   * @param {Function} constructor Class that `_parseTemplate` is currently\n   *   running on\n   * @param {Object} templateInfo Template metadata for current template\n   * @param {Object} binding Binding metadata\n   * @param {Object} part Binding part metadata\n   * @param {number} index Index into `nodeInfoList` for this node\n   */\n  function addEffectForBindingPart(constructor, templateInfo, binding, part, index) {\n    if (!part.literal) {\n      if (binding.kind === 'attribute' && binding.target[0] === '-') {\n        console.warn('Cannot set attribute ' + binding.target +\n          ' because \"-\" is not a valid attribute starting character');\n      } else {\n        let dependencies = part.dependencies;\n        let info = { index, binding, part, evaluator: constructor };\n        for (let j=0; j<dependencies.length; j++) {\n          let trigger = dependencies[j];\n          if (typeof trigger == 'string') {\n            trigger = parseArg(trigger);\n            trigger.wildcard = true;\n          }\n          constructor._addTemplatePropertyEffect(templateInfo, trigger.rootProperty, {\n            fn: runBindingEffect,\n            info, trigger\n          });\n        }\n      }\n    }\n  }\n\n  /**\n   * Implements the \"binding\" (property/path binding) effect.\n   *\n   * Note that binding syntax is overridable via `_parseBindings` and\n   * `_evaluateBinding`.  This method will call `_evaluateBinding` for any\n   * non-literal parts returned from `_parseBindings`.  However,\n   * there is no support for _path_ bindings via custom binding parts,\n   * as this is specific to Polymer's path binding syntax.\n   *\n   * @param {Element} inst The instance the effect will be run on\n   * @param {string} path Name of property\n   * @param {Object} props Bag of current property changes\n   * @param {Object} oldProps Bag of previous values for changed properties\n   * @param {Object} info Effect metadata\n   * @param {boolean} hasPaths True with `props` contains one or more paths\n   * @param {Array} nodeList List of nodes associated with `nodeInfoList` template\n   *   metadata\n   * @private\n   */\n  function runBindingEffect(inst, path, props, oldProps, info, hasPaths, nodeList) {\n    let node = nodeList[info.index];\n    let binding = info.binding;\n    let part = info.part;\n    // Subpath notification: transform path and set to client\n    // e.g.: foo=\"{{obj.sub}}\", path: 'obj.sub.prop', set 'foo.prop'=obj.sub.prop\n    if (hasPaths && part.source && (path.length > part.source.length) &&\n        (binding.kind == 'property') && !binding.isCompound &&\n        node.__dataHasAccessor && node.__dataHasAccessor[binding.target]) {\n      let value = props[path];\n      path = Polymer.Path.translate(part.source, binding.target, path);\n      if (node._setPendingPropertyOrPath(path, value, false, true)) {\n        inst._enqueueClient(node);\n      }\n    } else {\n      let value = info.evaluator._evaluateBinding(inst, part, path, props, oldProps, hasPaths);\n      // Propagate value to child\n      applyBindingValue(inst, node, binding, part, value);\n    }\n  }\n\n  /**\n   * Sets the value for an \"binding\" (binding) effect to a node,\n   * either as a property or attribute.\n   *\n   * @param {Object} inst The instance owning the binding effect\n   * @param {Node} node Target node for binding\n   * @param {Object} binding Binding metadata\n   * @param {Object} part Binding part metadata\n   * @param {*} value Value to set\n   * @private\n   */\n  function applyBindingValue(inst, node, binding, part, value) {\n    value = computeBindingValue(node, value, binding, part);\n    if (Polymer.sanitizeDOMValue) {\n      value = Polymer.sanitizeDOMValue(value, binding.target, binding.kind, node);\n    }\n    if (binding.kind == 'attribute') {\n      // Attribute binding\n      inst._valueToNodeAttribute(node, value, binding.target);\n    } else {\n      // Property binding\n      let prop = binding.target;\n      if (node.__dataHasAccessor && node.__dataHasAccessor[prop]) {\n        if (!node.__readOnly || !node.__readOnly[prop]) {\n          if (node._setPendingProperty(prop, value)) {\n            inst._enqueueClient(node);\n          }\n        }\n      } else  {\n        inst._setUnmanagedPropertyToNode(node, prop, value);\n      }\n    }\n  }\n\n  /**\n   * Transforms an \"binding\" effect value based on compound & negation\n   * effect metadata, as well as handling for special-case properties\n   *\n   * @param {Node} node Node the value will be set to\n   * @param {*} value Value to set\n   * @param {Object} binding Binding metadata\n   * @param {Object} part Binding part metadata\n   * @return {*} Transformed value to set\n   * @private\n   */\n  function computeBindingValue(node, value, binding, part) {\n    if (binding.isCompound) {\n      let storage = node.__dataCompoundStorage[binding.target];\n      storage[part.compoundIndex] = value;\n      value = storage.join('');\n    }\n    if (binding.kind !== 'attribute') {\n      // Some browsers serialize `undefined` to `\"undefined\"`\n      if (binding.target === 'textContent' ||\n          (node.localName == 'input' && binding.target == 'value')) {\n        value = value == undefined ? '' : value;\n      }\n    }\n    return value;\n  }\n\n  /**\n   * Returns true if a binding's metadata meets all the requirements to allow\n   * 2-way binding, and therefore a `<property>-changed` event listener should be\n   * added:\n   * - used curly braces\n   * - is a property (not attribute) binding\n   * - is not a textContent binding\n   * - is not compound\n   *\n   * @param {Object} binding Binding metadata\n   * @return {boolean} True if 2-way listener should be added\n   * @private\n   */\n  function shouldAddListener(binding) {\n    return binding.target &&\n           binding.kind != 'attribute' &&\n           binding.kind != 'text' &&\n           !binding.isCompound &&\n           binding.parts[0].mode === '{';\n  }\n\n  /**\n   * Setup compound binding storage structures, notify listeners, and dataHost\n   * references onto the bound nodeList.\n   *\n   * @param {Object} inst Instance that bas been previously bound\n   * @param {Object} templateInfo Template metadata\n   * @private\n   */\n  function setupBindings(inst, templateInfo) {\n    // Setup compound storage, dataHost, and notify listeners\n    let {nodeList, nodeInfoList} = templateInfo;\n    if (nodeInfoList.length) {\n      for (let i=0; i < nodeInfoList.length; i++) {\n        let info = nodeInfoList[i];\n        let node = nodeList[i];\n        let bindings = info.bindings;\n        if (bindings) {\n          for (let i=0; i<bindings.length; i++) {\n            let binding = bindings[i];\n            setupCompoundStorage(node, binding);\n            addNotifyListener(node, inst, binding);\n          }\n        }\n        node.__dataHost = inst;\n      }\n    }\n  }\n\n  /**\n   * Initializes `__dataCompoundStorage` local storage on a bound node with\n   * initial literal data for compound bindings, and sets the joined\n   * literal parts to the bound property.\n   *\n   * When changes to compound parts occur, they are first set into the compound\n   * storage array for that property, and then the array is joined to result in\n   * the final value set to the property/attribute.\n   *\n   * @param {Node} node Bound node to initialize\n   * @param {Object} binding Binding metadata\n   * @private\n   */\n  function setupCompoundStorage(node, binding) {\n    if (binding.isCompound) {\n      // Create compound storage map\n      let storage = node.__dataCompoundStorage ||\n        (node.__dataCompoundStorage = {});\n      let parts = binding.parts;\n      // Copy literals from parts into storage for this binding\n      let literals = new Array(parts.length);\n      for (let j=0; j<parts.length; j++) {\n        literals[j] = parts[j].literal;\n      }\n      let target = binding.target;\n      storage[target] = literals;\n      // Configure properties with their literal parts\n      if (binding.literal && binding.kind == 'property') {\n        node[target] = binding.literal;\n      }\n    }\n  }\n\n  /**\n   * Adds a 2-way binding notification event listener to the node specified\n   *\n   * @param {Object} node Child element to add listener to\n   * @param {Object} inst Host element instance to handle notification event\n   * @param {Object} binding Binding metadata\n   * @private\n   */\n  function addNotifyListener(node, inst, binding) {\n    if (binding.listenerEvent) {\n      let part = binding.parts[0];\n      node.addEventListener(binding.listenerEvent, function(e) {\n        handleNotification(e, inst, binding.target, part.source, part.negate);\n      });\n    }\n  }\n\n  // -- for method-based effects (complexObserver & computed) --------------\n\n  /**\n   * Adds property effects for each argument in the method signature (and\n   * optionally, for the method name if `dynamic` is true) that calls the\n   * provided effect function.\n   *\n   * @param {Element | Object} model Prototype or instance\n   * @param {Object} sig Method signature metadata\n   * @param {string} type Type of property effect to add\n   * @param {Function} effectFn Function to run when arguments change\n   * @param {*=} methodInfo Effect-specific information to be included in\n   *   method effect metadata\n   * @param {boolean|Object=} dynamicFn Boolean or object map indicating whether\n   *   method names should be included as a dependency to the effect. Note,\n   *   defaults to true if the signature is static (sig.static is true).\n   * @private\n   */\n  function createMethodEffect(model, sig, type, effectFn, methodInfo, dynamicFn) {\n    dynamicFn = sig.static || (dynamicFn &&\n      (typeof dynamicFn !== 'object' || dynamicFn[sig.methodName]));\n    let info = {\n      methodName: sig.methodName,\n      args: sig.args,\n      methodInfo,\n      dynamicFn\n    };\n    for (let i=0, arg; (i<sig.args.length) && (arg=sig.args[i]); i++) {\n      if (!arg.literal) {\n        model._addPropertyEffect(arg.rootProperty, type, {\n          fn: effectFn, info: info, trigger: arg\n        });\n      }\n    }\n    if (dynamicFn) {\n      model._addPropertyEffect(sig.methodName, type, {\n        fn: effectFn, info: info\n      });\n    }\n  }\n\n  /**\n   * Calls a method with arguments marshaled from properties on the instance\n   * based on the method signature contained in the effect metadata.\n   *\n   * Multi-property observers, computed properties, and inline computing\n   * functions call this function to invoke the method, then use the return\n   * value accordingly.\n   *\n   * @param {Object} inst The instance the effect will be run on\n   * @param {string} property Name of property\n   * @param {Object} props Bag of current property changes\n   * @param {Object} oldProps Bag of previous values for changed properties\n   * @param {Object} info Effect metadata\n   * @return {*} Returns the return value from the method invocation\n   * @private\n   */\n  function runMethodEffect(inst, property, props, oldProps, info) {\n    // Instances can optionally have a _methodHost which allows redirecting where\n    // to find methods. Currently used by `templatize`.\n    let context = inst._methodHost || inst;\n    let fn = context[info.methodName];\n    if (fn) {\n      let args = marshalArgs(inst.__data, info.args, property, props);\n      return fn.apply(context, args);\n    } else if (!info.dynamicFn) {\n      console.warn('method `' + info.methodName + '` not defined');\n    }\n  }\n\n  const emptyArray = [];\n\n  // Regular expressions used for binding\n  const IDENT  = '(?:' + '[a-zA-Z_$][\\\\w.:$\\\\-*]*' + ')';\n  const NUMBER = '(?:' + '[-+]?[0-9]*\\\\.?[0-9]+(?:[eE][-+]?[0-9]+)?' + ')';\n  const SQUOTE_STRING = '(?:' + '\\'(?:[^\\'\\\\\\\\]|\\\\\\\\.)*\\'' + ')';\n  const DQUOTE_STRING = '(?:' + '\"(?:[^\"\\\\\\\\]|\\\\\\\\.)*\"' + ')';\n  const STRING = '(?:' + SQUOTE_STRING + '|' + DQUOTE_STRING + ')';\n  const ARGUMENT = '(?:' + IDENT + '|' + NUMBER + '|' +  STRING + '\\\\s*' + ')';\n  const ARGUMENTS = '(?:' + ARGUMENT + '(?:,\\\\s*' + ARGUMENT + ')*' + ')';\n  const ARGUMENT_LIST = '(?:' + '\\\\(\\\\s*' +\n                                '(?:' + ARGUMENTS + '?' + ')' +\n                              '\\\\)\\\\s*' + ')';\n  const BINDING = '(' + IDENT + '\\\\s*' + ARGUMENT_LIST + '?' + ')'; // Group 3\n  const OPEN_BRACKET = '(\\\\[\\\\[|{{)' + '\\\\s*';\n  const CLOSE_BRACKET = '(?:]]|}})';\n  const NEGATE = '(?:(!)\\\\s*)?'; // Group 2\n  const EXPRESSION = OPEN_BRACKET + NEGATE + BINDING + CLOSE_BRACKET;\n  const bindingRegex = new RegExp(EXPRESSION, \"g\");\n\n  function literalFromParts(parts) {\n    let s = '';\n    for (let i=0; i<parts.length; i++) {\n      let literal = parts[i].literal;\n      s += literal || '';\n    }\n    return s;\n  }\n\n  /**\n   * Parses an expression string for a method signature, and returns a metadata\n   * describing the method in terms of `methodName`, `static` (whether all the\n   * arguments are literals), and an array of `args`\n   *\n   * @param {string} expression The expression to parse\n   * @return {?Object} The method metadata object if a method expression was\n   *   found, otherwise `undefined`\n   * @private\n   */\n  function parseMethod(expression) {\n    // tries to match valid javascript property names\n    let m = expression.match(/([^\\s]+?)\\(([\\s\\S]*)\\)/);\n    if (m) {\n      let methodName = m[1];\n      let sig = { methodName, static: true };\n      if (m[2].trim()) {\n        // replace escaped commas with comma entity, split on un-escaped commas\n        let args = m[2].replace(/\\\\,/g, '&comma;').split(',');\n        return parseArgs(args, sig);\n      } else {\n        sig.args = emptyArray;\n        return sig;\n      }\n    }\n    return null;\n  }\n\n  /**\n   * Parses an array of arguments and sets the `args` property of the supplied\n   * signature metadata object. Sets the `static` property to false if any\n   * argument is a non-literal.\n   *\n   * @param {Array<string>} argList Array of argument names\n   * @param {Object} sig Method signature metadata object\n   * @return {Object} The updated signature metadata object\n   * @private\n   */\n  function parseArgs(argList, sig) {\n    sig.args = argList.map(function(rawArg) {\n      let arg = parseArg(rawArg);\n      if (!arg.literal) {\n        sig.static = false;\n      }\n      return arg;\n    }, this);\n    return sig;\n  }\n\n  /**\n   * Parses an individual argument, and returns an argument metadata object\n   * with the following fields:\n   *\n   *   {\n   *     value: 'prop',        // property/path or literal value\n   *     literal: false,       // whether argument is a literal\n   *     structured: false,    // whether the property is a path\n   *     rootProperty: 'prop', // the root property of the path\n   *     wildcard: false       // whether the argument was a wildcard '.*' path\n   *   }\n   *\n   * @param {string} rawArg The string value of the argument\n   * @return {Object} Argument metadata object\n   * @private\n   */\n  function parseArg(rawArg) {\n    // clean up whitespace\n    let arg = rawArg.trim()\n      // replace comma entity with comma\n      .replace(/&comma;/g, ',')\n      // repair extra escape sequences; note only commas strictly need\n      // escaping, but we allow any other char to be escaped since its\n      // likely users will do this\n      .replace(/\\\\(.)/g, '\\$1')\n      ;\n    // basic argument descriptor\n    let a = {\n      name: arg\n    };\n    // detect literal value (must be String or Number)\n    let fc = arg[0];\n    if (fc === '-') {\n      fc = arg[1];\n    }\n    if (fc >= '0' && fc <= '9') {\n      fc = '#';\n    }\n    switch(fc) {\n      case \"'\":\n      case '\"':\n        a.value = arg.slice(1, -1);\n        a.literal = true;\n        break;\n      case '#':\n        a.value = Number(arg);\n        a.literal = true;\n        break;\n    }\n    // if not literal, look for structured path\n    if (!a.literal) {\n      a.rootProperty = Polymer.Path.root(arg);\n      // detect structured path (has dots)\n      a.structured = Polymer.Path.isPath(arg);\n      if (a.structured) {\n        a.wildcard = (arg.slice(-2) == '.*');\n        if (a.wildcard) {\n          a.name = arg.slice(0, -2);\n        }\n      }\n    }\n    return a;\n  }\n\n  /**\n   * Gather the argument values for a method specified in the provided array\n   * of argument metadata.\n   *\n   * The `path` and `value` arguments are used to fill in wildcard descriptor\n   * when the method is being called as a result of a path notification.\n   *\n   * @param {Object} data Instance data storage object to read properties from\n   * @param {Array<Object>} args Array of argument metadata\n   * @param {string} path Property/path name that triggered the method effect\n   * @param {Object} props Bag of current property changes\n   * @return {Array<*>} Array of argument values\n   * @private\n   */\n  function marshalArgs(data, args, path, props) {\n    let values = [];\n    for (let i=0, l=args.length; i<l; i++) {\n      let arg = args[i];\n      let name = arg.name;\n      let v;\n      if (arg.literal) {\n        v = arg.value;\n      } else {\n        if (arg.structured) {\n          v = Polymer.Path.get(data, name);\n          // when data is not stored e.g. `splices`\n          if (v === undefined) {\n            v = props[name];\n          }\n        } else {\n          v = data[name];\n        }\n      }\n      if (arg.wildcard) {\n        // Only send the actual path changed info if the change that\n        // caused the observer to run matched the wildcard\n        let baseChanged = (name.indexOf(path + '.') === 0);\n        let matches = (path.indexOf(name) === 0 && !baseChanged);\n        values[i] = {\n          path: matches ? path : name,\n          value: matches ? props[path] : v,\n          base: v\n        };\n      } else {\n        values[i] = v;\n      }\n    }\n    return values;\n  }\n\n  // data api\n\n  /**\n   * Sends array splice notifications (`.splices` and `.length`)\n   *\n   * Note: this implementation only accepts normalized paths\n   *\n   * @param {Element} inst Instance to send notifications to\n   * @param {Array} array The array the mutations occurred on\n   * @param {string} path The path to the array that was mutated\n   * @param {Array} splices Array of splice records\n   * @private\n   */\n  function notifySplices(inst, array, path, splices) {\n    let splicesPath = path + '.splices';\n    inst.notifyPath(splicesPath, { indexSplices: splices });\n    inst.notifyPath(path + '.length', array.length);\n    // Null here to allow potentially large splice records to be GC'ed.\n    inst.__data[splicesPath] = {indexSplices: null};\n  }\n\n  /**\n   * Creates a splice record and sends an array splice notification for\n   * the described mutation\n   *\n   * Note: this implementation only accepts normalized paths\n   *\n   * @param {Element} inst Instance to send notifications to\n   * @param {Array} array The array the mutations occurred on\n   * @param {string} path The path to the array that was mutated\n   * @param {number} index Index at which the array mutation occurred\n   * @param {number} addedCount Number of added items\n   * @param {Array} removed Array of removed items\n   * @private\n   */\n  function notifySplice(inst, array, path, index, addedCount, removed) {\n    notifySplices(inst, array, path, [{\n      index: index,\n      addedCount: addedCount,\n      removed: removed,\n      object: array,\n      type: 'splice'\n    }]);\n  }\n\n  /**\n   * Returns an upper-cased version of the string.\n   *\n   * @param {string} name String to uppercase\n   * @return {string} Uppercased string\n   * @private\n   */\n  function upper(name) {\n    return name[0].toUpperCase() + name.substring(1);\n  }\n\n  /**\n   * Element class mixin that provides meta-programming for Polymer's template\n   * binding and data observation (collectively, \"property effects\") system.\n   *\n   * This mixin uses provides the following key static methods for adding\n   * property effects to an element class:\n   * - `addPropertyEffect`\n   * - `createPropertyObserver`\n   * - `createMethodObserver`\n   * - `createNotifyingProperty`\n   * - `createReadOnlyProperty`\n   * - `createReflectedProperty`\n   * - `createComputedProperty`\n   * - `bindTemplate`\n   *\n   * Each method creates one or more property accessors, along with metadata\n   * used by this mixin's implementation of `_propertiesChanged` to perform\n   * the property effects.\n   *\n   * Underscored versions of the above methods also exist on the element\n   * prototype for adding property effects on instances at runtime.\n   *\n   * Note that this mixin overrides several `PropertyAccessors` methods, in\n   * many cases to maintain guarantees provided by the Polymer 1.x features;\n   * notably it changes property accessors to be synchronous by default\n   * whereas the default when using `PropertyAccessors` standalone is to be\n   * async by default.\n   *\n   * @polymerMixin\n   * @mixes Polymer.TemplateStamp\n   * @mixes Polymer.PropertyAccessors\n   * @memberof Polymer\n   * @summary Element class mixin that provides meta-programming for Polymer's\n   * template binding and data observation system.\n   */\n  Polymer.PropertyEffects = Polymer.dedupingMixin(superClass => {\n\n    /**\n     * @constructor\n     * @extends {superClass}\n     * @implements {Polymer_PropertyAccessors}\n     * @implements {Polymer_TemplateStamp}\n     */\n    const propertyEffectsBase = Polymer.TemplateStamp(Polymer.PropertyAccessors(superClass));\n\n    /**\n     * @polymerMixinClass\n     * @unrestricted\n     * @implements {Polymer_PropertyEffects}\n     */\n    class PropertyEffects extends propertyEffectsBase {\n\n      get PROPERTY_EFFECT_TYPES() {\n        return TYPES;\n      }\n\n      /**\n       * Overrides `Polymer.PropertyAccessors` implementation to initialize\n       * additional property-effect related properties.\n       *\n       * @override\n       */\n      _initializeProperties() {\n        super._initializeProperties();\n        hostStack.registerHost(this);\n        this.__dataClientsReady = false;\n        this.__dataPendingClients = null;\n        this.__dataToNotify = null;\n        this.__dataLinkedPaths = null;\n        this.__dataHasPaths = false;\n        // May be set on instance prior to upgrade\n        this.__dataCompoundStorage = this.__dataCompoundStorage || null;\n        this.__dataHost = this.__dataHost || null;\n        this.__dataTemp = {};\n      }\n\n      /**\n       * Overrides `Polymer.PropertyAccessors` implementation to provide a\n       * more efficient implementation of initializing properties from\n       * the prototype on the instance.\n       *\n       * @override\n       */\n      _initializeProtoProperties(props) {\n        this.__data = Object.create(props);\n        this.__dataPending = Object.create(props);\n        this.__dataOld = {};\n      }\n\n      /**\n       * Overrides `Polymer.PropertyAccessors` implementation to avoid setting\n       * `_setProperty`'s `shouldNotify: true`.\n       *\n       * @override\n       */\n      _initializeInstanceProperties(props) {\n        let readOnly = this.__readOnly;\n        for (let prop in props) {\n          if (!readOnly || !readOnly[prop]) {\n            this.__dataPending = this.__dataPending || {};\n            this.__dataOld = this.__dataOld || {};\n            this.__data[prop] = this.__dataPending[prop] = props[prop];\n          }\n        }\n      }\n\n      // Prototype setup ----------------------------------------\n\n      /**\n       * Equivalent to static `addPropertyEffect` API but can be called on\n       * an instance to add effects at runtime.  See that method for\n       * full API docs.\n       *\n       * @param {string} property Property that should trigger the effect\n       * @param {string} type Effect type, from this.PROPERTY_EFFECT_TYPES\n       * @param {Object=} effect Effect metadata object\n       * @protected\n       */\n      _addPropertyEffect(property, type, effect) {\n        this._createPropertyAccessor(property, type == TYPES.READ_ONLY);\n        // effects are accumulated into arrays per property based on type\n        let effects = ensureOwnEffectMap(this, type)[property];\n        if (!effects) {\n          effects = this[type][property] = [];\n        }\n        effects.push(effect);\n      }\n\n      /**\n       * Removes the given property effect.\n       *\n       * @param {string} property Property the effect was associated with\n       * @param {string} type Effect type, from this.PROPERTY_EFFECT_TYPES\n       * @param {Object=} effect Effect metadata object to remove\n       */\n      _removePropertyEffect(property, type, effect) {\n        let effects = ensureOwnEffectMap(this, type)[property];\n        let idx = effects.indexOf(effect);\n        if (idx >= 0) {\n          effects.splice(idx, 1);\n        }\n      }\n\n      /**\n       * Returns whether the current prototype/instance has a property effect\n       * of a certain type.\n       *\n       * @param {string} property Property name\n       * @param {string=} type Effect type, from this.PROPERTY_EFFECT_TYPES\n       * @return {boolean} True if the prototype/instance has an effect of this type\n       * @protected\n       */\n      _hasPropertyEffect(property, type) {\n        let effects = this[type];\n        return Boolean(effects && effects[property]);\n      }\n\n      /**\n       * Returns whether the current prototype/instance has a \"read only\"\n       * accessor for the given property.\n       *\n       * @param {string} property Property name\n       * @return {boolean} True if the prototype/instance has an effect of this type\n       * @protected\n       */\n      _hasReadOnlyEffect(property) {\n        return this._hasPropertyEffect(property, TYPES.READ_ONLY);\n      }\n\n      /**\n       * Returns whether the current prototype/instance has a \"notify\"\n       * property effect for the given property.\n       *\n       * @param {string} property Property name\n       * @return {boolean} True if the prototype/instance has an effect of this type\n       * @protected\n       */\n      _hasNotifyEffect(property) {\n        return this._hasPropertyEffect(property, TYPES.NOTIFY);\n      }\n\n      /**\n       * Returns whether the current prototype/instance has a \"reflect to attribute\"\n       * property effect for the given property.\n       *\n       * @param {string} property Property name\n       * @return {boolean} True if the prototype/instance has an effect of this type\n       * @protected\n       */\n      _hasReflectEffect(property) {\n        return this._hasPropertyEffect(property, TYPES.REFLECT);\n      }\n\n      /**\n       * Returns whether the current prototype/instance has a \"computed\"\n       * property effect for the given property.\n       *\n       * @param {string} property Property name\n       * @return {boolean} True if the prototype/instance has an effect of this type\n       * @protected\n       */\n      _hasComputedEffect(property) {\n        return this._hasPropertyEffect(property, TYPES.COMPUTE);\n      }\n\n      // Runtime ----------------------------------------\n\n      /**\n       * Sets a pending property or path.  If the root property of the path in\n       * question had no accessor, the path is set, otherwise it is enqueued\n       * via `_setPendingProperty`.\n       *\n       * This function isolates relatively expensive functionality necessary\n       * for the public API (`set`, `setProperties`, `notifyPath`, and property\n       * change listeners via {{...}} bindings), such that it is only done\n       * when paths enter the system, and not at every propagation step.  It\n       * also sets a `__dataHasPaths` flag on the instance which is used to\n       * fast-path slower path-matching code in the property effects host paths.\n       *\n       * `path` can be a path string or array of path parts as accepted by the\n       * public API.\n       *\n       * @param {string | !Array<number|string>} path Path to set\n       * @param {*} value Value to set\n       * @param {boolean=} shouldNotify Set to true if this change should\n       *  cause a property notification event dispatch\n       * @param {boolean=} isPathNotification If the path being set is a path\n       *   notification of an already changed value, as opposed to a request\n       *   to set and notify the change.  In the latter `false` case, a dirty\n       *   check is performed and then the value is set to the path before\n       *   enqueuing the pending property change.\n       * @return {boolean} Returns true if the property/path was enqueued in\n       *   the pending changes bag.\n       * @protected\n       */\n      _setPendingPropertyOrPath(path, value, shouldNotify, isPathNotification) {\n        if (isPathNotification ||\n            Polymer.Path.root(Array.isArray(path) ? path[0] : path) !== path) {\n          // Dirty check changes being set to a path against the actual object,\n          // since this is the entry point for paths into the system; from here\n          // the only dirty checks are against the `__dataTemp` cache to prevent\n          // duplicate work in the same turn only. Note, if this was a notification\n          // of a change already set to a path (isPathNotification: true),\n          // we always let the change through and skip the `set` since it was\n          // already dirty checked at the point of entry and the underlying\n          // object has already been updated\n          if (!isPathNotification) {\n            let old = Polymer.Path.get(this, path);\n            path = /** @type {string} */ (Polymer.Path.set(this, path, value));\n            // Use property-accessor's simpler dirty check\n            if (!path || !super._shouldPropertyChange(path, value, old)) {\n              return false;\n            }\n          }\n          this.__dataHasPaths = true;\n          if (this._setPendingProperty(path, value, shouldNotify)) {\n            computeLinkedPaths(this, path, value);\n            return true;\n          }\n        } else {\n          if (this.__dataHasAccessor && this.__dataHasAccessor[path]) {\n            return this._setPendingProperty(path, value, shouldNotify);\n          } else {\n            this[path] = value;\n          }\n        }\n        return false;\n      }\n\n      /**\n       * Applies a value to a non-Polymer element/node's property.\n       *\n       * The implementation makes a best-effort at binding interop:\n       * Some native element properties have side-effects when\n       * re-setting the same value (e.g. setting `<input>.value` resets the\n       * cursor position), so we do a dirty-check before setting the value.\n       * However, for better interop with non-Polymer custom elements that\n       * accept objects, we explicitly re-set object changes coming from the\n       * Polymer world (which may include deep object changes without the\n       * top reference changing), erring on the side of providing more\n       * information.\n       *\n       * Users may override this method to provide alternate approaches.\n       *\n       * @param {Node} node The node to set a property on\n       * @param {string} prop The property to set\n       * @param {*} value The value to set\n       * @protected\n       */\n      _setUnmanagedPropertyToNode(node, prop, value) {\n        // It is a judgment call that resetting primitives is\n        // \"bad\" and resettings objects is also \"good\"; alternatively we could\n        // implement a whitelist of tag & property values that should never\n        // be reset (e.g. <input>.value && <select>.value)\n        if (value !== node[prop] || typeof value == 'object') {\n          node[prop] = value;\n        }\n      }\n\n      /**\n       * Overrides the `PropertyAccessors` implementation to introduce special\n       * dirty check logic depending on the property & value being set:\n       *\n       * 1. Any value set to a path (e.g. 'obj.prop': 42 or 'obj.prop': {...})\n       *    Stored in `__dataTemp`, dirty checked against `__dataTemp`\n       * 2. Object set to simple property (e.g. 'prop': {...})\n       *    Stored in `__dataTemp` and `__data`, dirty checked against\n       *    `__dataTemp` by default implementation of `_shouldPropertyChange`\n       * 3. Primitive value set to simple property (e.g. 'prop': 42)\n       *    Stored in `__data`, dirty checked against `__data`\n       *\n       * The dirty-check is important to prevent cycles due to two-way\n       * notification, but paths and objects are only dirty checked against any\n       * previous value set during this turn via a \"temporary cache\" that is\n       * cleared when the last `_propertiesChaged` exits. This is so:\n       * a. any cached array paths (e.g. 'array.3.prop') may be invalidated\n       *    due to array mutations like shift/unshift/splice; this is fine\n       *    since path changes are dirty-checked at user entry points like `set`\n       * b. dirty-checking for objects only lasts one turn to allow the user\n       *    to mutate the object in-place and re-set it with the same identity\n       *    and have all sub-properties re-propagated in a subsequent turn.\n       *\n       * The temp cache is not necessarily sufficient to prevent invalid array\n       * paths, since a splice can happen during the same turn (with pathological\n       * user code); we could introduce a \"fixup\" for temporarily cached array\n       * paths if needed: https://github.com/Polymer/polymer/issues/4227\n       *\n       * @override\n       */\n      _setPendingProperty(property, value, shouldNotify) {\n        let isPath = this.__dataHasPaths && Polymer.Path.isPath(property);\n        let prevProps = isPath ? this.__dataTemp : this.__data;\n        if (this._shouldPropertyChange(property, value, prevProps[property])) {\n          if (!this.__dataPending) {\n            this.__dataPending = {};\n            this.__dataOld = {};\n          }\n          // Ensure old is captured from the last turn\n          if (!(property in this.__dataOld)) {\n            this.__dataOld[property] = this.__data[property];\n          }\n          // Paths are stored in temporary cache (cleared at end of turn),\n          // which is used for dirty-checking, all others stored in __data\n          if (isPath) {\n            this.__dataTemp[property] = value;\n          } else {\n            this.__data[property] = value;\n          }\n          // All changes go into pending property bag, passed to _propertiesChanged\n          this.__dataPending[property] = value;\n          // Track properties that should notify separately\n          if (isPath || (this.__notifyEffects && this.__notifyEffects[property])) {\n            this.__dataToNotify = this.__dataToNotify || {};\n            this.__dataToNotify[property] = shouldNotify;\n          }\n          return true;\n        }\n      }\n\n      /**\n       * Overrides base implementation to ensure all accessors set `shouldNotify`\n       * to true, for per-property notification tracking.\n       *\n       * @override\n       */\n      _setProperty(property, value) {\n        if (this._setPendingProperty(property, value, true)) {\n          this._invalidateProperties();\n        }\n      }\n\n      /**\n       * Overrides `PropertyAccessor`'s default async queuing of\n       * `_propertiesChanged`: if `__dataReady` is false (has not yet been\n       * manually flushed), the function no-ops; otherwise flushes\n       * `_propertiesChanged` synchronously.\n       *\n       * @override\n       */\n      _invalidateProperties() {\n        if (this.__dataReady) {\n          this._flushProperties();\n        }\n      }\n\n      /**\n       * Enqueues the given client on a list of pending clients, whose\n       * pending property changes can later be flushed via a call to\n       * `_flushClients`.\n       *\n       * @param {Object} client PropertyEffects client to enqueue\n       * @protected\n       */\n      _enqueueClient(client) {\n        this.__dataPendingClients = this.__dataPendingClients || [];\n        if (client !== this) {\n          this.__dataPendingClients.push(client);\n        }\n      }\n\n      /**\n       * Flushes any clients previously enqueued via `_enqueueClient`, causing\n       * their `_flushProperties` method to run.\n       *\n       * @protected\n       */\n      _flushClients() {\n        if (!this.__dataClientsReady) {\n          this.__dataClientsReady = true;\n          this._readyClients();\n          // Override point where accessors are turned on; importantly,\n          // this is after clients have fully readied, providing a guarantee\n          // that any property effects occur only after all clients are ready.\n          this.__dataReady = true;\n        } else {\n          this.__enableOrFlushClients();\n        }\n      }\n\n      // NOTE: We ensure clients either enable or flush as appropriate. This\n      // handles two corner cases:\n      // (1) clients flush properly when connected/enabled before the host\n      // enables; e.g.\n      //   (a) Templatize stamps with no properties and does not flush and\n      //   (b) the instance is inserted into dom and\n      //   (c) then the instance flushes.\n      // (2) clients enable properly when not connected/enabled when the host\n      // flushes; e.g.\n      //   (a) a template is runtime stamped and not yet connected/enabled\n      //   (b) a host sets a property, causing stamped dom to flush\n      //   (c) the stamped dom enables.\n      __enableOrFlushClients() {\n        let clients = this.__dataPendingClients;\n        if (clients) {\n          this.__dataPendingClients = null;\n          for (let i=0; i < clients.length; i++) {\n            let client = clients[i];\n            if (!client.__dataEnabled) {\n              client._enableProperties();\n            } else if (client.__dataPending) {\n              client._flushProperties();\n            }\n          }\n        }\n      }\n\n      /**\n       * Perform any initial setup on client dom. Called before the first\n       * `_flushProperties` call on client dom and before any element\n       * observers are called.\n       *\n       * @protected\n       */\n      _readyClients() {\n        this.__enableOrFlushClients();\n      }\n\n      /**\n       * Sets a bag of property changes to this instance, and\n       * synchronously processes all effects of the properties as a batch.\n       *\n       * Property names must be simple properties, not paths.  Batched\n       * path propagation is not supported.\n       *\n       * @param {Object} props Bag of one or more key-value pairs whose key is\n       *   a property and value is the new value to set for that property.\n       * @param {boolean=} setReadOnly When true, any private values set in\n       *   `props` will be set. By default, `setProperties` will not set\n       *   `readOnly: true` root properties.\n       * @public\n       */\n      setProperties(props, setReadOnly) {\n        for (let path in props) {\n          if (setReadOnly || !this.__readOnly || !this.__readOnly[path]) {\n            //TODO(kschaaf): explicitly disallow paths in setProperty?\n            // wildcard observers currently only pass the first changed path\n            // in the `info` object, and you could do some odd things batching\n            // paths, e.g. {'foo.bar': {...}, 'foo': null}\n            this._setPendingPropertyOrPath(path, props[path], true);\n          }\n        }\n        this._invalidateProperties();\n      }\n\n      /**\n       * Overrides `PropertyAccessors` so that property accessor\n       * side effects are not enabled until after client dom is fully ready.\n       * Also calls `_flushClients` callback to ensure client dom is enabled\n       * that was not enabled as a result of flushing properties.\n       *\n       * @override\n       */\n      ready() {\n        // It is important that `super.ready()` is not called here as it\n        // immediately turns on accessors. Instead, we wait until `readyClients`\n        // to enable accessors to provide a guarantee that clients are ready\n        // before processing any accessors side effects.\n        this._flushProperties();\n        // If no data was pending, `_flushProperties` will not `flushClients`\n        // so ensure this is done.\n        if (!this.__dataClientsReady) {\n          this._flushClients();\n        }\n        // Before ready, client notifications do not trigger _flushProperties.\n        // Therefore a flush is necessary here if data has been set.\n        if (this.__dataPending) {\n          this._flushProperties();\n        }\n      }\n\n      /**\n       * Implements `PropertyAccessors`'s properties changed callback.\n       *\n       * Runs each class of effects for the batch of changed properties in\n       * a specific order (compute, propagate, reflect, observe, notify).\n       *\n       * @override\n       */\n      _propertiesChanged(currentProps, changedProps, oldProps) {\n        // ----------------------------\n        // let c = Object.getOwnPropertyNames(changedProps || {});\n        // window.debug && console.group(this.localName + '#' + this.id + ': ' + c);\n        // if (window.debug) { debugger; }\n        // ----------------------------\n        let hasPaths = this.__dataHasPaths;\n        this.__dataHasPaths = false;\n        // Compute properties\n        runComputedEffects(this, changedProps, oldProps, hasPaths);\n        // Clear notify properties prior to possible reentry (propagate, observe),\n        // but after computing effects have a chance to add to them\n        let notifyProps = this.__dataToNotify;\n        this.__dataToNotify = null;\n        // Propagate properties to clients\n        this._propagatePropertyChanges(changedProps, oldProps, hasPaths);\n        // Flush clients\n        this._flushClients();\n        // Reflect properties\n        runEffects(this, this.__reflectEffects, changedProps, oldProps, hasPaths);\n        // Observe properties\n        runEffects(this, this.__observeEffects, changedProps, oldProps, hasPaths);\n        // Notify properties to host\n        if (notifyProps) {\n          runNotifyEffects(this, notifyProps, changedProps, oldProps, hasPaths);\n        }\n        // Clear temporary cache at end of turn\n        if (this.__dataCounter == 1) {\n          this.__dataTemp = {};\n        }\n        // ----------------------------\n        // window.debug && console.groupEnd(this.localName + '#' + this.id + ': ' + c);\n        // ----------------------------\n      }\n\n      /**\n       * Called to propagate any property changes to stamped template nodes\n       * managed by this element.\n       *\n       * @param {Object} changedProps Bag of changed properties\n       * @param {Object} oldProps Bag of previous values for changed properties\n       * @param {boolean} hasPaths True with `props` contains one or more paths\n       * @protected\n       */\n      _propagatePropertyChanges(changedProps, oldProps, hasPaths) {\n        if (this.__propagateEffects) {\n          runEffects(this, this.__propagateEffects, changedProps, oldProps, hasPaths);\n        }\n        let templateInfo = this.__templateInfo;\n        while (templateInfo) {\n          runEffects(this, templateInfo.propertyEffects, changedProps, oldProps,\n            hasPaths, templateInfo.nodeList);\n          templateInfo = templateInfo.nextTemplateInfo;\n        }\n      }\n\n      /**\n       * Aliases one data path as another, such that path notifications from one\n       * are routed to the other.\n       *\n       * @param {string | !Array<string|number>} to Target path to link.\n       * @param {string | !Array<string|number>} from Source path to link.\n       * @public\n       */\n      linkPaths(to, from) {\n        to = Polymer.Path.normalize(to);\n        from = Polymer.Path.normalize(from);\n        this.__dataLinkedPaths = this.__dataLinkedPaths || {};\n        this.__dataLinkedPaths[to] = from;\n      }\n\n      /**\n       * Removes a data path alias previously established with `_linkPaths`.\n       *\n       * Note, the path to unlink should be the target (`to`) used when\n       * linking the paths.\n       *\n       * @param {string | !Array<string|number>} path Target path to unlink.\n       * @public\n       */\n      unlinkPaths(path) {\n        path = Polymer.Path.normalize(path);\n        if (this.__dataLinkedPaths) {\n          delete this.__dataLinkedPaths[path];\n        }\n      }\n\n      /**\n       * Notify that an array has changed.\n       *\n       * Example:\n       *\n       *     this.items = [ {name: 'Jim'}, {name: 'Todd'}, {name: 'Bill'} ];\n       *     ...\n       *     this.items.splice(1, 1, {name: 'Sam'});\n       *     this.items.push({name: 'Bob'});\n       *     this.notifySplices('items', [\n       *       { index: 1, removed: [{name: 'Todd'}], addedCount: 1, obect: this.items, type: 'splice' },\n       *       { index: 3, removed: [], addedCount: 1, object: this.items, type: 'splice'}\n       *     ]);\n       *\n       * @param {string} path Path that should be notified.\n       * @param {Array} splices Array of splice records indicating ordered\n       *   changes that occurred to the array. Each record should have the\n       *   following fields:\n       *    * index: index at which the change occurred\n       *    * removed: array of items that were removed from this index\n       *    * addedCount: number of new items added at this index\n       *    * object: a reference to the array in question\n       *    * type: the string literal 'splice'\n       *\n       *   Note that splice records _must_ be normalized such that they are\n       *   reported in index order (raw results from `Object.observe` are not\n       *   ordered and must be normalized/merged before notifying).\n       * @public\n      */\n      notifySplices(path, splices) {\n        let info = {};\n        let array = /** @type {Array} */(Polymer.Path.get(this, path, info));\n        notifySplices(this, array, info.path, splices);\n      }\n\n      /**\n       * Convenience method for reading a value from a path.\n       *\n       * Note, if any part in the path is undefined, this method returns\n       * `undefined` (this method does not throw when dereferencing undefined\n       * paths).\n       *\n       * @param {(string|!Array<(string|number)>)} path Path to the value\n       *   to read.  The path may be specified as a string (e.g. `foo.bar.baz`)\n       *   or an array of path parts (e.g. `['foo.bar', 'baz']`).  Note that\n       *   bracketed expressions are not supported; string-based path parts\n       *   *must* be separated by dots.  Note that when dereferencing array\n       *   indices, the index may be used as a dotted part directly\n       *   (e.g. `users.12.name` or `['users', 12, 'name']`).\n       * @param {Object=} root Root object from which the path is evaluated.\n       * @return {*} Value at the path, or `undefined` if any part of the path\n       *   is undefined.\n       * @public\n       */\n      get(path, root) {\n        return Polymer.Path.get(root || this, path);\n      }\n\n      /**\n       * Convenience method for setting a value to a path and notifying any\n       * elements bound to the same path.\n       *\n       * Note, if any part in the path except for the last is undefined,\n       * this method does nothing (this method does not throw when\n       * dereferencing undefined paths).\n       *\n       * @param {(string|!Array<(string|number)>)} path Path to the value\n       *   to write.  The path may be specified as a string (e.g. `'foo.bar.baz'`)\n       *   or an array of path parts (e.g. `['foo.bar', 'baz']`).  Note that\n       *   bracketed expressions are not supported; string-based path parts\n       *   *must* be separated by dots.  Note that when dereferencing array\n       *   indices, the index may be used as a dotted part directly\n       *   (e.g. `'users.12.name'` or `['users', 12, 'name']`).\n       * @param {*} value Value to set at the specified path.\n       * @param {Object=} root Root object from which the path is evaluated.\n       *   When specified, no notification will occur.\n       * @public\n      */\n      set(path, value, root) {\n        if (root) {\n          Polymer.Path.set(root, path, value);\n        } else {\n          if (!this.__readOnly || !this.__readOnly[/** @type {string} */(path)]) {\n            if (this._setPendingPropertyOrPath(path, value, true)) {\n              this._invalidateProperties();\n            }\n          }\n        }\n      }\n\n      /**\n       * Adds items onto the end of the array at the path specified.\n       *\n       * The arguments after `path` and return value match that of\n       * `Array.prototype.push`.\n       *\n       * This method notifies other paths to the same array that a\n       * splice occurred to the array.\n       *\n       * @param {string} path Path to array.\n       * @param {...*} items Items to push onto array\n       * @return {number} New length of the array.\n       * @public\n       */\n      push(path, ...items) {\n        let info = {};\n        let array = /** @type {Array}*/(Polymer.Path.get(this, path, info));\n        let len = array.length;\n        let ret = array.push(...items);\n        if (items.length) {\n          notifySplice(this, array, info.path, len, items.length, []);\n        }\n        return ret;\n      }\n\n      /**\n       * Removes an item from the end of array at the path specified.\n       *\n       * The arguments after `path` and return value match that of\n       * `Array.prototype.pop`.\n       *\n       * This method notifies other paths to the same array that a\n       * splice occurred to the array.\n       *\n       * @param {string} path Path to array.\n       * @return {*} Item that was removed.\n       * @public\n       */\n      pop(path) {\n        let info = {};\n        let array = /** @type {Array} */(Polymer.Path.get(this, path, info));\n        let hadLength = Boolean(array.length);\n        let ret = array.pop();\n        if (hadLength) {\n          notifySplice(this, array, info.path, array.length, 0, [ret]);\n        }\n        return ret;\n      }\n\n      /**\n       * Starting from the start index specified, removes 0 or more items\n       * from the array and inserts 0 or more new items in their place.\n       *\n       * The arguments after `path` and return value match that of\n       * `Array.prototype.splice`.\n       *\n       * This method notifies other paths to the same array that a\n       * splice occurred to the array.\n       *\n       * @param {string} path Path to array.\n       * @param {number} start Index from which to start removing/inserting.\n       * @param {number} deleteCount Number of items to remove.\n       * @param {...*} items Items to insert into array.\n       * @return {Array} Array of removed items.\n       * @public\n       */\n      splice(path, start, deleteCount, ...items) {\n        let info = {};\n        let array = /** @type {Array} */(Polymer.Path.get(this, path, info));\n        // Normalize fancy native splice handling of crazy start values\n        if (start < 0) {\n          start = array.length - Math.floor(-start);\n        } else {\n          start = Math.floor(start);\n        }\n        if (!start) {\n          start = 0;\n        }\n        let ret = array.splice(start, deleteCount, ...items);\n        if (items.length || ret.length) {\n          notifySplice(this, array, info.path, start, items.length, ret);\n        }\n        return ret;\n      }\n\n      /**\n       * Removes an item from the beginning of array at the path specified.\n       *\n       * The arguments after `path` and return value match that of\n       * `Array.prototype.pop`.\n       *\n       * This method notifies other paths to the same array that a\n       * splice occurred to the array.\n       *\n       * @param {string} path Path to array.\n       * @return {*} Item that was removed.\n       * @public\n       */\n      shift(path) {\n        let info = {};\n        let array = /** @type {Array} */(Polymer.Path.get(this, path, info));\n        let hadLength = Boolean(array.length);\n        let ret = array.shift();\n        if (hadLength) {\n          notifySplice(this, array, info.path, 0, 0, [ret]);\n        }\n        return ret;\n      }\n\n      /**\n       * Adds items onto the beginning of the array at the path specified.\n       *\n       * The arguments after `path` and return value match that of\n       * `Array.prototype.push`.\n       *\n       * This method notifies other paths to the same array that a\n       * splice occurred to the array.\n       *\n       * @param {string} path Path to array.\n       * @param {...*} items Items to insert info array\n       * @return {number} New length of the array.\n       * @public\n       */\n      unshift(path, ...items) {\n        let info = {};\n        let array = /** @type {Array} */(Polymer.Path.get(this, path, info));\n        let ret = array.unshift(...items);\n        if (items.length) {\n          notifySplice(this, array, info.path, 0, items.length, []);\n        }\n        return ret;\n      }\n\n      /**\n       * Notify that a path has changed.\n       *\n       * Example:\n       *\n       *     this.item.user.name = 'Bob';\n       *     this.notifyPath('item.user.name');\n       *\n       * @param {string} path Path that should be notified.\n       * @param {*=} value Value at the path (optional).\n       * @public\n      */\n      notifyPath(path, value) {\n        /** @type {string} */\n        let propPath;\n        if (arguments.length == 1) {\n          // Get value if not supplied\n          let info = {};\n          value = Polymer.Path.get(this, path, info);\n          propPath = info.path;\n        } else if (Array.isArray(path)) {\n          // Normalize path if needed\n          propPath = Polymer.Path.normalize(path);\n        } else {\n          propPath = /** @type{string} */(path);\n        }\n        if (this._setPendingPropertyOrPath(propPath, value, true, true)) {\n          this._invalidateProperties();\n        }\n      }\n\n      /**\n       * Equivalent to static `createReadOnlyProperty` API but can be called on\n       * an instance to add effects at runtime.  See that method for\n       * full API docs.\n       *\n       * @param {string} property Property name\n       * @param {boolean=} protectedSetter Creates a custom protected setter\n       *   when `true`.\n       * @protected\n       */\n      _createReadOnlyProperty(property, protectedSetter) {\n        this._addPropertyEffect(property, TYPES.READ_ONLY);\n        if (protectedSetter) {\n          this['_set' + upper(property)] = function(value) {\n            this._setProperty(property, value);\n          }\n        }\n      }\n\n      /**\n       * Equivalent to static `createPropertyObserver` API but can be called on\n       * an instance to add effects at runtime.  See that method for\n       * full API docs.\n       *\n       * @param {string} property Property name\n       * @param {string} methodName Name of observer method to call\n       * @param {boolean=} dynamicFn Whether the method name should be included as\n       *   a dependency to the effect.\n       * @protected\n       */\n      _createPropertyObserver(property, methodName, dynamicFn) {\n        let info = { property, methodName, dynamicFn };\n        this._addPropertyEffect(property, TYPES.OBSERVE, {\n          fn: runObserverEffect, info, trigger: {name: property}\n        });\n        if (dynamicFn) {\n          this._addPropertyEffect(methodName, TYPES.OBSERVE, {\n            fn: runObserverEffect, info, trigger: {name: methodName}\n          });\n        }\n      }\n\n      /**\n       * Equivalent to static `createMethodObserver` API but can be called on\n       * an instance to add effects at runtime.  See that method for\n       * full API docs.\n       *\n       * @param {string} expression Method expression\n       * @param {boolean|Object=} dynamicFn Boolean or object map indicating\n       *   whether method names should be included as a dependency to the effect.\n       * @protected\n       */\n      _createMethodObserver(expression, dynamicFn) {\n        let sig = parseMethod(expression);\n        if (!sig) {\n          throw new Error(\"Malformed observer expression '\" + expression + \"'\");\n        }\n        createMethodEffect(this, sig, TYPES.OBSERVE, runMethodEffect, null, dynamicFn);\n      }\n\n      /**\n       * Equivalent to static `createNotifyingProperty` API but can be called on\n       * an instance to add effects at runtime.  See that method for\n       * full API docs.\n       *\n       * @param {string} property Property name\n       * @protected\n       */\n      _createNotifyingProperty(property) {\n        this._addPropertyEffect(property, TYPES.NOTIFY, {\n          fn: runNotifyEffect,\n          info: {\n            eventName: CaseMap.camelToDashCase(property) + '-changed',\n            property: property\n          }\n        });\n      }\n\n      /**\n       * Equivalent to static `createReflectedProperty` API but can be called on\n       * an instance to add effects at runtime.  See that method for\n       * full API docs.\n       *\n       * @param {string} property Property name\n       * @protected\n       */\n      _createReflectedProperty(property) {\n        let attr = CaseMap.camelToDashCase(property);\n        if (attr[0] === '-') {\n          console.warn('Property ' + property + ' cannot be reflected to attribute ' +\n            attr + ' because \"-\" is not a valid starting attribute name. Use a lowercase first letter for the property thisead.');\n        } else {\n          this._addPropertyEffect(property, TYPES.REFLECT, {\n            fn: runReflectEffect,\n            info: {\n              attrName: attr\n            }\n          });\n        }\n      }\n\n      /**\n       * Equivalent to static `createComputedProperty` API but can be called on\n       * an instance to add effects at runtime.  See that method for\n       * full API docs.\n       *\n       * @param {string} property Name of computed property to set\n       * @param {string} expression Method expression\n       * @param {boolean|Object=} dynamicFn Boolean or object map indicating\n       *   whether method names should be included as a dependency to the effect.\n       * @protected\n       */\n      _createComputedProperty(property, expression, dynamicFn) {\n        let sig = parseMethod(expression);\n        if (!sig) {\n          throw new Error(\"Malformed computed expression '\" + expression + \"'\");\n        }\n        createMethodEffect(this, sig, TYPES.COMPUTE, runComputedEffect, property, dynamicFn);\n      }\n\n      // -- static class methods ------------\n\n      /**\n       * Ensures an accessor exists for the specified property, and adds\n       * to a list of \"property effects\" that will run when the accessor for\n       * the specified property is set.  Effects are grouped by \"type\", which\n       * roughly corresponds to a phase in effect processing.  The effect\n       * metadata should be in the following form:\n       *\n       *   {\n       *     fn: effectFunction, // Reference to function to call to perform effect\n       *     info: { ... }       // Effect metadata passed to function\n       *     trigger: {          // Optional triggering metadata; if not provided\n       *       name: string      // the property is treated as a wildcard\n       *       structured: boolean\n       *       wildcard: boolean\n       *     }\n       *   }\n       *\n       * Effects are called from `_propertiesChanged` in the following order by\n       * type:\n       *\n       * 1. COMPUTE\n       * 2. PROPAGATE\n       * 3. REFLECT\n       * 4. OBSERVE\n       * 5. NOTIFY\n       *\n       * Effect functions are called with the following signature:\n       *\n       *   effectFunction(inst, path, props, oldProps, info, hasPaths)\n       *\n       * @param {string} property Property that should trigger the effect\n       * @param {string} type Effect type, from this.PROPERTY_EFFECT_TYPES\n       * @param {Object=} effect Effect metadata object\n       * @protected\n       */\n      static addPropertyEffect(property, type, effect) {\n        this.prototype._addPropertyEffect(property, type, effect);\n      }\n\n      /**\n       * Creates a single-property observer for the given property.\n       *\n       * @param {string} property Property name\n       * @param {string} methodName Name of observer method to call\n       * @param {boolean=} dynamicFn Whether the method name should be included as\n       *   a dependency to the effect.\n       * @protected\n       */\n      static createPropertyObserver(property, methodName, dynamicFn) {\n        this.prototype._createPropertyObserver(property, methodName, dynamicFn);\n      }\n\n      /**\n       * Creates a multi-property \"method observer\" based on the provided\n       * expression, which should be a string in the form of a normal Javascript\n       * function signature: `'methodName(arg1, [..., argn])'`.  Each argument\n       * should correspond to a property or path in the context of this\n       * prototype (or instance), or may be a literal string or number.\n       *\n       * @param {string} expression Method expression\n       * @param {boolean|Object=} dynamicFn Boolean or object map indicating\n       *   whether method names should be included as a dependency to the effect.\n       * @protected\n       */\n      static createMethodObserver(expression, dynamicFn) {\n        this.prototype._createMethodObserver(expression, dynamicFn);\n      }\n\n      /**\n       * Causes the setter for the given property to dispatch `<property>-changed`\n       * events to notify of changes to the property.\n       *\n       * @param {string} property Property name\n       * @protected\n       */\n      static createNotifyingProperty(property) {\n        this.prototype._createNotifyingProperty(property);\n      }\n\n      /**\n       * Creates a read-only accessor for the given property.\n       *\n       * To set the property, use the protected `_setProperty` API.\n       * To create a custom protected setter (e.g. `_setMyProp()` for\n       * property `myProp`), pass `true` for `protectedSetter`.\n       *\n       * Note, if the property will have other property effects, this method\n       * should be called first, before adding other effects.\n       *\n       * @param {string} property Property name\n       * @param {boolean=} protectedSetter Creates a custom protected setter\n       *   when `true`.\n       * @protected\n       */\n      static createReadOnlyProperty(property, protectedSetter) {\n        this.prototype._createReadOnlyProperty(property, protectedSetter);\n      }\n\n      /**\n       * Causes the setter for the given property to reflect the property value\n       * to a (dash-cased) attribute of the same name.\n       *\n       * @param {string} property Property name\n       * @protected\n       */\n      static createReflectedProperty(property) {\n        this.prototype._createReflectedProperty(property);\n      }\n\n      /**\n       * Creates a computed property whose value is set to the result of the\n       * method described by the given `expression` each time one or more\n       * arguments to the method changes.  The expression should be a string\n       * in the form of a normal Javascript function signature:\n       * `'methodName(arg1, [..., argn])'`\n       *\n       * @param {string} property Name of computed property to set\n       * @param {string} expression Method expression\n       * @param {boolean|Object=} dynamicFn Boolean or object map indicating whether\n       *   method names should be included as a dependency to the effect.\n       * @protected\n       */\n      static createComputedProperty(property, expression, dynamicFn) {\n        this.prototype._createComputedProperty(property, expression, dynamicFn);\n      }\n\n      /**\n       * Parses the provided template to ensure binding effects are created\n       * for them, and then ensures property accessors are created for any\n       * dependent properties in the template.  Binding effects for bound\n       * templates are stored in a linked list on the instance so that\n       * templates can be efficiently stamped and unstamped.\n       *\n       * @param {HTMLTemplateElement} template Template containing binding\n       *   bindings\n       * @return {Object} Template metadata object\n       * @protected\n       */\n      static bindTemplate(template) {\n        return this.prototype._bindTemplate(template);\n      }\n\n      // -- binding ----------------------------------------------\n\n      /**\n       * Equivalent to static `bindTemplate` API but can be called on\n       * an instance to add effects at runtime.  See that method for\n       * full API docs.\n       *\n       * This method may be called on the prototype (for prototypical template\n       * binding, to avoid creating accessors every instance) once per prototype,\n       * and will be called with `runtimeBinding: true` by `_stampTemplate` to\n       * create and link an instance of the template metadata associated with a\n       * particular stamping.\n       *\n       * @param {HTMLTemplateElement} template Template containing binding\n       *   bindings\n       * @param {boolean=} instanceBinding When false (default), performs\n       *   \"prototypical\" binding of the template and overwrites any previously\n       *   bound template for the class. When true (as passed from\n       *   `_stampTemplate`), the template info is instanced and linked into\n       *   the list of bound templates.\n       * @return {Object} Template metadata object; for `runtimeBinding`,\n       *   this is an instance of the prototypical template info\n       * @protected\n       */\n      _bindTemplate(template, instanceBinding) {\n        let templateInfo = this.constructor._parseTemplate(template);\n        let wasPreBound = this.__templateInfo == templateInfo;\n        // Optimization: since this is called twice for proto-bound templates,\n        // don't attempt to recreate accessors if this template was pre-bound\n        if (!wasPreBound) {\n          for (let prop in templateInfo.propertyEffects) {\n            this._createPropertyAccessor(prop);\n          }\n        }\n        if (instanceBinding) {\n          // For instance-time binding, create instance of template metadata\n          // and link into list of templates if necessary\n          templateInfo = Object.create(templateInfo);\n          templateInfo.wasPreBound = wasPreBound;\n          if (!wasPreBound && this.__templateInfo) {\n            let last = this.__templateInfoLast || this.__templateInfo;\n            this.__templateInfoLast = last.nextTemplateInfo = templateInfo;\n            templateInfo.previousTemplateInfo = last;\n            return templateInfo;\n          }\n        }\n        return this.__templateInfo = templateInfo;\n      }\n\n      /**\n       * Adds a property effect to the given template metadata, which is run\n       * at the \"propagate\" stage of `_propertiesChanged` when the template\n       * has been bound to the element via `_bindTemplate`.\n       *\n       * The `effect` object should match the format in `_addPropertyEffect`.\n       *\n       * @param {Object} templateInfo Template metadata to add effect to\n       * @param {string} prop Property that should trigger the effect\n       * @param {Object=} effect Effect metadata object\n       * @protected\n       */\n      static _addTemplatePropertyEffect(templateInfo, prop, effect) {\n        let hostProps = templateInfo.hostProps = templateInfo.hostProps || {};\n        hostProps[prop] = true;\n        let effects = templateInfo.propertyEffects = templateInfo.propertyEffects || {};\n        let propEffects = effects[prop] = effects[prop] || [];\n        propEffects.push(effect);\n      }\n\n      /**\n       * Stamps the provided template and performs instance-time setup for\n       * Polymer template features, including data bindings, declarative event\n       * listeners, and the `this.$` map of `id`'s to nodes.  A document fragment\n       * is returned containing the stamped DOM, ready for insertion into the\n       * DOM.\n       *\n       * This method may be called more than once; however note that due to\n       * `shadycss` polyfill limitations, only styles from templates prepared\n       * using `ShadyCSS.prepareTemplate` will be correctly polyfilled (scoped\n       * to the shadow root and support CSS custom properties), and note that\n       * `ShadyCSS.prepareTemplate` may only be called once per element. As such,\n       * any styles required by in runtime-stamped templates must be included\n       * in the main element template.\n       *\n       * @param {HTMLTemplateElement} template Template to stamp\n       * @return {DocumentFragment} Cloned template content\n       * @protected\n       */\n      _stampTemplate(template) {\n        // Ensures that created dom is `_enqueueClient`'d to this element so\n        // that it can be flushed on next call to `_flushProperties`\n        hostStack.beginHosting(this);\n        let dom = super._stampTemplate(template);\n        hostStack.endHosting(this);\n        let templateInfo = this._bindTemplate(template, true);\n        // Add template-instance-specific data to instanced templateInfo\n        templateInfo.nodeList = dom.nodeList;\n        // Capture child nodes to allow unstamping of non-prototypical templates\n        if (!templateInfo.wasPreBound) {\n          let nodes = templateInfo.childNodes = [];\n          for (let n=dom.firstChild; n; n=n.nextSibling) {\n            nodes.push(n);\n          }\n        }\n        dom.templateInfo = templateInfo;\n        // Setup compound storage, 2-way listeners, and dataHost for bindings\n        setupBindings(this, templateInfo);\n        // Flush properties into template nodes if already booted\n        if (this.__dataReady) {\n          runEffects(this, templateInfo.propertyEffects, this.__data, null,\n            false, templateInfo.nodeList);\n        }\n        return dom;\n      }\n\n      /**\n       * Removes and unbinds the nodes previously contained in the provided\n       * DocumentFragment returned from `_stampTemplate`.\n       *\n       * @param {DocumentFragment} dom DocumentFragment previously returned\n       *   from `_stampTemplate` associated with the nodes to be removed\n       * @protected\n       */\n      _removeBoundDom(dom) {\n        // Unlink template info\n        let templateInfo = dom.templateInfo;\n        if (templateInfo.previousTemplateInfo) {\n          templateInfo.previousTemplateInfo.nextTemplateInfo =\n            templateInfo.nextTemplateInfo;\n        }\n        if (templateInfo.nextTemplateInfo) {\n          templateInfo.nextTemplateInfo.previousTemplateInfo =\n            templateInfo.previousTemplateInfo;\n        }\n        if (this.__templateInfoLast == templateInfo) {\n          this.__templateInfoLast = templateInfo.previousTemplateInfo;\n        }\n        templateInfo.previousTemplateInfo = templateInfo.nextTemplateInfo = null;\n        // Remove stamped nodes\n        let nodes = templateInfo.childNodes;\n        for (let i=0; i<nodes.length; i++) {\n          let node = nodes[i];\n          node.parentNode.removeChild(node);\n        }\n      }\n\n      /**\n       * Overrides default `TemplateStamp` implementation to add support for\n       * parsing bindings from `TextNode`'s' `textContent`.  A `bindings`\n       * array is added to `nodeInfo` and populated with binding metadata\n       * with information capturing the binding target, and a `parts` array\n       * with one or more metadata objects capturing the source(s) of the\n       * binding.\n       *\n       * @override\n       * @param {Node} node Node to parse\n       * @param {Object} templateInfo Template metadata for current template\n       * @param {Object} nodeInfo Node metadata for current template node\n       * @return {boolean} `true` if the visited node added node-specific\n       *   metadata to `nodeInfo`\n       * @protected\n       */\n      static _parseTemplateNode(node, templateInfo, nodeInfo) {\n        let noted = super._parseTemplateNode(node, templateInfo, nodeInfo);\n        if (node.nodeType === Node.TEXT_NODE) {\n          let parts = this._parseBindings(node.textContent, templateInfo);\n          if (parts) {\n            // Initialize the textContent with any literal parts\n            // NOTE: default to a space here so the textNode remains; some browsers\n            // (IE) evacipate an empty textNode following cloneNode/importNode.\n            node.textContent = literalFromParts(parts) || ' ';\n            addBinding(this, templateInfo, nodeInfo, 'text', 'textContent', parts);\n            noted = true;\n          }\n        }\n        return noted;\n      }\n\n      /**\n       * Overrides default `TemplateStamp` implementation to add support for\n       * parsing bindings from attributes.  A `bindings`\n       * array is added to `nodeInfo` and populated with binding metadata\n       * with information capturing the binding target, and a `parts` array\n       * with one or more metadata objects capturing the source(s) of the\n       * binding.\n       *\n       * @override\n       * @param {Node} node Node to parse\n       * @param {Object} templateInfo Template metadata for current template\n       * @param {Object} nodeInfo Node metadata for current template node\n       * @return {boolean} `true` if the visited node added node-specific\n       *   metadata to `nodeInfo`\n       * @protected\n       */\n      static _parseTemplateNodeAttribute(node, templateInfo, nodeInfo, name, value) {\n        let parts = this._parseBindings(value, templateInfo);\n        if (parts) {\n          // Attribute or property\n          let origName = name;\n          let kind = 'property';\n          if (name[name.length-1] == '$') {\n            name = name.slice(0, -1);\n            kind = 'attribute';\n          }\n          // Initialize attribute bindings with any literal parts\n          let literal = literalFromParts(parts);\n          if (literal && kind == 'attribute') {\n            node.setAttribute(name, literal);\n          }\n          // Clear attribute before removing, since IE won't allow removing\n          // `value` attribute if it previously had a value (can't\n          // unconditionally set '' before removing since attributes with `$`\n          // can't be set using setAttribute)\n          if (node.localName === 'input' && origName === 'value') {\n            node.setAttribute(origName, '');\n          }\n          // Remove annotation\n          node.removeAttribute(origName);\n          // Case hackery: attributes are lower-case, but bind targets\n          // (properties) are case sensitive. Gambit is to map dash-case to\n          // camel-case: `foo-bar` becomes `fooBar`.\n          // Attribute bindings are excepted.\n          if (kind === 'property') {\n            name = Polymer.CaseMap.dashToCamelCase(name);\n          }\n          addBinding(this, templateInfo, nodeInfo, kind, name, parts, literal);\n          return true;\n        } else {\n          return super._parseTemplateNodeAttribute(node, templateInfo, nodeInfo, name, value);\n        }\n      }\n\n      /**\n       * Overrides default `TemplateStamp` implementation to add support for\n       * binding the properties that a nested template depends on to the template\n       * as `_host_<property>`.\n       *\n       * @override\n       * @param {Node} node Node to parse\n       * @param {Object} templateInfo Template metadata for current template\n       * @param {Object} nodeInfo Node metadata for current template node\n       * @return {boolean} `true` if the visited node added node-specific\n       *   metadata to `nodeInfo`\n       * @protected\n       */\n      static _parseTemplateNestedTemplate(node, templateInfo, nodeInfo) {\n        let noted = super._parseTemplateNestedTemplate(node, templateInfo, nodeInfo);\n        // Merge host props into outer template and add bindings\n        let hostProps = nodeInfo.templateInfo.hostProps;\n        let mode = '{';\n        for (let source in hostProps) {\n          let parts = [{ mode, source, dependencies: [source] }];\n          addBinding(this, templateInfo, nodeInfo, 'property', '_host_' + source, parts);\n        }\n        return noted;\n      }\n\n      /**\n       * Called to parse text in a template (either attribute values or\n       * textContent) into binding metadata.\n       *\n       * Any overrides of this method should return an array of binding part\n       * metadata  representing one or more bindings found in the provided text\n       * and any \"literal\" text in between.  Any non-literal parts will be passed\n       * to `_evaluateBinding` when any dependencies change.  The only required\n       * fields of each \"part\" in the returned array are as follows:\n       *\n       * - `dependencies` - Array containing trigger metadata for each property\n       *   that should trigger the binding to update\n       * - `literal` - String containing text if the part represents a literal;\n       *   in this case no `dependencies` are needed\n       *\n       * Additional metadata for use by `_evaluateBinding` may be provided in\n       * each part object as needed.\n       *\n       * The default implementation handles the following types of bindings\n       * (one or more may be intermixed with literal strings):\n       * - Property binding: `[[prop]]`\n       * - Path binding: `[[object.prop]]`\n       * - Negated property or path bindings: `[[!prop]]` or `[[!object.prop]]`\n       * - Two-way property or path bindings (supports negation):\n       *   `{{prop}}`, `{{object.prop}}`, `{{!prop}}` or `{{!object.prop}}`\n       * - Inline computed method (supports negation):\n       *   `[[compute(a, 'literal', b)]]`, `[[!compute(a, 'literal', b)]]`\n       *\n       * @param {string} text Text to parse from attribute or textContent\n       * @param {Object} templateInfo Current template metadata\n       * @return {Array<Object>} Array of binding part metadata\n       * @protected\n       */\n      static _parseBindings(text, templateInfo) {\n        let parts = [];\n        let lastIndex = 0;\n        let m;\n        // Example: \"literal1{{prop}}literal2[[!compute(foo,bar)]]final\"\n        // Regex matches:\n        //        Iteration 1:  Iteration 2:\n        // m[1]: '{{'          '[['\n        // m[2]: ''            '!'\n        // m[3]: 'prop'        'compute(foo,bar)'\n        while ((m = bindingRegex.exec(text)) !== null) {\n          // Add literal part\n          if (m.index > lastIndex) {\n            parts.push({literal: text.slice(lastIndex, m.index)});\n          }\n          // Add binding part\n          let mode = m[1][0];\n          let negate = Boolean(m[2]);\n          let source = m[3].trim();\n          let customEvent, notifyEvent, colon;\n          if (mode == '{' && (colon = source.indexOf('::')) > 0) {\n            notifyEvent = source.substring(colon + 2);\n            source = source.substring(0, colon);\n            customEvent = true;\n          }\n          let signature = parseMethod(source);\n          let dependencies = [];\n          if (signature) {\n            // Inline computed function\n            let {args, methodName} = signature;\n            for (let i=0; i<args.length; i++) {\n              let arg = args[i];\n              if (!arg.literal) {\n                dependencies.push(arg);\n              }\n            }\n            let dynamicFns = templateInfo.dynamicFns;\n            if (dynamicFns && dynamicFns[methodName] || signature.static) {\n              dependencies.push(methodName);\n              signature.dynamicFn = true;\n            }\n          } else {\n            // Property or path\n            dependencies.push(source);\n          }\n          parts.push({\n            source, mode, negate, customEvent, signature, dependencies,\n            event: notifyEvent\n          });\n          lastIndex = bindingRegex.lastIndex;\n        }\n        // Add a final literal part\n        if (lastIndex && lastIndex < text.length) {\n          let literal = text.substring(lastIndex);\n          if (literal) {\n            parts.push({\n              literal: literal\n            });\n          }\n        }\n        if (parts.length) {\n          return parts;\n        }\n      }\n\n      /**\n       * Called to evaluate a previously parsed binding part based on a set of\n       * one or more changed dependencies.\n       *\n       * @param {HTMLElement} inst Element that should be used as scope for\n       *   binding dependencies\n       * @param {Object} part Binding part metadata\n       * @param {string} path Property/path that triggered this effect\n       * @param {Object} props Bag of current property changes\n       * @param {Object} oldProps Bag of previous values for changed properties\n       * @param {boolean} hasPaths True with `props` contains one or more paths\n       * @return {*} Value the binding part evaluated to\n       * @protected\n       */\n      static _evaluateBinding(inst, part, path, props, oldProps, hasPaths) {\n        let value;\n        if (part.signature) {\n          value = runMethodEffect(inst, path, props, oldProps, part.signature);\n        } else if (path != part.source) {\n          value = Polymer.Path.get(inst, part.source);\n        } else {\n          if (hasPaths && Polymer.Path.isPath(path)) {\n            value = Polymer.Path.get(inst, path);\n          } else {\n            value = inst.__data[path];\n          }\n        }\n        if (part.negate) {\n          value = !value;\n        }\n        return value;\n      }\n\n    }\n\n    return PropertyEffects;\n  });\n\n  /**\n   * Helper api for enqueing client dom created by a host element.\n   *\n   * By default elements are flushed via `_flushProperties` when\n   * `connectedCallback` is called. Elements attach their client dom to\n   * themselves at `ready` time which results from this first flush.\n   * This provides an ordering guarantee that the client dom an element\n   * creates is flushed before the element itself (i.e. client `ready`\n   * fires before host `ready`).\n   *\n   * However, if `_flushProperties` is called *before* an element is connected,\n   * as for example `Templatize` does, this ordering guarantee cannot be\n   * satisfied because no elements are connected. (Note: Bound elements that\n   * receive data do become enqueued clients and are properly ordered but\n   * unbound elements are not.)\n   *\n   * To maintain the desired \"client before host\" ordering guarantee for this\n   * case we rely on the \"host stack. Client nodes registers themselves with\n   * the creating host element when created. This ensures that all client dom\n   * is readied in the proper order, maintaining the desired guarantee.\n   *\n   * @private\n   */\n  let hostStack = {\n\n    stack: [],\n\n    registerHost(inst) {\n      if (this.stack.length) {\n        let host = this.stack[this.stack.length-1];\n        host._enqueueClient(inst);\n      }\n    },\n\n    beginHosting(inst) {\n      this.stack.push(inst);\n    },\n\n    endHosting(inst) {\n      let stackLen = this.stack.length;\n      if (stackLen && this.stack[stackLen-1] == inst) {\n        this.stack.pop();\n      }\n    }\n\n  }\n\n})();\n\n\n\n\n// WEBPACK FOOTER //\n// ./~/@polymer/polymer/lib/mixins/property-effects.html","/*__wc__loader*/\nrequire('./boot.html');\n\n\n(function() {\n\n  'use strict';\n\n  /** @typedef {{run: function(function(), number=):number, cancel: function(number)}} */\n  let AsyncInterface; // eslint-disable-line no-unused-vars\n\n  // Microtask implemented using Mutation Observer\n  let microtaskCurrHandle = 0;\n  let microtaskLastHandle = 0;\n  let microtaskCallbacks = [];\n  let microtaskNodeContent = 0;\n  let microtaskNode = document.createTextNode('');\n  new window.MutationObserver(microtaskFlush).observe(microtaskNode, {characterData: true});\n\n  function microtaskFlush() {\n    const len = microtaskCallbacks.length;\n    for (let i = 0; i < len; i++) {\n      let cb = microtaskCallbacks[i];\n      if (cb) {\n        try {\n          cb();\n        } catch (e) {\n          setTimeout(() => { throw e });\n        }\n      }\n    }\n    microtaskCallbacks.splice(0, len);\n    microtaskLastHandle += len;\n  }\n\n  /**\n   * Module that provides a number of strategies for enqueuing asynchronous\n   * tasks.  Each sub-module provides a standard `run(fn)` interface that returns a\n   * handle, and a `cancel(handle)` interface for canceling async tasks before\n   * they run.\n   *\n   * @namespace\n   * @memberof Polymer\n   * @summary Module that provides a number of strategies for enqueuing asynchronous\n   * tasks.\n   */\n  Polymer.Async = {\n\n    /**\n     * Async interface wrapper around `setTimeout`.\n     *\n     * @namespace\n     * @memberof Polymer.Async\n     * @summary Async interface wrapper around `setTimeout`.\n     */\n    timeOut: {\n      /**\n       * Returns a sub-module with the async interface providing the provided\n       * delay.\n       *\n       * @memberof Polymer.Async.timeOut\n       * @param {number} delay Time to wait before calling callbacks in ms\n       * @return {AsyncInterface} An async timeout interface\n       */\n      after(delay) {\n        return  {\n          run(fn) { return setTimeout(fn, delay) },\n          cancel: window.clearTimeout.bind(window)\n        }\n      },\n      /**\n       * Enqueues a function called in the next task.\n       *\n       * @memberof Polymer.Async.timeOut\n       * @param {Function} fn Callback to run\n       * @return {number} Handle used for canceling task\n       */\n      run: window.setTimeout.bind(window),\n      /**\n       * Cancels a previously enqueued `timeOut` callback.\n       *\n       * @memberof Polymer.Async.timeOut\n       * @param {number} handle Handle returned from `run` of callback to cancel\n       */\n      cancel: window.clearTimeout.bind(window)\n    },\n\n    /**\n     * Async interface wrapper around `requestAnimationFrame`.\n     *\n     * @namespace\n     * @memberof Polymer.Async\n     * @summary Async interface wrapper around `requestAnimationFrame`.\n     */\n    animationFrame: {\n      /**\n       * Enqueues a function called at `requestAnimationFrame` timing.\n       *\n       * @memberof Polymer.Async.animationFrame\n       * @param {Function} fn Callback to run\n       * @return {number} Handle used for canceling task\n       */\n      run: window.requestAnimationFrame.bind(window),\n      /**\n       * Cancels a previously enqueued `animationFrame` callback.\n       *\n       * @memberof Polymer.Async.timeOut\n       * @param {number} handle Handle returned from `run` of callback to cancel\n       */\n      cancel: window.cancelAnimationFrame.bind(window)\n    },\n\n    /**\n     * Async interface wrapper around `requestIdleCallback`.  Falls back to\n     * `setTimeout` on browsers that do not support `requestIdleCallback`.\n     *\n     * @namespace\n     * @memberof Polymer.Async\n     * @summary Async interface wrapper around `requestIdleCallback`.\n     */\n    idlePeriod: {\n      /**\n       * Enqueues a function called at `requestIdleCallback` timing.\n       *\n       * @memberof Polymer.Async.idlePeriod\n       * @param {function(IdleDeadline)} fn Callback to run\n       * @return {number} Handle used for canceling task\n       */\n      run(fn) {\n        return window.requestIdleCallback ?\n          window.requestIdleCallback(fn) :\n          window.setTimeout(fn, 16);\n      },\n      /**\n       * Cancels a previously enqueued `idlePeriod` callback.\n       *\n       * @memberof Polymer.Async.idlePeriod\n       * @param {number} handle Handle returned from `run` of callback to cancel\n       */\n      cancel(handle) {\n        window.cancelIdleCallback ?\n          window.cancelIdleCallback(handle) :\n          window.clearTimeout(handle);\n      }\n    },\n\n    /**\n     * Async interface for enqueueing callbacks that run at microtask timing.\n     *\n     * Note that microtask timing is achieved via a single `MutationObserver`,\n     * and thus callbacks enqueued with this API will all run in a single\n     * batch, and not interleaved with other microtasks such as promises.\n     * Promises are avoided as an implementation choice for the time being\n     * due to Safari bugs that cause Promises to lack microtask guarantees.\n     *\n     * @namespace\n     * @memberof Polymer.Async\n     * @summary Async interface for enqueueing callbacks that run at microtask\n     *   timing.\n     */\n    microTask: {\n\n      /**\n       * Enqueues a function called at microtask timing.\n       *\n       * @memberof Polymer.Async.microTask\n       * @param {Function} callback Callback to run\n       * @return {*} Handle used for canceling task\n       */\n      run(callback) {\n        microtaskNode.textContent = microtaskNodeContent++;\n        microtaskCallbacks.push(callback);\n        return microtaskCurrHandle++;\n      },\n\n      /**\n       * Cancels a previously enqueued `microTask` callback.\n       *\n       * @memberof Polymer.Async.microTask\n       * @param {number} handle Handle returned from `run` of callback to cancel\n       */\n      cancel(handle) {\n        const idx = handle - microtaskLastHandle;\n        if (idx >= 0) {\n          if (!microtaskCallbacks[idx]) {\n            throw new Error('invalid async handle: ' + handle);\n          }\n          microtaskCallbacks[idx] = null;\n        }\n      }\n\n    }\n  };\n\n})();\n\n\n\n\n// WEBPACK FOOTER //\n// ./~/@polymer/polymer/lib/utils/async.html","var g;\r\n\r\n// This works in non-strict mode\r\ng = (function() {\r\n\treturn this;\r\n})();\r\n\r\ntry {\r\n\t// This works if eval is allowed (see CSP)\r\n\tg = g || Function(\"return this\")() || (1,eval)(\"this\");\r\n} catch(e) {\r\n\t// This works if the window reference is available\r\n\tif(typeof window === \"object\")\r\n\t\tg = window;\r\n}\r\n\r\n// g can still be undefined, but nothing to do about it...\r\n// We return undefined, instead of nothing here, so it's\r\n// easier to handle this case. if(!global) { ...}\r\n\r\nmodule.exports = g;\r\n\n\n\n// WEBPACK FOOTER //\n// (webpack)/buildin/global.js","'use strict';\n\nimport '@polymer/polymer/polymer-element.html';\nimport './template.html';\n\nimport { store } from './../store';\n\nimport './../list-data';\n\nclass FakeApp extends Polymer.Element {\n  static get is() { return 'fake-app' }\n  static get properties() {\n    return {\n      test: {\n        type: String,\n        value: \"hello world\"\n      },\n      version: {\n        type: String,\n        value: () => { return window.Polymer.version }  \n      }\n    }\n  }\n\n}\n\ncustomElements.define(FakeApp.is, FakeApp);\n\n\n// WEBPACK FOOTER //\n// ./components/fake-app/index.js","'use strict';\n\nimport '@polymer/polymer/polymer-element.html';\nimport '@polymer/polymer/lib/elements/dom-repeat.html';\nimport './template.html';\n\nimport { store } from './../store';\n\nclass ListData extends Polymer.Element {\n  static get is() { return 'list-data' }\n  static get properties() {\n    return {\n      data: {\n        type: Array,\n        value: []\n      }\n    }\n  }\n\n  connectedCallback(){\n    fetch('http://jsonplaceholder.typicode.com/posts/')\n      .then(resp => resp.json())\n      .then(data => {\n        const filtered = data.filter((e,i) => {\n          return i < 10;\n        });\n        this.data = filtered;\n        store.dispatch({\n          type: 'SET_ITEMS',\n          data: filtered\n        });\n      });\n  }\n\n}\n\ncustomElements.define(ListData.is, ListData);\n\n\n// WEBPACK FOOTER //\n// ./components/list-data/index.js","import Symbol from './_Symbol.js';\nimport getRawTag from './_getRawTag.js';\nimport objectToString from './_objectToString.js';\n\n/** `Object#toString` result references. */\nvar nullTag = '[object Null]',\n    undefinedTag = '[object Undefined]';\n\n/** Built-in value references. */\nvar symToStringTag = Symbol ? Symbol.toStringTag : undefined;\n\n/**\n * The base implementation of `getTag` without fallbacks for buggy environments.\n *\n * @private\n * @param {*} value The value to query.\n * @returns {string} Returns the `toStringTag`.\n */\nfunction baseGetTag(value) {\n  if (value == null) {\n    return value === undefined ? undefinedTag : nullTag;\n  }\n  return (symToStringTag && symToStringTag in Object(value))\n    ? getRawTag(value)\n    : objectToString(value);\n}\n\nexport default baseGetTag;\n\n\n\n// WEBPACK FOOTER //\n// ./~/lodash-es/_baseGetTag.js","/** Detect free variable `global` from Node.js. */\nvar freeGlobal = typeof global == 'object' && global && global.Object === Object && global;\n\nexport default freeGlobal;\n\n\n\n// WEBPACK FOOTER //\n// ./~/lodash-es/_freeGlobal.js","import overArg from './_overArg.js';\n\n/** Built-in value references. */\nvar getPrototype = overArg(Object.getPrototypeOf, Object);\n\nexport default getPrototype;\n\n\n\n// WEBPACK FOOTER //\n// ./~/lodash-es/_getPrototype.js","import Symbol from './_Symbol.js';\n\n/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/**\n * Used to resolve the\n * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)\n * of values.\n */\nvar nativeObjectToString = objectProto.toString;\n\n/** Built-in value references. */\nvar symToStringTag = Symbol ? Symbol.toStringTag : undefined;\n\n/**\n * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.\n *\n * @private\n * @param {*} value The value to query.\n * @returns {string} Returns the raw `toStringTag`.\n */\nfunction getRawTag(value) {\n  var isOwn = hasOwnProperty.call(value, symToStringTag),\n      tag = value[symToStringTag];\n\n  try {\n    value[symToStringTag] = undefined;\n    var unmasked = true;\n  } catch (e) {}\n\n  var result = nativeObjectToString.call(value);\n  if (unmasked) {\n    if (isOwn) {\n      value[symToStringTag] = tag;\n    } else {\n      delete value[symToStringTag];\n    }\n  }\n  return result;\n}\n\nexport default getRawTag;\n\n\n\n// WEBPACK FOOTER //\n// ./~/lodash-es/_getRawTag.js","/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/**\n * Used to resolve the\n * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)\n * of values.\n */\nvar nativeObjectToString = objectProto.toString;\n\n/**\n * Converts `value` to a string using `Object.prototype.toString`.\n *\n * @private\n * @param {*} value The value to convert.\n * @returns {string} Returns the converted string.\n */\nfunction objectToString(value) {\n  return nativeObjectToString.call(value);\n}\n\nexport default objectToString;\n\n\n\n// WEBPACK FOOTER //\n// ./~/lodash-es/_objectToString.js","/**\n * Creates a unary function that invokes `func` with its argument transformed.\n *\n * @private\n * @param {Function} func The function to wrap.\n * @param {Function} transform The argument transform.\n * @returns {Function} Returns the new function.\n */\nfunction overArg(func, transform) {\n  return function(arg) {\n    return func(transform(arg));\n  };\n}\n\nexport default overArg;\n\n\n\n// WEBPACK FOOTER //\n// ./~/lodash-es/_overArg.js","import freeGlobal from './_freeGlobal.js';\n\n/** Detect free variable `self`. */\nvar freeSelf = typeof self == 'object' && self && self.Object === Object && self;\n\n/** Used as a reference to the global object. */\nvar root = freeGlobal || freeSelf || Function('return this')();\n\nexport default root;\n\n\n\n// WEBPACK FOOTER //\n// ./~/lodash-es/_root.js","/**\n * Checks if `value` is object-like. A value is object-like if it's not `null`\n * and has a `typeof` result of \"object\".\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is object-like, else `false`.\n * @example\n *\n * _.isObjectLike({});\n * // => true\n *\n * _.isObjectLike([1, 2, 3]);\n * // => true\n *\n * _.isObjectLike(_.noop);\n * // => false\n *\n * _.isObjectLike(null);\n * // => false\n */\nfunction isObjectLike(value) {\n  return value != null && typeof value == 'object';\n}\n\nexport default isObjectLike;\n\n\n\n// WEBPACK FOOTER //\n// ./~/lodash-es/isObjectLike.js","var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };\n\nimport compose from './compose';\n\n/**\n * Creates a store enhancer that applies middleware to the dispatch method\n * of the Redux store. This is handy for a variety of tasks, such as expressing\n * asynchronous actions in a concise manner, or logging every action payload.\n *\n * See `redux-thunk` package as an example of the Redux middleware.\n *\n * Because middleware is potentially asynchronous, this should be the first\n * store enhancer in the composition chain.\n *\n * Note that each middleware will be given the `dispatch` and `getState` functions\n * as named arguments.\n *\n * @param {...Function} middlewares The middleware chain to be applied.\n * @returns {Function} A store enhancer applying the middleware.\n */\nexport default function applyMiddleware() {\n  for (var _len = arguments.length, middlewares = Array(_len), _key = 0; _key < _len; _key++) {\n    middlewares[_key] = arguments[_key];\n  }\n\n  return function (createStore) {\n    return function (reducer, preloadedState, enhancer) {\n      var store = createStore(reducer, preloadedState, enhancer);\n      var _dispatch = store.dispatch;\n      var chain = [];\n\n      var middlewareAPI = {\n        getState: store.getState,\n        dispatch: function dispatch(action) {\n          return _dispatch(action);\n        }\n      };\n      chain = middlewares.map(function (middleware) {\n        return middleware(middlewareAPI);\n      });\n      _dispatch = compose.apply(undefined, chain)(store.dispatch);\n\n      return _extends({}, store, {\n        dispatch: _dispatch\n      });\n    };\n  };\n}\n\n\n// WEBPACK FOOTER //\n// ./~/redux/es/applyMiddleware.js","module.exports = require('./lib/index');\n\n\n\n// WEBPACK FOOTER //\n// ./~/symbol-observable/index.js","'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _ponyfill = require('./ponyfill');\n\nvar _ponyfill2 = _interopRequireDefault(_ponyfill);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\n\nvar root; /* global window */\n\n\nif (typeof self !== 'undefined') {\n  root = self;\n} else if (typeof window !== 'undefined') {\n  root = window;\n} else if (typeof global !== 'undefined') {\n  root = global;\n} else if (typeof module !== 'undefined') {\n  root = module;\n} else {\n  root = Function('return this')();\n}\n\nvar result = (0, _ponyfill2['default'])(root);\nexports['default'] = result;\n\n\n// WEBPACK FOOTER //\n// ./~/symbol-observable/lib/index.js","'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n\tvalue: true\n});\nexports['default'] = symbolObservablePonyfill;\nfunction symbolObservablePonyfill(root) {\n\tvar result;\n\tvar _Symbol = root.Symbol;\n\n\tif (typeof _Symbol === 'function') {\n\t\tif (_Symbol.observable) {\n\t\t\tresult = _Symbol.observable;\n\t\t} else {\n\t\t\tresult = _Symbol('observable');\n\t\t\t_Symbol.observable = result;\n\t\t}\n\t} else {\n\t\tresult = '@@observable';\n\t}\n\n\treturn result;\n};\n\n\n// WEBPACK FOOTER //\n// ./~/symbol-observable/lib/ponyfill.js","/*__wc__loader*/!function(a){var b=\"<dom-module id=\\\"fake-app\\\"><template><style>:host{display:block;width:80%;margin:30px auto;background-color:white;padding:10px 20px 30px;box-shadow:0px 10px 20px rgba(0,0,0,0.2);}</style><slot></slot><p><small>Running on Polymer [[version]]</small></p><list-data></list-data></template></dom-module>\";if(a.body){var c=a.body,d=a.createElement(\"div\");for(d.innerHTML=b;d.children.length>0;)c.appendChild(d.children[0])}else a.write(b)}(document);\n\n\n// WEBPACK FOOTER //\n// ./components/fake-app/template.html","/*__wc__loader*/!function(a){var b=\"<dom-module id=\\\"list-data\\\"><template><style>li{margin:10px 0;transition:all 0.6s ease;}ul:hover li{opacity:0.3;}ul:hover li:hover{cursor:pointer;opacity:1;}</style><ul><dom-repeat items=\\\"[[data]]\\\"><template><li data-id$=\\\"[[item.id]]\\\" data-user$=\\\"[[item.userId]]\\\"><strong>[[item.title]]</strong> - <small>[[item.body]]</small></li></template></dom-repeat></ul></template></dom-module>\";if(a.body){var c=a.body,d=a.createElement(\"div\");for(d.innerHTML=b;d.children.length>0;)c.appendChild(d.children[0])}else a.write(b)}(document);\n\n\n// WEBPACK FOOTER //\n// ./components/list-data/template.html","/*__wc__loader*/\nrequire('../utils/boot.html');\n\nrequire('../utils/resolve-url.html');\n\n\n(function() {\n  'use strict';\n\n  let modules = {};\n  let lcModules = {};\n  function findModule(id) {\n    return modules[id] || lcModules[id.toLowerCase()];\n  }\n\n  function styleOutsideTemplateCheck(inst) {\n    if (inst.querySelector('style')) {\n      console.warn('dom-module %s has style outside template', inst.id);\n    }\n  }\n\n  /**\n   * The `dom-module` element registers the dom it contains to the name given\n   * by the module's id attribute. It provides a unified database of dom\n   * accessible via its static `import` API.\n   *\n   * A key use case of `dom-module` is for providing custom element `<template>`s\n   * via HTML imports that are parsed by the native HTML parser, that can be\n   * relocated during a bundling pass and still looked up by `id`.\n   *\n   * Example:\n   *\n   *     <dom-module id=\"foo\">\n   *       <img src=\"stuff.png\">\n   *     </dom-module>\n   *\n   * Then in code in some other location that cannot access the dom-module above\n   *\n   *     let img = document.createElement('dom-module').import('foo', 'img');\n   *\n   * @extends HTMLElement\n   * @memberof Polymer\n   * @summary Custom element that provides a registry of relocatable DOM content\n   *   by `id` that is agnostic to bundling.\n   */\n  class DomModule extends HTMLElement {\n\n    static get observedAttributes() { return ['id'] }\n\n    /**\n     * Retrieves the element specified by the css `selector` in the module\n     * registered by `id`. For example, this.import('foo', 'img');\n     * @param {string} id The id of the dom-module in which to search.\n     * @param {string=} selector The css selector by which to find the element.\n     * @return {Element} Returns the element which matches `selector` in the\n     * module registered at the specified `id`.\n     */\n    static import(id, selector) {\n      if (id) {\n        let m = findModule(id);\n        if (m && selector) {\n          return m.querySelector(selector);\n        }\n        return m;\n      }\n      return null;\n    }\n\n    attributeChangedCallback(name, old, value) {\n      if (old !== value) {\n        this.register();\n      }\n    }\n\n    /**\n     * The absolute URL of the original location of this `dom-module`.\n     *\n     * This value will differ from this element's `ownerDocument` in the\n     * following ways:\n     * - Takes into account any `assetpath` attribute added during bundling\n     *   to indicate the original location relative to the bundled location\n     * - Uses the HTMLImports polyfill's `importForElement` API to ensure\n     *   the path is relative to the import document's location since\n     *   `ownerDocument` is not currently polyfilled\n     */\n    get assetpath() {\n      // Don't override existing assetpath.\n      if (!this.__assetpath) {\n        // note: assetpath set via an attribute must be relative to this\n        // element's location; accomodate polyfilled HTMLImports\n        const owner = window.HTMLImports && HTMLImports.importForElement ?\n          HTMLImports.importForElement(this) || document : this.ownerDocument;\n        const url = Polymer.ResolveUrl.resolveUrl(\n          this.getAttribute('assetpath') || '', owner.baseURI);\n        this.__assetpath = Polymer.ResolveUrl.pathFromUrl(url);\n      }\n      return this.__assetpath;\n    }\n\n    /**\n     * Registers the dom-module at a given id. This method should only be called\n     * when a dom-module is imperatively created. For\n     * example, `document.createElement('dom-module').register('foo')`.\n     * @param {string=} id The id at which to register the dom-module.\n     */\n    register(id) {\n      id = id || this.id;\n      if (id) {\n        this.id = id;\n        // store id separate from lowercased id so that\n        // in all cases mixedCase id will stored distinctly\n        // and lowercase version is a fallback\n        modules[id] = this;\n        lcModules[id.toLowerCase()] = this;\n        styleOutsideTemplateCheck(this);\n      }\n    }\n  }\n\n  DomModule.prototype['modules'] = modules;\n\n  customElements.define('dom-module', DomModule);\n\n  // export\n  Polymer.DomModule = DomModule;\n\n})();\n\n\n\n\n// WEBPACK FOOTER //\n// ./~/@polymer/polymer/lib/elements/dom-module.html","/*__wc__loader*/\nrequire('../../polymer-element.html');\n\nrequire('../utils/templatize.html');\n\nrequire('../utils/debounce.html');\n\nrequire('../utils/flush.html');\n\nrequire('../mixins/mutable-data.html');\n\n\n(function() {\n  'use strict';\n\n  /**\n   * @constructor\n   * @implements {Polymer_OptionalMutableData}\n   * @extends {Polymer.Element}\n   */\n  const domRepeatBase = Polymer.OptionalMutableData(Polymer.Element);\n\n  /**\n   * The `<dom-repeat>` element will automatically stamp and binds one instance\n   * of template content to each object in a user-provided array.\n   * `dom-repeat` accepts an `items` property, and one instance of the template\n   * is stamped for each item into the DOM at the location of the `dom-repeat`\n   * element.  The `item` property will be set on each instance's binding\n   * scope, thus templates should bind to sub-properties of `item`.\n   *\n   * Example:\n   *\n   * ```html\n   * <dom-module id=\"employee-list\">\n   *\n   *   <template>\n   *\n   *     <div> Employee list: </div>\n   *     <template is=\"dom-repeat\" items=\"{{employees}}\">\n   *         <div>First name: <span>{{item.first}}</span></div>\n   *         <div>Last name: <span>{{item.last}}</span></div>\n   *     </template>\n   *\n   *   </template>\n   *\n   *   <script>\n   *     Polymer({\n   *       is: 'employee-list',\n   *       ready: function() {\n   *         this.employees = [\n   *             {first: 'Bob', last: 'Smith'},\n   *             {first: 'Sally', last: 'Johnson'},\n   *             ...\n   *         ];\n   *       }\n   *     });\n   *   < /script>\n   *\n   * </dom-module>\n   * ```\n   *\n   * Notifications for changes to items sub-properties will be forwarded to template\n   * instances, which will update via the normal structured data notification system.\n   *\n   * Mutations to the `items` array itself should me made using the Array\n   * mutation API's on `Polymer.Base` (`push`, `pop`, `splice`, `shift`,\n   * `unshift`), and template instances will be kept in sync with the data in the\n   * array.\n   *\n   * Events caught by event handlers within the `dom-repeat` template will be\n   * decorated with a `model` property, which represents the binding scope for\n   * each template instance.  The model is an instance of Polymer.Base, and should\n   * be used to manipulate data on the instance, for example\n   * `event.model.set('item.checked', true);`.\n   *\n   * Alternatively, the model for a template instance for an element stamped by\n   * a `dom-repeat` can be obtained using the `modelForElement` API on the\n   * `dom-repeat` that stamped it, for example\n   * `this.$.domRepeat.modelForElement(event.target).set('item.checked', true);`.\n   * This may be useful for manipulating instance data of event targets obtained\n   * by event handlers on parents of the `dom-repeat` (event delegation).\n   *\n   * A view-specific filter/sort may be applied to each `dom-repeat` by supplying a\n   * `filter` and/or `sort` property.  This may be a string that names a function on\n   * the host, or a function may be assigned to the property directly.  The functions\n   * should implemented following the standard `Array` filter/sort API.\n   *\n   * In order to re-run the filter or sort functions based on changes to sub-fields\n   * of `items`, the `observe` property may be set as a space-separated list of\n   * `item` sub-fields that should cause a re-filter/sort when modified.  If\n   * the filter or sort function depends on properties not contained in `items`,\n   * the user should observe changes to those properties and call `render` to update\n   * the view based on the dependency change.\n   *\n   * For example, for an `dom-repeat` with a filter of the following:\n   *\n   * ```js\n   * isEngineer: function(item) {\n   *     return item.type == 'engineer' || item.manager.type == 'engineer';\n   * }\n   * ```\n   *\n   * Then the `observe` property should be configured as follows:\n   *\n   * ```html\n   * <template is=\"dom-repeat\" items=\"{{employees}}\"\n   *           filter=\"isEngineer\" observe=\"type manager.type\">\n   * ```\n   *\n   * @polymerElement\n   * @memberof Polymer\n   * @extends Polymer.Element\n   * @mixes Polymer.MutableData\n   * @summary Custom element for stamping instance of a template bound to\n   *   items in an array.\n   */\n  class DomRepeat extends domRepeatBase {\n\n    // Not needed to find template; can be removed once the analyzer\n    // can find the tag name from customElements.define call\n    static get is() { return 'dom-repeat'; }\n\n    static get template() { return null; }\n\n    static get properties() {\n\n      /**\n       * Fired whenever DOM is added or removed by this template (by\n       * default, rendering occurs lazily).  To force immediate rendering, call\n       * `render`.\n       *\n       * @event dom-change\n       */\n      return {\n\n        /**\n         * An array containing items determining how many instances of the template\n         * to stamp and that that each template instance should bind to.\n         */\n        items: {\n          type: Array\n        },\n\n        /**\n         * The name of the variable to add to the binding scope for the array\n         * element associated with a given template instance.\n         */\n        as: {\n          type: String,\n          value: 'item'\n        },\n\n        /**\n         * The name of the variable to add to the binding scope with the index\n         * of the instance in the sorted and filtered list of rendered items.\n         * Note, for the index in the `this.items` array, use the value of the\n         * `itemsIndexAs` property.\n         */\n        indexAs: {\n          type: String,\n          value: 'index'\n        },\n\n        /**\n         * The name of the variable to add to the binding scope with the index\n         * of the instance in the `this.items` array. Note, for the index of\n         * this instance in the sorted and filtered list of rendered items,\n         * use the value of the `indexAs` property.\n         */\n        itemsIndexAs: {\n          type: String,\n          value: 'itemsIndex'\n        },\n\n        /**\n         * A function that should determine the sort order of the items.  This\n         * property should either be provided as a string, indicating a method\n         * name on the element's host, or else be an actual function.  The\n         * function should match the sort function passed to `Array.sort`.\n         * Using a sort function has no effect on the underlying `items` array.\n         */\n        sort: {\n          type: Function,\n          observer: '__sortChanged'\n        },\n\n        /**\n         * A function that can be used to filter items out of the view.  This\n         * property should either be provided as a string, indicating a method\n         * name on the element's host, or else be an actual function.  The\n         * function should match the sort function passed to `Array.filter`.\n         * Using a filter function has no effect on the underlying `items` array.\n         */\n        filter: {\n          type: Function,\n          observer: '__filterChanged'\n        },\n\n        /**\n         * When using a `filter` or `sort` function, the `observe` property\n         * should be set to a space-separated list of the names of item\n         * sub-fields that should trigger a re-sort or re-filter when changed.\n         * These should generally be fields of `item` that the sort or filter\n         * function depends on.\n         */\n        observe: {\n          type: String,\n          observer: '__observeChanged'\n        },\n\n        /**\n         * When using a `filter` or `sort` function, the `delay` property\n         * determines a debounce time after a change to observed item\n         * properties that must pass before the filter or sort is re-run.\n         * This is useful in rate-limiting shuffing of the view when\n         * item changes may be frequent.\n         */\n        delay: Number,\n\n        /**\n         * Count of currently rendered items after `filter` (if any) has been applied.\n         * If \"chunking mode\" is enabled, `renderedItemCount` is updated each time a\n         * set of template instances is rendered.\n         *\n         */\n        renderedItemCount: {\n          type: Number,\n          notify: true,\n          readOnly: true\n        },\n\n        /**\n         * Defines an initial count of template instances to render after setting\n         * the `items` array, before the next paint, and puts the `dom-repeat`\n         * into \"chunking mode\".  The remaining items will be created and rendered\n         * incrementally at each animation frame therof until all instances have\n         * been rendered.\n         */\n        initialCount: {\n          type: Number,\n          observer: '__initializeChunking'\n        },\n\n        /**\n         * When `initialCount` is used, this property defines a frame rate to\n         * target by throttling the number of instances rendered each frame to\n         * not exceed the budget for the target frame rate.  Setting this to a\n         * higher number will allow lower latency and higher throughput for\n         * things like event handlers, but will result in a longer time for the\n         * remaining items to complete rendering.\n         */\n        targetFramerate: {\n          type: Number,\n          value: 20\n        },\n\n        _targetFrameTime: {\n          type: Number,\n          computed: '__computeFrameTime(targetFramerate)'\n        }\n\n      }\n\n    }\n\n    static get observers() {\n      return [ '__itemsChanged(items.*)' ]\n    }\n\n    constructor() {\n      super();\n      this.__instances = [];\n      this.__limit = Infinity;\n      this.__pool = [];\n      this.__renderDebouncer = null;\n      this.__itemsIdxToInstIdx = {};\n      this.__chunkCount = null;\n      this.__lastChunkTime = null;\n      this.__needFullRefresh = false;\n      this.__sortFn = null;\n      this.__filterFn = null;\n      this.__observePaths = null;\n      this.__ctor = null;\n    }\n\n    disconnectedCallback() {\n      super.disconnectedCallback();\n      this.__isDetached = true;\n      for (let i=0; i<this.__instances.length; i++) {\n        this.__detachInstance(i);\n      }\n    }\n\n    connectedCallback() {\n      super.connectedCallback();\n      // only perform attachment if the element was previously detached.\n      if (this.__isDetached) {\n        this.__isDetached = false;\n        let parent = this.parentNode;\n        for (let i=0; i<this.__instances.length; i++) {\n          this.__attachInstance(i, parent);\n        }\n      }\n    }\n\n    __ensureTemplatized() {\n      // Templatizing (generating the instance constructor) needs to wait\n      // until ready, since won't have its template content handed back to\n      // it until then\n      if (!this.__ctor) {\n        let template = this.template = this.querySelector('template');\n        if (!template) {\n          // // Wait until childList changes and template should be there by then\n          let observer = new MutationObserver(() => {\n            if (this.querySelector('template')) {\n              observer.disconnect();\n              this.__render();\n            } else {\n              throw new Error('dom-repeat requires a <template> child');\n            }\n          })\n          observer.observe(this, {childList: true});\n          return false;\n        }\n        // Template instance props that should be excluded from forwarding\n        let instanceProps = {};\n        instanceProps[this.as] = true;\n        instanceProps[this.indexAs] = true;\n        instanceProps[this.itemsIndexAs] = true;\n        this.__ctor = Polymer.Templatize.templatize(template, this, {\n          mutableData: this.mutableData,\n          parentModel: true,\n          instanceProps: instanceProps,\n          forwardHostProp: function(prop, value) {\n            let i$ = this.__instances;\n            for (let i=0, inst; (i<i$.length) && (inst=i$[i]); i++) {\n              inst.forwardHostProp(prop, value);\n            }\n          },\n          notifyInstanceProp: function(inst, prop, value) {\n            if (Polymer.Path.matches(this.as, prop)) {\n              let idx = inst[this.itemsIndexAs];\n              if (prop == this.as) {\n                this.items[idx] = value;\n              }\n              let path = Polymer.Path.translate(this.as, 'items.' + idx, prop);\n              this.notifyPath(path, value);\n            }\n          }\n        });\n      }\n      return true;\n    }\n\n    __getMethodHost() {\n      // Technically this should be the owner of the outermost template.\n      // In shadow dom, this is always getRootNode().host, but we can\n      // approximate this via cooperation with our dataHost always setting\n      // `_methodHost` as long as there were bindings (or id's) on this\n      // instance causing it to get a dataHost.\n      return this.__dataHost._methodHost || this.__dataHost;\n    }\n\n    __sortChanged(sort) {\n      let methodHost = this.__getMethodHost();\n      this.__sortFn = sort && (typeof sort == 'function' ? sort :\n        function() { return methodHost[sort].apply(methodHost, arguments); });\n      this.__needFullRefresh = true;\n      if (this.items) {\n        this.__debounceRender(this.__render);\n      }\n    }\n\n    __filterChanged(filter) {\n      let methodHost = this.__getMethodHost();\n      this.__filterFn = filter && (typeof filter == 'function' ? filter :\n        function() { return methodHost[filter].apply(methodHost, arguments); });\n      this.__needFullRefresh = true;\n      if (this.items) {\n        this.__debounceRender(this.__render);\n      }\n    }\n\n    __computeFrameTime(rate) {\n      return Math.ceil(1000/rate);\n    }\n\n    __initializeChunking() {\n      if (this.initialCount) {\n        this.__limit = this.initialCount;\n        this.__chunkCount = this.initialCount;\n        this.__lastChunkTime = performance.now();\n      }\n    }\n\n    __tryRenderChunk() {\n      // Debounced so that multiple calls through `_render` between animation\n      // frames only queue one new rAF (e.g. array mutation & chunked render)\n      if (this.items && this.__limit < this.items.length) {\n        this.__debounceRender(this.__requestRenderChunk);\n      }\n    }\n\n    __requestRenderChunk() {\n      requestAnimationFrame(()=>this.__renderChunk());\n    }\n\n    __renderChunk() {\n      // Simple auto chunkSize throttling algorithm based on feedback loop:\n      // measure actual time between frames and scale chunk count by ratio\n      // of target/actual frame time\n      let currChunkTime = performance.now();\n      let ratio = this._targetFrameTime / (currChunkTime - this.__lastChunkTime);\n      this.__chunkCount = Math.round(this.__chunkCount * ratio) || 1;\n      this.__limit += this.__chunkCount;\n      this.__lastChunkTime = currChunkTime;\n      this.__debounceRender(this.__render);\n    }\n\n    __observeChanged() {\n      this.__observePaths = this.observe &&\n        this.observe.replace('.*', '.').split(' ');\n    }\n\n    __itemsChanged(change) {\n      if (this.items && !Array.isArray(this.items)) {\n        console.warn('dom-repeat expected array for `items`, found', this.items);\n      }\n      // If path was to an item (e.g. 'items.3' or 'items.3.foo'), forward the\n      // path to that instance synchronously (retuns false for non-item paths)\n      if (!this.__handleItemPath(change.path, change.value)) {\n        // Otherwise, the array was reset ('items') or spliced ('items.splices'),\n        // so queue a full refresh\n        this.__needFullRefresh = true;\n        this.__initializeChunking();\n        this.__debounceRender(this.__render);\n      }\n    }\n\n    __handleObservedPaths(path) {\n      if (this.__observePaths) {\n        path = path.substring(path.indexOf('.') + 1);\n        let paths = this.__observePaths;\n        for (let i=0; i<paths.length; i++) {\n          if (path.indexOf(paths[i]) === 0) {\n            this.__needFullRefresh = true;\n            this.__debounceRender(this.__render, this.delay);\n            return true;\n          }\n        }\n      }\n    }\n\n    /**\n     * @param {function()} fn Function to debounce.\n     * @param {number=} delay Delay in ms to debounce by.\n     */\n    __debounceRender(fn, delay) {\n      this.__renderDebouncer = Polymer.Debouncer.debounce(\n            this.__renderDebouncer\n          , delay > 0 ? Polymer.Async.timeOut.after(delay) : Polymer.Async.microTask\n          , fn.bind(this));\n      Polymer.enqueueDebouncer(this.__renderDebouncer);\n    }\n\n    /**\n     * Forces the element to render its content. Normally rendering is\n     * asynchronous to a provoking change. This is done for efficiency so\n     * that multiple changes trigger only a single render. The render method\n     * should be called if, for example, template rendering is required to\n     * validate application state.\n     */\n    render() {\n      // Queue this repeater, then flush all in order\n      this.__needFullRefresh = true;\n      this.__debounceRender(this.__render);\n      Polymer.flush();\n    }\n\n    __render() {\n      if (!this.__ensureTemplatized()) {\n        // No template found yet\n        return;\n      }\n      this.__applyFullRefresh();\n      // Reset the pool\n      // TODO(kschaaf): Reuse pool across turns and nested templates\n      // Now that objects/arrays are re-evaluated when set, we can safely\n      // reuse pooled instances across turns, however we still need to decide\n      // semantics regarding how long to hold, how many to hold, etc.\n      this.__pool.length = 0;\n      // Set rendered item count\n      this._setRenderedItemCount(this.__instances.length);\n      // Notify users\n      this.dispatchEvent(new CustomEvent('dom-change', {\n        bubbles: true,\n        composed: true\n      }));\n      // Check to see if we need to render more items\n      this.__tryRenderChunk();\n    }\n\n    __applyFullRefresh() {\n      const items = this.items || [];\n      let isntIdxToItemsIdx = new Array(items.length);\n      for (let i=0; i<items.length; i++) {\n        isntIdxToItemsIdx[i] = i;\n      }\n      // Apply user filter\n      if (this.__filterFn) {\n        isntIdxToItemsIdx = isntIdxToItemsIdx.filter((i, idx, array) =>\n          this.__filterFn(items[i], idx, array));\n      }\n      // Apply user sort\n      if (this.__sortFn) {\n        isntIdxToItemsIdx.sort((a, b) => this.__sortFn(items[a], items[b]));\n      }\n      // items->inst map kept for item path forwarding\n      const itemsIdxToInstIdx = this.__itemsIdxToInstIdx = {};\n      let instIdx = 0;\n      // Generate instances and assign items\n      const limit = Math.min(isntIdxToItemsIdx.length, this.__limit);\n      for (; instIdx<limit; instIdx++) {\n        let inst = this.__instances[instIdx];\n        let itemIdx = isntIdxToItemsIdx[instIdx];\n        let item = items[itemIdx];\n        itemsIdxToInstIdx[itemIdx] = instIdx;\n        if (inst && instIdx < this.__limit) {\n          inst._setPendingProperty(this.as, item);\n          inst._setPendingProperty(this.indexAs, instIdx);\n          inst._setPendingProperty(this.itemsIndexAs, itemIdx);\n          inst._flushProperties();\n        } else {\n          this.__insertInstance(item, instIdx, itemIdx);\n        }\n      }\n      // Remove any extra instances from previous state\n      for (let i=this.__instances.length-1; i>=instIdx; i--) {\n        this.__detachAndRemoveInstance(i);\n      }\n    }\n\n    __detachInstance(idx) {\n      let inst = this.__instances[idx];\n      for (let i=0; i<inst.children.length; i++) {\n        let el = inst.children[i];\n        inst.root.appendChild(el);\n      }\n      return inst;\n    }\n\n    __attachInstance(idx, parent) {\n      let inst = this.__instances[idx];\n      parent.insertBefore(inst.root, this);\n    }\n\n    __detachAndRemoveInstance(idx) {\n      let inst = this.__detachInstance(idx);\n      if (inst) {\n        this.__pool.push(inst);\n      }\n      this.__instances.splice(idx, 1);\n    }\n\n    __stampInstance(item, instIdx, itemIdx) {\n      let model = {};\n      model[this.as] = item;\n      model[this.indexAs] = instIdx;\n      model[this.itemsIndexAs] = itemIdx;\n      return new this.__ctor(model);\n    }\n\n    __insertInstance(item, instIdx, itemIdx) {\n      let inst = this.__pool.pop();\n      if (inst) {\n        // TODO(kschaaf): If the pool is shared across turns, hostProps\n        // need to be re-set to reused instances in addition to item\n        inst._setPendingProperty(this.as, item);\n        inst._setPendingProperty(this.indexAs, instIdx);\n        inst._setPendingProperty(this.itemsIndexAs, itemIdx);\n        inst._flushProperties();\n      } else {\n        inst = this.__stampInstance(item, instIdx, itemIdx);\n      }\n      let beforeRow = this.__instances[instIdx + 1];\n      let beforeNode = beforeRow ? beforeRow.children[0] : this;\n      this.parentNode.insertBefore(inst.root, beforeNode);\n      this.__instances[instIdx] = inst;\n      return inst;\n    }\n\n    // Implements extension point from Templatize mixin\n    _showHideChildren(hidden) {\n      for (let i=0; i<this.__instances.length; i++) {\n        this.__instances[i]._showHideChildren(hidden);\n      }\n    }\n\n    // Called as a side effect of a host items.<key>.<path> path change,\n    // responsible for notifying item.<path> changes to inst for key\n    __handleItemPath(path, value) {\n      let itemsPath = path.slice(6); // 'items.'.length == 6\n      let dot = itemsPath.indexOf('.');\n      let itemsIdx = dot < 0 ? itemsPath : itemsPath.substring(0, dot);\n      // If path was index into array...\n      if (itemsIdx == parseInt(itemsIdx, 10)) {\n        let itemSubPath = dot < 0 ? '' : itemsPath.substring(dot+1);\n        // See if the item subpath should trigger a full refresh...\n        if (!this.__handleObservedPaths(itemSubPath)) {\n          // If not, forward to the instance for that index\n          let instIdx = this.__itemsIdxToInstIdx[itemsIdx];\n          let inst = this.__instances[instIdx];\n          if (inst) {\n            let itemPath = this.as + (itemSubPath ? '.' + itemSubPath : '');\n            // This is effectively `notifyPath`, but avoids some of the overhead\n            // of the public API\n            inst._setPendingPropertyOrPath(itemPath, value, false, true);\n            inst._flushProperties();\n          }\n        }\n        return true;\n      }\n    }\n\n    /**\n     * Returns the item associated with a given element stamped by\n     * this `dom-repeat`.\n     *\n     * Note, to modify sub-properties of the item,\n     * `modelForElement(el).set('item.<sub-prop>', value)`\n     * should be used.\n     *\n     * @param {HTMLElement} el Element for which to return the item.\n     * @return {*} Item associated with the element.\n     */\n    itemForElement(el) {\n      let instance = this.modelForElement(el);\n      return instance && instance[this.as];\n    }\n\n    /**\n     * Returns the inst index for a given element stamped by this `dom-repeat`.\n     * If `sort` is provided, the index will reflect the sorted order (rather\n     * than the original array order).\n     *\n     * @param {HTMLElement} el Element for which to return the index.\n     * @return {*} Row index associated with the element (note this may\n     *   not correspond to the array index if a user `sort` is applied).\n     */\n    indexForElement(el) {\n      let instance = this.modelForElement(el);\n      return instance && instance[this.indexAs];\n    }\n\n    /**\n     * Returns the template \"model\" associated with a given element, which\n     * serves as the binding scope for the template instance the element is\n     * contained in. A template model is an instance of `Polymer.Base`, and\n     * should be used to manipulate data associated with this template instance.\n     *\n     * Example:\n     *\n     *   let model = modelForElement(el);\n     *   if (model.index < 10) {\n     *     model.set('item.checked', true);\n     *   }\n     *\n     * @param {HTMLElement} el Element for which to return a template model.\n     * @return {TemplateInstanceBase} Model representing the binding scope for\n     *   the element.\n     */\n    modelForElement(el) {\n      return Polymer.Templatize.modelForElement(this.template, el);\n    }\n\n  }\n\n  customElements.define(DomRepeat.is, DomRepeat);\n\n  Polymer.DomRepeat = DomRepeat;\n\n})();\n\n\n\n\n\n// WEBPACK FOOTER //\n// ./~/@polymer/polymer/lib/elements/dom-repeat.html","/*__wc__loader*/\nrequire('../utils/boot.html');\n\nrequire('../utils/mixin.html');\n\nrequire('../utils/case-map.html');\n\nrequire('../utils/style-gather.html');\n\nrequire('../utils/resolve-url.html');\n\nrequire('../elements/dom-module.html');\n\nrequire('./property-effects.html');\n\n\n(function() {\n  'use strict';\n  /**\n   * @typedef Object<string, {\n   *   value: *,\n   *   type: (Function | undefined),\n   *   readOnly: (boolean | undefined),\n   *   computed: (string | undefined),\n   *   reflectToAttribute: (boolean | undefined),\n   *   notify: (boolean | undefined),\n   *   observer: (string | undefined)\n   * }>)\n   */\n  let PolymerElementProperties; // eslint-disable-line no-unused-vars\n\n  /** @record */\n  let PolymerElementConstructor = function(){}; // eslint-disable-line no-unused-vars\n  /** @type {(string | undefined)} */\n  PolymerElementConstructor.is;\n  /** @type {(string | undefined)} */\n  PolymerElementConstructor.extends;\n  /** @type {(!PolymerElementProperties | undefined)} */\n  PolymerElementConstructor.properties;\n  /** @type {(!Array<string> | undefined)} */\n  PolymerElementConstructor.observers;\n  /** @type {(!HTMLTemplateElement | string | undefined)} */\n  PolymerElementConstructor.template;\n\n  /**\n   * Element class mixin that provides the core API for Polymer's meta-programming\n   * features including template stamping, data-binding, attribute deserialization,\n   * and property change observation.\n   *\n   * Subclassers may provide the following static getters to return metadata\n   * used to configure Polymer's features for the class:\n   *\n   * - `static get is()`: When the template is provided via a `dom-module`,\n   *   users should return the `dom-module` id from a static `is` getter.  If\n   *   no template is needed or the template is provided directly via the\n   *   `template` getter, there is no need to define `is` for the element.\n   *\n   * - `static get template()`: Users may provide the template directly (as\n   *   opposed to via `dom-module`) by implementing a static `template` getter.\n   *   The getter may return an `HTMLTemplateElement` or a string, which will\n   *   automatically be parsed into a template.\n   *\n   * - `static get properties()`: Should return an object describing\n   *   property-related metadata used by Polymer features (key: property name\n   *   value: object containing property metadata). Valid keys in per-property\n   *   metadata include:\n   *   - `type` (String|Number|Object|Array|...): Used by\n   *     `attributeChangedCallback` to determine how string-based attributes\n   *     are deserialized to JavaScript property values.\n   *   - `notify` (boolean): Causes a change in the property to fire a\n   *     non-bubbling event called `<property>-changed`. Elements that have\n   *     enabled two-way binding to the property use this event to observe changes.\n   *   - `readOnly` (boolean): Creates a getter for the property, but no setter.\n   *     To set a read-only property, use the private setter method\n   *     `_setProperty(property, value)`.\n   *   - `observer` (string): Observer method name that will be called when\n   *     the property changes. The arguments of the method are\n   *     `(value, previousValue)`.\n   *   - `computed` (string): String describing method and dependent properties\n   *     for computing the value of this property (e.g. `'computeFoo(bar, zot)'`).\n   *     Computed properties are read-only by default and can only be changed\n   *     via the return value of the computing method.\n   *\n   * - `static get observers()`: Array of strings describing multi-property\n   *   observer methods and their dependent properties (e.g.\n   *   `'observeABC(a, b, c)'`).\n   *\n   * The base class provides default implementations for the following standard\n   * custom element lifecycle callbacks; users may override these, but should\n   * call the super method to ensure\n   * - `constructor`: Run when the element is created or upgraded\n   * - `connectedCallback`: Run each time the element is connected to the\n   *   document\n   * - `disconnectedCallback`: Run each time the element is disconnected from\n   *   the document\n   * - `attributeChangedCallback`: Run each time an attribute in\n   *   `observedAttributes` is set or removed (note: this element's default\n   *   `observedAttributes` implementation will automatically return an array\n   *   of dash-cased attributes based on `properties`)\n   *\n   * @polymerMixin\n   * @mixes Polymer.PropertyEffects\n   * @memberof Polymer\n   * @property rootPath {string} Set to the value of `Polymer.rootPath`,\n   *   which defaults to the main document path\n   * @property importPath {string} Set to the value of the class's static\n   *   `importPath` property, which defaults to the path of this element's\n   *   `dom-module` (when `is` is used), but can be overridden for other\n   *   import strategies.\n   * @summary Element class mixin that provides the core API for Polymer's\n   * meta-programming features.\n   */\n  Polymer.ElementMixin = Polymer.dedupingMixin(base => {\n\n    /**\n     * @constructor\n     * @extends {base}\n     * @implements {Polymer_PropertyEffects}\n     */\n    const polymerElementBase = Polymer.PropertyEffects(base);\n\n    let caseMap = Polymer.CaseMap;\n\n    /**\n     * Returns the `properties` object specifically on `klass`. Use for:\n     * (1) super chain mixes togther to make `propertiesForClass` which is\n     * then used to make `observedAttributes`.\n     * (2) properties effects and observers are created from it at `finalize` time.\n     *\n     * @param {HTMLElement} klass Element class\n     * @return {Object} Object containing own properties for this class\n     * @private\n     */\n    function ownPropertiesForClass(klass) {\n      if (!klass.hasOwnProperty(\n        JSCompiler_renameProperty('__ownProperties', klass))) {\n        klass.__ownProperties =\n          klass.hasOwnProperty(JSCompiler_renameProperty('properties', klass)) ?\n          klass.properties : {};\n      }\n      return klass.__ownProperties;\n    }\n\n    /**\n     * Returns the `observers` array specifically on `klass`. Use for\n     * setting up observers.\n     *\n     * @param {HTMLElement} klass Element class\n     * @return {Array} Array containing own observers for this class\n     * @private\n     */\n    function ownObserversForClass(klass) {\n      if (!klass.hasOwnProperty(\n        JSCompiler_renameProperty('__ownObservers', klass))) {\n        klass.__ownObservers =\n          klass.hasOwnProperty(JSCompiler_renameProperty('observers', klass)) ?\n          klass.observers : [];\n      }\n      return klass.__ownObservers;\n    }\n\n    /**\n     * Mixes `props` into `flattenedProps` but upgrades shorthand type\n     * syntax to { type: Type}.\n     *\n     * @param {Object} flattenedProps Bag to collect flattened properties into\n     * @param {Object} props Bag of properties to add to `flattenedProps`\n     * @return {Objecg} The input `flattenedProps` bag\n     * @private\n     */\n    function flattenProperties(flattenedProps, props) {\n      for (let p in props) {\n        let o = props[p];\n        if (typeof o == 'function') {\n          o = { type: o };\n        }\n        flattenedProps[p] = o;\n      }\n      return flattenedProps;\n    }\n\n    /**\n     * Returns a flattened list of properties mixed together from the chain of all\n     * constructor's `config.properties`. This list is used to create\n     * (1) observedAttributes,\n     * (2) class property default values\n     *\n     * @param {HTMLElement} klass Element class\n     * @return {PolymerElementProperties} Flattened properties for this class\n     * @private\n     */\n    function propertiesForClass(klass) {\n      if (!klass.hasOwnProperty(\n        JSCompiler_renameProperty('__classProperties', klass))) {\n        klass.__classProperties =\n        flattenProperties({}, ownPropertiesForClass(klass));\n        let superCtor = Object.getPrototypeOf(klass.prototype).constructor;\n        if (superCtor.prototype instanceof PolymerElement) {\n          klass.__classProperties = Object.assign(\n            Object.create(propertiesForClass(superCtor)),\n            klass.__classProperties);\n        }\n      }\n      return klass.__classProperties;\n    }\n\n    /**\n     * Returns a list of properties with default values.\n     * This list is created as an optimization since it is a subset of\n     * the list returned from `propertiesForClass`.\n     * This list is used in `_initializeProperties` to set property defaults.\n     *\n     * @param {HTMLElement} klass Element class\n     * @return {PolymerElementProperties} Flattened properties for this class\n     *   that have default values\n     * @private\n     */\n    function propertyDefaultsForClass(klass) {\n      if (!klass.hasOwnProperty(\n        JSCompiler_renameProperty('__classPropertyDefaults', klass))) {\n        klass.__classPropertyDefaults = null;\n        let props = propertiesForClass(klass);\n        for (let p in props) {\n          let info = props[p];\n          if ('value' in info) {\n            klass.__classPropertyDefaults = klass.__classPropertyDefaults || {};\n            klass.__classPropertyDefaults[p] = info;\n          }\n        }\n      }\n      return klass.__classPropertyDefaults;\n    }\n\n    /**\n     * Returns true if a `klass` has finalized. Called in `ElementClass.finalize()`\n     * @param {HTMLElement} klass Element class\n     * @return {boolean} True if all metaprogramming for this class has been\n     *   completed\n     * @private\n     */\n    function hasClassFinalized(klass) {\n      return klass.hasOwnProperty(JSCompiler_renameProperty('__finalized', klass));\n    }\n\n    /**\n     * Called by `ElementClass.finalize()`. Ensures this `klass` and\n     * *all superclasses* are finalized by traversing the prototype chain\n     * and calling `klass.finalize()`.\n     *\n     * @param {HTMLElement} klass Element class\n     * @private\n     */\n    function finalizeClassAndSuper(klass) {\n      let proto = klass.prototype;\n      let superCtor = Object.getPrototypeOf(proto).constructor;\n      if (superCtor.prototype instanceof PolymerElement) {\n        superCtor.finalize();\n      }\n      finalizeClass(klass);\n    }\n\n    /**\n     * Configures a `klass` based on a staic `klass.config` object and\n     * a `template`. This includes creating accessors and effects\n     * for properties in `config` and the `template` as well as preparing the\n     * `template` for stamping.\n     *\n     * @param {HTMLElement} klass Element class\n     * @private\n     */\n    function finalizeClass(klass) {\n      klass.__finalized = true;\n      let proto = klass.prototype;\n      if (klass.hasOwnProperty(\n        JSCompiler_renameProperty('is', klass)) && klass.is) {\n        Polymer.telemetry.register(proto);\n      }\n      let props = ownPropertiesForClass(klass);\n      if (props) {\n        finalizeProperties(proto, props);\n      }\n      let observers = ownObserversForClass(klass);\n      if (observers) {\n        finalizeObservers(proto, observers, props);\n      }\n      // note: create \"working\" template that is finalized at instance time\n      let template = klass.template;\n      if (template) {\n        if (typeof template === 'string') {\n          let t = document.createElement('template');\n          t.innerHTML = template;\n          template = t;\n        } else {\n          template = template.cloneNode(true);\n        }\n        proto._template = template;\n      }\n    }\n\n    /**\n     * Configures a `proto` based on a `properties` object.\n     * Leverages `PropertyEffects` to create property accessors and effects\n     * supporting, observers, reflecting to attributes, change notification,\n     * computed properties, and read only properties.\n     * @param {HTMLElement} proto Element class prototype to add accessors\n     *    and effects to\n     * @param {Object} properties Flattened bag of property descriptors for\n     *    this class\n     * @private\n     */\n    function finalizeProperties(proto, properties) {\n      for (let p in properties) {\n        createPropertyFromConfig(proto, p, properties[p], properties);\n      }\n    }\n\n    /**\n     * Configures a `proto` based on a `observers` array.\n     * Leverages `PropertyEffects` to create observers.\n     * @param {HTMLElement} proto Element class prototype to add accessors\n     *   and effects to\n     * @param {Object} observers Flattened array of observer descriptors for\n     *   this class\n     * @param {Object} dynamicFns Object containing keys for any properties\n     *   that are functions and should trigger the effect when the function\n     *   reference is changed\n     * @private\n     */\n    function finalizeObservers(proto, observers, dynamicFns) {\n      for (let i=0; i < observers.length; i++) {\n        proto._createMethodObserver(observers[i], dynamicFns);\n      }\n    }\n\n    /**\n     * Creates effects for a property.\n     *\n     * Note, once a property has been set to\n     * `readOnly`, `computed`, `reflectToAttribute`, or `notify`\n     * these values may not be changed. For example, a subclass cannot\n     * alter these settings. However, additional `observers` may be added\n     * by subclasses.\n     *\n     * The info object should may contain property metadata as follows:\n     *\n     * * `type`: {function} type to which an attribute matching the property\n     * is deserialized. Note the property is camel-cased from a dash-cased\n     * attribute. For example, 'foo-bar' attribute is dersialized to a\n     * property named 'fooBar'.\n     *\n     * * `readOnly`: {boolean} creates a readOnly property and\n     * makes a private setter for the private of the form '_setFoo' for a\n     * property 'foo',\n     *\n     * * `computed`: {string} creates a computed property. A computed property\n     * also automatically is set to `readOnly: true`. The value is calculated\n     * by running a method and arguments parsed from the given string. For\n     * example 'compute(foo)' will compute a given property when the\n     * 'foo' property changes by executing the 'compute' method. This method\n     * must return the computed value.\n     *\n     * * `reflectToAttriute`: {boolean} If true, the property value is reflected\n     * to an attribute of the same name. Note, the attribute is dash-cased\n     * so a property named 'fooBar' is reflected as 'foo-bar'.\n     *\n     * * `notify`: {boolean} sends a non-bubbling notification event when\n     * the property changes. For example, a property named 'foo' sends an\n     * event named 'foo-changed' with `event.detail` set to the value of\n     * the property.\n     *\n     * * observer: {string} name of a method that runs when the property\n     * changes. The arguments of the method are (value, previousValue).\n     *\n     * Note: Users may want control over modifying property\n     * effects via subclassing. For example, a user might want to make a\n     * reflectToAttribute property not do so in a subclass. We've chosen to\n     * disable this because it leads to additional complication.\n     * For example, a readOnly effect generates a special setter. If a subclass\n     * disables the effect, the setter would fail unexpectedly.\n     * Based on feedback, we may want to try to make effects more malleable\n     * and/or provide an advanced api for manipulating them.\n     * Also consider adding warnings when an effect cannot be changed.\n     *\n     * @param {HTMLElement} proto Element class prototype to add accessors\n     *   and effects to\n     * @param {string} name Name of the property.\n     * @param {Object} info Info object from which to create property effects.\n     * Supported keys:\n     * @param {Object} allProps Flattened map of all properties defined in this\n     *   element (including inherited properties)\n     * @private\n     */\n    function createPropertyFromConfig(proto, name, info, allProps) {\n      // computed forces readOnly...\n      if (info.computed) {\n        info.readOnly = true;\n      }\n      // Note, since all computed properties are readOnly, this prevents\n      // adding additional computed property effects (which leads to a confusing\n      // setup where multiple triggers for setting a property)\n      // While we do have `hasComputedEffect` this is set on the property's\n      // dependencies rather than itself.\n      if (info.computed  && !proto._hasReadOnlyEffect(name)) {\n        proto._createComputedProperty(name, info.computed, allProps);\n      }\n      if (info.readOnly && !proto._hasReadOnlyEffect(name)) {\n        proto._createReadOnlyProperty(name, !info.computed);\n      }\n      if (info.reflectToAttribute && !proto._hasReflectEffect(name)) {\n        proto._createReflectedProperty(name);\n      }\n      if (info.notify && !proto._hasNotifyEffect(name)) {\n        proto._createNotifyingProperty(name);\n      }\n      // always add observer\n      if (info.observer) {\n        proto._createPropertyObserver(name, info.observer, allProps[info.observer]);\n      }\n    }\n\n    /**\n     * Configures an element `proto` to function with a given `template`.\n     * The element name `is` and extends `ext` must be specified for ShadyCSS\n     * style scoping.\n     *\n     * @param {HTMLElement} proto Element class prototype to add accessors\n     *   and effects to\n     * @param {HTMLTemplateElement} template Template to process and bind\n     * @param {string} baseURI URL against which to resolve urls in\n     *   style element cssText\n     * @param {string} is Tag name (or type extension name) for this element\n     * @param {string=} ext For type extensions, the tag name that was extended\n     * @private\n     */\n    function finalizeTemplate(proto, template, baseURI, is, ext) {\n      // support `include=\"module-name\"`\n      let cssText =\n        Polymer.StyleGather.cssFromTemplate(template, baseURI) +\n        Polymer.StyleGather.cssFromModuleImports(is);\n      if (cssText) {\n        let style = document.createElement('style');\n        style.textContent = cssText;\n        template.content.insertBefore(style, template.content.firstChild);\n      }\n      if (window.ShadyCSS) {\n        window.ShadyCSS.prepareTemplate(template, is, ext);\n      }\n      proto._bindTemplate(template);\n    }\n\n    /**\n     * @polymerMixinClass\n     * @unrestricted\n     * @implements {Polymer_ElementMixin}\n     */\n    class PolymerElement extends polymerElementBase {\n\n      /**\n       * Standard Custom Elements V1 API.  The default implementation returns\n       * a list of dash-cased attributes based on a flattening of all properties\n       * declared in `static get properties()` for this element and any\n       * superclasses.\n       *\n       * @return {Array} Observed attribute list\n       */\n      static get observedAttributes() {\n        if (!this.hasOwnProperty(JSCompiler_renameProperty('__observedAttributes', this))) {\n          let list = [];\n          let properties = propertiesForClass(this);\n          for (let prop in properties) {\n            list.push(Polymer.CaseMap.camelToDashCase(prop));\n          }\n          this.__observedAttributes = list;\n        }\n        return this.__observedAttributes;\n      }\n\n      /**\n       * Called automatically when the first element instance is created to\n       * ensure that class finalization work has been completed.\n       * May be called by users to eagerly perform class finalization work\n       * prior to the creation of the first element instance.\n       *\n       * Class finalization work generally includes meta-programming such as\n       * creating property accessors and any property effect metadata needed for\n       * the features used.\n       *\n       * @public\n       */\n      static finalize() {\n        if (!hasClassFinalized(this)) {\n          finalizeClassAndSuper(this);\n        }\n      }\n\n      /**\n       * Returns the template that will be stamped into this element's shadow root.\n       *\n       * If a `static get is()` getter is defined, the default implementation\n       * will return the first `<template>` in a `dom-module` whose `id`\n       * matches this element's `is`.\n       *\n       * Users may override this getter to return an arbitrary template\n       * (in which case the `is` getter is unnecessary). The template returned\n       * may be either an `HTMLTemplateElement` or a string that will be\n       * automatically parsed into a template.\n       *\n       * Note that when subclassing, if the super class overrode the default\n       * implementation and the subclass would like to provide an alternate\n       * template via a `dom-module`, it should override this getter and\n       * return `Polymer.DomModule.import(this.is, 'template')`.\n       *\n       * If a subclass would like to modify the super class template, it should\n       * clone it rather than modify it in place.  If the getter does expensive\n       * work such as cloning/modifying a template, it should memoize the\n       * template for maximum performance:\n       *\n       *   let memoizedTemplate;\n       *   class MySubClass extends MySuperClass {\n       *     static get template() {\n       *       if (!memoizedTemplate) {\n       *         memoizedTemplate = super.template.cloneNode(true);\n       *         let subContent = document.createElement('div');\n       *         subContent.textContent = 'This came from MySubClass';\n       *         memoizedTemplate.content.appendChild(subContent);\n       *       }\n       *       return memoizedTemplate;\n       *     }\n       *   }\n       *\n       * @return {HTMLTemplateElement|string} Template to be stamped\n       */\n      static get template() {\n        if (!this.hasOwnProperty(JSCompiler_renameProperty('_template', this))) {\n          this._template = Polymer.DomModule.import(this.is, 'template') ||\n            // note: implemented so a subclass can retrieve the super\n            // template; call the super impl this way so that `this` points\n            // to the superclass.\n            Object.getPrototypeOf(this.prototype).constructor.template;\n        }\n        return this._template;\n      }\n\n      /**\n       * Path matching the url from which the element was imported.\n       * This path is used to resolve url's in template style cssText.\n       * The `importPath` property is also set on element instances and can be\n       * used to create bindings relative to the import path.\n       * Defaults to the path matching the url containing a `dom-module` element\n       * matching this element's static `is` property.\n       * Note, this path should contain a trailing `/`.\n       *\n       * @return {string} The import path for this element class\n       */\n      static get importPath() {\n        if (!this.hasOwnProperty(JSCompiler_renameProperty('_importPath', this))) {\n            const module = Polymer.DomModule.import(this.is);\n            this._importPath = module ? module.assetpath : '' ||\n            Object.getPrototypeOf(this.prototype).constructor.importPath;\n        }\n        return this._importPath;\n      }\n\n      /**\n       * Overrides the default `Polymer.PropertyAccessors` to ensure class\n       * metaprogramming related to property accessors and effects has\n       * completed (calls `finalize`).\n       *\n       * It also initializes any property defaults provided via `value` in\n       * `properties` metadata.\n       *\n       * @override\n       */\n      _initializeProperties() {\n        Polymer.telemetry.instanceCount++;\n        this.constructor.finalize();\n        const importPath = this.constructor.importPath;\n        // note: finalize template when we have access to `localName` to\n        // avoid dependence on `is` for polyfilling styling.\n        if (this._template && !this._template.__polymerFinalized) {\n          this._template.__polymerFinalized = true;\n          const baseURI =\n            importPath ? Polymer.ResolveUrl.resolveUrl(importPath) : '';\n          finalizeTemplate(this.__proto__, this._template, baseURI,\n            this.localName);\n        }\n        super._initializeProperties();\n        // set path defaults\n        this.rootPath = Polymer.rootPath;\n        this.importPath = importPath;\n        // apply property defaults...\n        let p$ = propertyDefaultsForClass(this.constructor);\n        if (!p$) {\n          return;\n        }\n        for (let p in p$) {\n          let info = p$[p];\n          // Don't set default value if there is already an own property, which\n          // happens when a `properties` property with default but no effects had\n          // a property set (e.g. bound) by its host before upgrade\n          if (!this.hasOwnProperty(p)) {\n            let value = typeof info.value == 'function' ?\n              info.value.call(this) :\n              info.value;\n            // Set via `_setProperty` if there is an accessor, to enable\n            // initializing readOnly property defaults\n            if (this._hasAccessor(p)) {\n              this._setPendingProperty(p, value, true);\n            } else {\n              this[p] = value;\n            }\n          }\n        }\n      }\n\n      /**\n       * Provides a default implementation of the standard Custom Elements\n       * `connectedCallback`.\n       *\n       * The default implementation enables the property effects system and\n       * flushes any pending properties, and updates shimmed CSS properties\n       * when using the ShadyCSS scoping/custom properties polyfill.\n       *\n       * @override\n       */\n      connectedCallback() {\n        if (window.ShadyCSS && this._template) {\n          window.ShadyCSS.styleElement(this);\n        }\n        this._enableProperties();\n      }\n\n      /**\n       * Provides a default implementation of the standard Custom Elements\n       * `disconnectedCallback`.\n       *\n       * @override\n       */\n      disconnectedCallback() {}\n\n      /**\n       * Stamps the element template.\n       *\n       * @override\n       */\n      ready() {\n        if (this._template) {\n          this.root = this._stampTemplate(this._template);\n          this.$ = this.root.$;\n        }\n        super.ready();\n      }\n\n      /**\n       * Implements `PropertyEffects`'s `_readyClients` call. Attaches\n       * element dom by calling `_attachDom` with the dom stamped from the\n       * element's template via `_stampTemplate`. Note that this allows\n       * client dom to be attached to the element prior to any observers\n       * running.\n       *\n       * @override\n       */\n      _readyClients() {\n        if (this._template) {\n          this.root = this._attachDom(this.root);\n        }\n        // The super._readyClients here sets the clients initialized flag.\n        // We must wait to do this until after client dom is created/attached\n        // so that this flag can be checked to prevent notifications fired\n        // during this process from being handled before clients are ready.\n        super._readyClients();\n      }\n\n\n      /**\n       * Attaches an element's stamped dom to itself. By default,\n       * this method creates a `shadowRoot` and adds the dom to it.\n       * However, this method may be overridden to allow an element\n       * to put its dom in another location.\n       *\n       * @throws {Error}\n       * @suppress {missingReturn}\n       * @param {NodeList} dom to attach to the element.\n       * @return {Node} node to which the dom has been attached.\n       */\n      _attachDom(dom) {\n        if (this.attachShadow) {\n          if (dom) {\n            if (!this.shadowRoot) {\n              this.attachShadow({mode: 'open'});\n            }\n            this.shadowRoot.appendChild(dom);\n            return this.shadowRoot;\n          }\n        } else {\n          throw new Error('ShadowDOM not available. ' +\n            // TODO(sorvell): move to compile-time conditional when supported\n          'Polymer.Element can create dom as children instead of in ' +\n          'ShadowDOM by setting `this.root = this;\\` before \\`ready\\`.');\n        }\n      }\n\n      /**\n       * Provides a default implementation of the standard Custom Elements\n       * `attributeChangedCallback`.\n       *\n       * By default, attributes declared in `properties` metadata are\n       * deserialized using their `type` information to properties of the\n       * same name.  \"Dash-cased\" attributes are deserialzed to \"camelCase\"\n       * properties.\n       *\n       * @override\n       */\n      attributeChangedCallback(name, old, value) {\n        if (old !== value) {\n          let property = caseMap.dashToCamelCase(name);\n          let type = propertiesForClass(this.constructor)[property].type;\n          if (!this._hasReadOnlyEffect(property)) {\n            this._attributeToProperty(name, value, type);\n          }\n        }\n      }\n\n      /**\n       * When using the ShadyCSS scoping and custom property shim, causes all\n       * shimmed styles in this element (and its subtree) to be updated\n       * based on current custom property values.\n       *\n       * The optional parameter overrides inline custom property styles with an\n       * object of properties where the keys are CSS properties, and the values\n       * are strings.\n       *\n       * Example: `this.updateStyles({'--color': 'blue'})`\n       *\n       * These properties are retained unless a value of `null` is set.\n       *\n       * @param {Object=} properties Bag of custom property key/values to\n       *   apply to this element.\n       */\n      updateStyles(properties) {\n        if (window.ShadyCSS) {\n          window.ShadyCSS.styleSubtree(this, properties);\n        }\n      }\n\n      /**\n       * Rewrites a given URL relative to a base URL. The base URL defaults to\n       * the original location of the document containing the `dom-module` for\n       * this element. This method will return the same URL before and after\n       * bundling.\n       *\n       * @param {string} url URL to resolve.\n       * @param {string=} base Optional base URL to resolve against, defaults\n       * to the element's `importPath`\n       * @return {string} Rewritten URL relative to base\n       */\n      resolveUrl(url, base) {\n        if (!base && this.importPath) {\n          base = Polymer.ResolveUrl.resolveUrl(this.importPath);\n        }\n        return Polymer.ResolveUrl.resolveUrl(url, base);\n      }\n\n      /**\n       * Overrides `PropertyAccessors` to add map of dynamic functions on\n       * template info, for consumption by `PropertyEffects` template binding\n       * code. This map determines which method templates should have accessors\n       * created for them.\n       *\n       * @override\n       */\n      static _parseTemplateContent(template, templateInfo, nodeInfo) {\n        templateInfo.dynamicFns = templateInfo.dynamicFns || propertiesForClass(this);\n        return super._parseTemplateContent(template, templateInfo, nodeInfo);\n      }\n\n    }\n\n    return PolymerElement;\n  });\n\n  /**\n   * Provides basic tracking of element definitions (registrations) and\n   * instance counts.\n   *\n   * @namespace\n   * @summary Provides basic tracking of element definitions (registrations) and\n   * instance counts.\n   */\n  Polymer.telemetry = {\n    /**\n     * Total number of Polymer element instances created.\n     * @type {number}\n     */\n    instanceCount: 0,\n    /**\n     * Array of Polymer element classes that have been finalized.\n     * @type {Array<Polymer.Element>}\n     */\n    registrations: [],\n    /**\n     * @param {HTMLElement} prototype Element prototype to log\n     * @private\n     */\n    _regLog: function(prototype) {\n      console.log('[' + prototype.is + ']: registered')\n    },\n    /**\n     * Registers a class prototype for telemetry purposes.\n     * @param {HTMLElement} prototype Element prototype to register\n     * @protected\n     */\n    register: function(prototype) {\n      this.registrations.push(prototype);\n      Polymer.log && this._regLog(prototype);\n    },\n    /**\n     * Logs all elements registered with an `is` to the console.\n     * @public\n     */\n    dumpRegistrations: function() {\n      this.registrations.forEach(this._regLog);\n    }\n  };\n\n  /**\n   * When using the ShadyCSS scoping and custom property shim, causes all\n   * shimmed `styles` (via `custom-style`) in the document (and its subtree)\n   * to be updated based on current custom property values.\n   *\n   * The optional parameter overrides inline custom property styles with an\n   * object of properties where the keys are CSS properties, and the values\n   * are strings.\n   *\n   * Example: `Polymer.updateStyles({'--color': 'blue'})`\n   *\n   * These properties are retained unless a value of `null` is set.\n   *\n   * @param {Object=} props Bag of custom property key/values to\n   *   apply to the document.\n   */\n  Polymer.updateStyles = function(props) {\n    if (window.ShadyCSS) {\n      window.ShadyCSS.styleDocument(props);\n    }\n  };\n\n  /**\n   * Globally settable property that is automatically assigned to\n   * `Polymer.ElementMixin` instances, useful for binding in templates to\n   * make URL's relative to an application's root.  Defaults to the main\n   * document URL, but can be overridden by users.  It may be useful to set\n   * `Polymer.rootPath` to provide a stable application mount path when\n   * using client side routing.\n   *\n   * @memberof Polymer\n   */\n  Polymer.rootPath = Polymer.rootPath ||\n    Polymer.ResolveUrl.pathFromUrl(document.baseURI || window.location.href);\n\n})();\n\n\n\n\n// WEBPACK FOOTER //\n// ./~/@polymer/polymer/lib/mixins/element-mixin.html","/*__wc__loader*/\nrequire('../utils/boot.html');\n\nrequire('../utils/mixin.html');\n\nrequire('../utils/case-map.html');\n\nrequire('../utils/async.html');\n\n\n(function() {\n\n  'use strict';\n\n  let caseMap = Polymer.CaseMap;\n\n  let microtask = Polymer.Async.microTask;\n\n  // Save map of native properties; this forms a blacklist or properties\n  // that won't have their values \"saved\" by `saveAccessorValue`, since\n  // reading from an HTMLElement accessor from the context of a prototype throws\n  const nativeProperties = {};\n  let proto = HTMLElement.prototype;\n  while (proto) {\n    let props = Object.getOwnPropertyNames(proto);\n    for (let i=0; i<props.length; i++) {\n      nativeProperties[props[i]] = true;\n    }\n    proto = Object.getPrototypeOf(proto);\n  }\n\n  /**\n   * Used to save the value of a property that will be overridden with\n   * an accessor. If the `model` is a prototype, the values will be saved\n   * in `__dataProto`, and it's up to the user (or downstream mixin) to\n   * decide how/when to set these values back into the accessors.\n   * If `model` is already an instance (it has a `__data` property), then\n   * the value will be set as a pending property, meaning the user should\n   * call `_invalidateProperties` or `_flushProperties` to take effect\n   *\n   * @param {Object} model Prototype or instance\n   * @param {string} property Name of property\n   * @private\n   */\n  function saveAccessorValue(model, property) {\n    // Don't read/store value for any native properties since they could throw\n    if (!nativeProperties[property]) {\n      let value = model[property];\n      if (value !== undefined) {\n        if (model.__data) {\n          // Adding accessor to instance; update the property\n          // It is the user's responsibility to call _flushProperties\n          model._setPendingProperty(property, value);\n        } else {\n          // Adding accessor to proto; save proto's value for instance-time use\n          if (!model.__dataProto) {\n            model.__dataProto = {};\n          } else if (!model.hasOwnProperty(JSCompiler_renameProperty('__dataProto', model))) {\n            model.__dataProto = Object.create(model.__dataProto);\n          }\n          model.__dataProto[property] = value;\n        }\n      }\n    }\n  }\n\n  /**\n   * Element class mixin that provides basic meta-programming for creating one\n   * or more property accessors (getter/setter pair) that enqueue an async\n   * (batched) `_propertiesChanged` callback.\n   *\n   * For basic usage of this mixin, simply declare attributes to observe via\n   * the standard `static get observedAttributes()`, implement `_propertiesChanged`\n   * on the class, and then call `MyClass.createPropertiesForAttributes()` once\n   * on the class to generate property accessors for each observed attribute\n   * prior to instancing.  Last, call `this._flushProperties()` once to enable\n   * the accessors.\n   *\n   * Any `observedAttributes` will automatically be\n   * deserialized via `attributeChangedCallback` and set to the associated\n   * property using `dash-case`-to-`camelCase` convention.\n   *\n   * @polymerMixin\n   * @memberof Polymer\n   * @summary Element class mixin for reacting to property changes from\n   *   generated property accessors.\n   */\n  Polymer.PropertyAccessors = Polymer.dedupingMixin(superClass => {\n\n    /**\n     * @polymerMixinClass\n     * @implements {Polymer_PropertyAccessors}\n     * @unrestricted\n     */\n    class PropertyAccessors extends superClass {\n\n      /**\n       * Generates property accessors for all attributes in the standard\n       * static `observedAttributes` array.\n       *\n       * Attribute names are mapped to property names using the `dash-case` to\n       * `camelCase` convention\n       *\n       */\n      static createPropertiesForAttributes() {\n        let a$ = this.observedAttributes;\n        for (let i=0; i < a$.length; i++) {\n          this.prototype._createPropertyAccessor(caseMap.dashToCamelCase(a$[i]));\n        }\n      }\n\n      constructor() {\n        super();\n        this._initializeProperties();\n      }\n\n      attributeChangedCallback(name, old, value) {\n        if (old !== value) {\n          this._attributeToProperty(name, value);\n        }\n      }\n\n      /**\n       * Initializes the local storage for property accessors.\n       *\n       * Provided as an override point for performing any setup work prior\n       * to initializing the property accessor system.\n       *\n       * @protected\n       */\n      _initializeProperties() {\n        this.__serializing = false;\n        this.__dataCounter = 0;\n        this.__dataEnabled = false;\n        this.__dataReady = false;\n        this.__dataInvalid = false;\n        // initialize data with prototype values saved when creating accessors\n        this.__data = {};\n        this.__dataPending = null;\n        this.__dataOld = null;\n        if (this.__dataProto) {\n          this._initializeProtoProperties(this.__dataProto);\n          this.__dataProto = null;\n        }\n        // Capture instance properties; these will be set into accessors\n        // during first flush. Don't set them here, since we want\n        // these to overwrite defaults/constructor assignments\n        for (let p in this.__dataHasAccessor) {\n          if (this.hasOwnProperty(p)) {\n            this.__dataInstanceProps = this.__dataInstanceProps || {};\n            this.__dataInstanceProps[p] = this[p];\n            delete this[p];\n          }\n        }\n      }\n\n      /**\n       * Called at instance time with bag of properties that were overwritten\n       * by accessors on the prototype when accessors were created.\n       *\n       * The default implementation sets these properties back into the\n       * setter at instance time.  This method is provided as an override\n       * point for customizing or providing more efficient initialization.\n       *\n       * @param {Object} props Bag of property values that were overwritten\n       *   when creating property accessors.\n       * @protected\n       */\n      _initializeProtoProperties(props) {\n        for (let p in props) {\n          this._setProperty(p, props[p]);\n        }\n      }\n\n      /**\n       * Called at ready time with bag of instance properties that overwrote\n       * accessors when the element upgraded.\n       *\n       * The default implementation sets these properties back into the\n       * setter at ready time.  This method is provided as an override\n       * point for customizing or providing more efficient initialization.\n       *\n       * @param {Object} props Bag of property values that were overwritten\n       *   when creating property accessors.\n       * @protected\n       */\n      _initializeInstanceProperties(props) {\n        Object.assign(this, props);\n      }\n\n      /**\n       * Ensures the element has the given attribute. If it does not,\n       * assigns the given value to the attribute.\n       *\n       *\n       * @param {string} attribute Name of attribute to ensure is set.\n       * @param {string} value of the attribute.\n       */\n      _ensureAttribute(attribute, value) {\n        if (!this.hasAttribute(attribute)) {\n          this._valueToNodeAttribute(this, value, attribute);\n        }\n      }\n\n      /**\n       * Deserializes an attribute to its associated property.\n       *\n       * This method calls the `_deserializeValue` method to convert the string to\n       * a typed value.\n       *\n       * @param {string} attribute Name of attribute to deserialize.\n       * @param {string} value of the attribute.\n       * @param {*} type type to deserialize to.\n       */\n      _attributeToProperty(attribute, value, type) {\n        // Don't deserialize back to property if currently reflecting\n        if (!this.__serializing) {\n          let property = caseMap.dashToCamelCase(attribute);\n          this[property] = this._deserializeValue(value, type);\n        }\n      }\n\n      /**\n       * Serializes a property to its associated attribute.\n       *\n       * @param {string} property Property name to reflect.\n       * @param {string=} attribute Attribute name to reflect.\n       * @param {*=} value Property value to refect.\n       */\n      _propertyToAttribute(property, attribute, value) {\n        this.__serializing = true;\n        value = (arguments.length < 3) ? this[property] : value;\n        this._valueToNodeAttribute(this, value,\n          attribute || caseMap.camelToDashCase(property));\n        this.__serializing = false;\n      }\n\n      /**\n       * Sets a typed value to an HTML attribute on a node.\n       *\n       * This method calls the `_serializeValue` method to convert the typed\n       * value to a string.  If the `_serializeValue` method returns `undefined`,\n       * the attribute will be removed (this is the default for boolean\n       * type `false`).\n       *\n       * @param {Element} node Element to set attribute to.\n       * @param {*} value Value to serialize.\n       * @param {string} attribute Attribute name to serialize to.\n       */\n      _valueToNodeAttribute(node, value, attribute) {\n        let str = this._serializeValue(value);\n        if (str === undefined) {\n          node.removeAttribute(attribute);\n        } else {\n          node.setAttribute(attribute, str);\n        }\n      }\n\n      /**\n       * Converts a typed JavaScript value to a string.\n       *\n       * This method is called by Polymer when setting JS property values to\n       * HTML attributes.  Users may override this method on Polymer element\n       * prototypes to provide serialization for custom types.\n       *\n       * @param {*} value Property value to serialize.\n       * @return {string | undefined} String serialized from the provided property value.\n       */\n      _serializeValue(value) {\n        /* eslint-disable no-fallthrough */\n        switch (typeof value) {\n          case 'boolean':\n            return value ? '' : undefined;\n\n          case 'object':\n            if (value instanceof Date) {\n              return value.toString();\n            } else if (value) {\n              try {\n                return JSON.stringify(value);\n              } catch(x) {\n                return '';\n              }\n            }\n\n          default:\n            return value != null ? value.toString() : undefined;\n        }\n      }\n\n      /**\n       * Converts a string to a typed JavaScript value.\n       *\n       * This method is called by Polymer when reading HTML attribute values to\n       * JS properties.  Users may override this method on Polymer element\n       * prototypes to provide deserialization for custom `type`s.  Note,\n       * the `type` argument is the value of the `type` field provided in the\n       * `properties` configuration object for a given property, and is\n       * by convention the constructor for the type to deserialize.\n       *\n       * Note: The return value of `undefined` is used as a sentinel value to\n       * indicate the attribute should be removed.\n       *\n       * @param {string} value Attribute value to deserialize.\n       * @param {*} type Type to deserialize the string to.\n       * @return {*} Typed value deserialized from the provided string.\n       */\n      _deserializeValue(value, type) {\n        /**\n         * @type {*}\n         */\n        let outValue;\n        switch (type) {\n          case Number:\n            outValue = Number(value);\n            break;\n\n          case Boolean:\n            outValue = (value !== null);\n            break;\n\n          case Object:\n            try {\n              outValue = JSON.parse(value);\n            } catch(x) {\n              // allow non-JSON literals like Strings and Numbers\n            }\n            break;\n\n          case Array:\n            try {\n              outValue = JSON.parse(value);\n            } catch(x) {\n              outValue = null;\n              console.warn(`Polymer::Attributes: couldn't decode Array as JSON: ${value}`);\n            }\n            break;\n\n          case Date:\n            outValue = new Date(value);\n            break;\n\n          case String:\n          default:\n            outValue = value;\n            break;\n        }\n\n        return outValue;\n      }\n      /* eslint-enable no-fallthrough */\n\n      /**\n       * Creates a setter/getter pair for the named property with its own\n       * local storage.  The getter returns the value in the local storage,\n       * and the setter calls `_setProperty`, which updates the local storage\n       * for the property and enqueues a `_propertiesChanged` callback.\n       *\n       * This method may be called on a prototype or an instance.  Calling\n       * this method may overwrite a property value that already exists on\n       * the prototype/instance by creating the accessor.  When calling on\n       * a prototype, any overwritten values are saved in `__dataProto`,\n       * and it is up to the subclasser to decide how/when to set those\n       * properties back into the accessor.  When calling on an instance,\n       * the overwritten value is set via `_setPendingProperty`, and the\n       * user should call `_invalidateProperties` or `_flushProperties`\n       * for the values to take effect.\n       *\n       * @param {string} property Name of the property\n       * @param {boolean=} readOnly When true, no setter is created; the\n       *   protected `_setProperty` function must be used to set the property\n       * @protected\n       */\n      _createPropertyAccessor(property, readOnly) {\n        if (!this.hasOwnProperty('__dataHasAccessor')) {\n          this.__dataHasAccessor = Object.assign({}, this.__dataHasAccessor);\n        }\n        if (!this.__dataHasAccessor[property]) {\n          this.__dataHasAccessor[property] = true;\n          saveAccessorValue(this, property);\n          Object.defineProperty(this, property, {\n            get: function() {\n              return this.__data[property];\n            },\n            set: readOnly ? function() { } : function(value) {\n              this._setProperty(property, value);\n            }\n          });\n        }\n      }\n\n      /**\n       * Returns true if this library created an accessor for the given property.\n       *\n       * @param {string} property Property name\n       * @return {boolean} True if an accessor was created\n       */\n      _hasAccessor(property) {\n        return this.__dataHasAccessor && this.__dataHasAccessor[property];\n      }\n\n      /**\n       * Updates the local storage for a property (via `_setPendingProperty`)\n       * and enqueues a `_proeprtiesChanged` callback.\n       *\n       * @param {string} property Name of the property\n       * @param {*} value Value to set\n       * @protected\n       */\n      _setProperty(property, value) {\n        if (this._setPendingProperty(property, value)) {\n          this._invalidateProperties();\n        }\n      }\n\n      /**\n       * Updates the local storage for a property, records the previous value,\n       * and adds it to the set of \"pending changes\" that will be passed to the\n       * `_propertiesChanged` callback.  This method does not enqueue the\n       * `_propertiesChanged` callback.\n       *\n       * @param {string} property Name of the property\n       * @param {*} value Value to set\n       * @return {boolean} Returns true if the property changed\n       * @protected\n       */\n      _setPendingProperty(property, value) {\n        let old = this.__data[property];\n        if (this._shouldPropertyChange(property, value, old)) {\n          if (!this.__dataPending) {\n            this.__dataPending = {};\n            this.__dataOld = {};\n          }\n          // Ensure old is captured from the last turn\n          if (!(property in this.__dataOld)) {\n            this.__dataOld[property] = old;\n          }\n          this.__data[property] = value;\n          this.__dataPending[property] = value;\n          return true;\n        }\n      }\n\n      /**\n       * Returns true if the specified property has a pending change.\n       *\n       * @param {string} prop Property name\n       * @return {boolean} True if property has a pending change\n       * @protected\n       */\n      _isPropertyPending(prop) {\n        return this.__dataPending && (prop in this.__dataPending);\n      }\n\n      /**\n       * Marks the properties as invalid, and enqueues an async\n       * `_propertiesChanged` callback.\n       *\n       * @protected\n       */\n      _invalidateProperties() {\n        if (!this.__dataInvalid && this.__dataReady) {\n          this.__dataInvalid = true;\n          microtask.run(() => {\n            if (this.__dataInvalid) {\n              this.__dataInvalid = false;\n              this._flushProperties();\n            }\n          });\n        }\n      }\n\n      /**\n       * Call to enable property accessor processing. Before this method is\n       * called accessor values will be set but side effects are\n       * queued. When called, any pending side effects occur immediately.\n       * For elements, generally `connectedCallback` is a normal spot to do so.\n       * It is safe to call this method multiple times as it only turns on\n       * property accessors once.\n       */\n      _enableProperties() {\n        if (!this.__dataEnabled) {\n          this.__dataEnabled = true;\n          if (this.__dataInstanceProps) {\n            this._initializeInstanceProperties(this.__dataInstanceProps);\n            this.__dataInstanceProps = null;\n          }\n          this.ready()\n        }\n      }\n\n      /**\n       * Calls the `_propertiesChanged` callback with the current set of\n       * pending changes (and old values recorded when pending changes were\n       * set), and resets the pending set of changes. Generally, this method\n       * should not be called in user code.\n       *\n       *\n       * @protected\n       */\n      _flushProperties() {\n        if (this.__dataPending) {\n          let changedProps = this.__dataPending;\n          this.__dataPending = null;\n          this.__dataCounter++;\n          this._propertiesChanged(this.__data, changedProps, this.__dataOld);\n          this.__dataCounter--;\n        }\n      }\n\n      /**\n       * Lifecycle callback called the first time properties are being flushed.\n       * Prior to `ready`, all property sets through accessors are queued and\n       * their effects are flushed after this method returns.\n       *\n       * Users may override this function to implement behavior that is\n       * dependent on the element having its properties initialized, e.g.\n       * from defaults (initialized from `constructor`, `_initializeProperties`),\n       * `attributeChangedCallback`, or values propagated from host e.g. via\n       * bindings.  `super.ready()` must be called to ensure the data system\n       * becomes enabled.\n       *\n       * @public\n       */\n      ready() {\n        this.__dataReady = true;\n        // Run normal flush\n        this._flushProperties();\n      }\n\n      /**\n       * Callback called when any properties with accessors created via\n       * `_createPropertyAccessor` have been set.\n       *\n       * @param {Object} currentProps Bag of all current accessor values\n       * @param {Object} changedProps Bag of properties changed since the last\n       *   call to `_propertiesChanged`\n       * @param {Object} oldProps Bag of previous values for each property\n       *   in `changedProps`\n       * @protected\n       */\n      _propertiesChanged(currentProps, changedProps, oldProps) { // eslint-disable-line no-unused-vars\n      }\n\n      /**\n       * Method called to determine whether a property value should be\n       * considered as a change and cause the `_propertiesChanged` callback\n       * to be enqueued.\n       *\n       * The default implementation returns `true` for primitive types if a\n       * strict equality check fails, and returns `true` for all Object/Arrays.\n       * The method always returns false for `NaN`.\n       *\n       * Override this method to e.g. provide stricter checking for\n       * Objects/Arrays when using immutable patterns.\n       *\n       * @param {string} property Property name\n       * @param {*} value New property value\n       * @param {*} old Previous property value\n       * @return {boolean} Whether the property should be considered a change\n       *   and enqueue a `_proeprtiesChanged` callback\n       * @protected\n       */\n      _shouldPropertyChange(property, value, old) {\n        return (\n          // Strict equality check\n          (old !== value &&\n           // This ensures (old==NaN, value==NaN) always returns false\n           (old === old || value === value))\n        );\n      }\n\n    }\n\n    return PropertyAccessors;\n\n  });\n\n})();\n\n\n\n\n// WEBPACK FOOTER //\n// ./~/@polymer/polymer/lib/mixins/property-accessors.html","/*__wc__loader*/\nrequire('../utils/boot.html');\n\nrequire('../utils/mixin.html');\n\n\n(function() {\n\n  'use strict';\n\n  // 1.x backwards-compatible auto-wrapper for template type extensions\n  // This is a clear layering violation and gives favored-nation status to\n  // dom-if and dom-repeat templates.  This is a conceit we're choosing to keep\n  // a.) to ease 1.x backwards-compatibility due to loss of `is`, and\n  // b.) to maintain if/repeat capability in parser-constrained elements\n  //     (e.g. table, select) in lieu of native CE type extensions without\n  //     massive new invention in this space (e.g. directive system)\n  const templateExtensions = {\n    'dom-if': true,\n    'dom-repeat': true\n  };\n  function wrapTemplateExtension(node) {\n    let is = node.getAttribute('is');\n    if (is && templateExtensions[is]) {\n      let t = node;\n      t.removeAttribute('is');\n      node = t.ownerDocument.createElement(is);\n      t.parentNode.replaceChild(node, t);\n      node.appendChild(t);\n      while(t.attributes.length) {\n        node.setAttribute(t.attributes[0].name, t.attributes[0].value);\n        t.removeAttribute(t.attributes[0].name);\n      }\n    }\n    return node;\n  }\n\n  function findTemplateNode(root, nodeInfo) {\n    // recursively ascend tree until we hit root\n    let parent = nodeInfo.parentInfo && findTemplateNode(root, nodeInfo.parentInfo);\n    // unwind the stack, returning the indexed node at each level\n    if (parent) {\n      // note: marginally faster than indexing via childNodes\n      // (http://jsperf.com/childnodes-lookup)\n      for (let n=parent.firstChild, i=0; n; n=n.nextSibling) {\n        if (nodeInfo.parentIndex === i++) {\n          return n;\n        }\n      }\n    } else {\n      return root;\n    }\n  }\n\n  // construct `$` map (from id annotations)\n  function applyIdToMap(inst, map, node, nodeInfo) {\n    if (nodeInfo.id) {\n      map[nodeInfo.id] = node;\n    }\n  }\n\n  // install event listeners (from event annotations)\n  function applyEventListener(inst, node, nodeInfo) {\n    if (nodeInfo.events && nodeInfo.events.length) {\n      for (let j=0, e$=nodeInfo.events, e; (j<e$.length) && (e=e$[j]); j++) {\n        inst._addMethodEventListenerToNode(node, e.name, e.value, inst);\n      }\n    }\n  }\n\n  // push configuration references at configure time\n  function applyTemplateContent(inst, node, nodeInfo) {\n    if (nodeInfo.templateInfo) {\n      node._templateInfo = nodeInfo.templateInfo;\n    }\n  }\n\n  function createNodeEventHandler(context, eventName, methodName) {\n    // Instances can optionally have a _methodHost which allows redirecting where\n    // to find methods. Currently used by `templatize`.\n    context = context._methodHost || context;\n    let handler = function(e) {\n      if (context[methodName]) {\n        context[methodName](e, e.detail);\n      } else {\n        console.warn('listener method `' + methodName + '` not defined');\n      }\n    };\n    return handler;\n  }\n\n  /**\n   * Element mixin that provides basic template parsing and stamping, including\n   * the following template-related features for stamped templates:\n   *\n   * - Declarative event listeners (`on-eventname=\"listener\"`)\n   * - Map of node id's to stamped node instances (`this.$.id`)\n   * - Nested template content caching/removal and re-installation (performance\n   *   optimization)\n   *\n   * @polymerMixin\n   * @memberof Polymer\n   * @summary Element class mixin that provides basic template parsing and stamping\n   */\n  Polymer.TemplateStamp = Polymer.dedupingMixin(superClass => {\n\n    /**\n     * @polymerMixinClass\n     * @implements {Polymer_TemplateStamp}\n     */\n    class TemplateStamp extends superClass {\n\n      /**\n       * Scans a template to produce template metadata.\n       *\n       * Template-specific metadata are stored in the object returned, and node-\n       * specific metadata are stored in objects in its flattened `nodeInfoList`\n       * array.  Only nodes in the template that were parsed as nodes of\n       * interest contain an object in `nodeInfoList`.  Each `nodeInfo` object\n       * contains an `index` (`childNodes` index in parent) and optionally\n       * `parent`, which points to node info of its parent (including its index).\n       *\n       * The template metadata object returned from this method has the following\n       * structure (many fields optional):\n       *\n       * ```js\n       *   {\n       *     // Flattened list of node metadata (for nodes that generated metadata)\n       *     nodeInfoList: [\n       *       {\n       *         // `id` attribute for any nodes with id's for generating `$` map\n       *         id: {string},\n       *         // `on-event=\"handler\"` metadata\n       *         events: [\n       *           {\n       *             name: {string},   // event name\n       *             value: {string},  // handler method name\n       *           }, ...\n       *         ],\n       *         // Notes when the template contained a `<slot>` for shady DOM\n       *         // optimization purposes\n       *         hasInsertionPoint: {boolean},\n       *         // For nested `<template>`` nodes, nested template metadata\n       *         templateInfo: {object}, // nested template metadata\n       *         // Metadata to allow efficient retrieval of instanced node\n       *         // corresponding to this metadata\n       *         parentInfo: {number},   // reference to parent nodeInfo>\n       *         parentIndex: {number},  // index in parent's `childNodes` collection\n       *         infoIndex: {number},    // index of this `nodeInfo` in `templateInfo.nodeInfoList`\n       *       },\n       *       ...\n       *     ],\n       *     // When true, the template had the `strip-whitespace` attribute\n       *     // or was nested in a template with that setting\n       *     stripWhitespace: {boolean},\n       *     // For nested templates, nested template content is moved into\n       *     // a document fragment stored here; this is an optimization to\n       *     // avoid the cost of nested template cloning\n       *     content: {DocumentFragment}\n       *   }\n       * ```\n       *\n       * This method kicks off a recursive treewalk as follows:\n       *\n       * ```\n       *    _parseTemplate <---------------------+\n       *      _parseTemplateContent              |\n       *        _parseTemplateNode  <------------|--+\n       *          _parseTemplateNestedTemplate --+  |\n       *          _parseTemplateChildNodes ---------+\n       *          _parseTemplateNodeAttributes\n       *            _parseTemplateNodeAttribute\n       *\n       * ```\n       *\n       * These methods may be overridden to add custom metadata about templates\n       * to either `templateInfo` or `nodeInfo`.\n       *\n       * Note that this method may be destructive to the template, in that\n       * e.g. event annotations may be removed after being noted in the\n       * template metadata.\n       *\n       * @param {HTMLTemplateElement} template Template to parse\n       * @param {Object=} outerTemplateInfo Template metadata from the outer\n       *   template, for parsing nested templates\n       * @return {Object} Parsed template metadata\n       */\n      static _parseTemplate(template, outerTemplateInfo) {\n        // since a template may be re-used, memo-ize metadata\n        if (!template._templateInfo) {\n          let templateInfo = template._templateInfo = {};\n          templateInfo.nodeInfoList = [];\n          templateInfo.stripWhiteSpace =\n            (outerTemplateInfo && outerTemplateInfo.stripWhiteSpace) ||\n            template.hasAttribute('strip-whitespace');\n          this._parseTemplateContent(template, templateInfo, {parent: null});\n        }\n        return template._templateInfo;\n      }\n\n      static _parseTemplateContent(template, templateInfo, nodeInfo) {\n        return this._parseTemplateNode(template.content, templateInfo, nodeInfo);\n      }\n\n      /**\n       * Parses template node and adds template and node metadata based on\n       * the current node, and its `childNodes` and `attributes`.\n       *\n       * This method may be overridden to add custom node or template specific\n       * metadata based on this node.\n       *\n       * @param {Node} node Node to parse\n       * @param {Object} templateInfo Template metadata for current template\n       * @param {Object} nodeInfo Node metadata for current template.\n       * @return {boolean} `true` if the visited node added node-specific\n       *   metadata to `nodeInfo`\n       */\n      static _parseTemplateNode(node, templateInfo, nodeInfo) {\n        let noted;\n        if (node.localName == 'template' && !node.hasAttribute('preserve-content')) {\n          noted = this._parseTemplateNestedTemplate(node, templateInfo, nodeInfo) || noted;\n        } else if (node.localName === 'slot') {\n          // For ShadyDom optimization, indicating there is an insertion point\n          templateInfo.hasInsertionPoint = true;\n        }\n        if (node.firstChild) {\n          noted = this._parseTemplateChildNodes(node, templateInfo, nodeInfo) || noted;\n        }\n        if (node.hasAttributes && node.hasAttributes()) {\n          noted = this._parseTemplateNodeAttributes(node, templateInfo, nodeInfo) || noted;\n        }\n        return noted;\n      }\n\n      /**\n       * Parses template child nodes for the given root node.\n       *\n       * This method also wraps whitelisted legacy template extensions\n       * (`is=\"dom-if\"` and `is=\"dom-repeat\"`) with their equivalent element\n       * wrappers, collapses text nodes, and strips whitespace from the template\n       * if the `templateInfo.stripWhitespace` setting was provided.\n       *\n       * @param {Node} root Root node whose `childNodes` will be parsed\n       * @param {Object} templateInfo Template metadata for current template\n       * @param {Object} nodeInfo Node metadata for current template.\n       */\n      static _parseTemplateChildNodes(root, templateInfo, nodeInfo) {\n        for (let node=root.firstChild, parentIndex=0, next; node; node=next) {\n          // Wrap templates\n          if (node.localName == 'template') {\n            node = wrapTemplateExtension(node);\n          }\n          // collapse adjacent textNodes: fixes an IE issue that can cause\n          // text nodes to be inexplicably split =(\n          // note that root.normalize() should work but does not so we do this\n          // manually.\n          next = node.nextSibling;\n          if (node.nodeType === Node.TEXT_NODE) {\n            let n = next;\n            while (n && (n.nodeType === Node.TEXT_NODE)) {\n              node.textContent += n.textContent;\n              next = n.nextSibling;\n              root.removeChild(n);\n              n = next;\n            }\n            // optionally strip whitespace\n            if (templateInfo.stripWhiteSpace && !node.textContent.trim()) {\n              root.removeChild(node);\n              continue;\n            }\n          }\n          let childInfo = { parentIndex, parentInfo: nodeInfo };\n          if (this._parseTemplateNode(node, templateInfo, childInfo)) {\n            childInfo.infoIndex = templateInfo.nodeInfoList.push(childInfo) - 1;\n          }\n          // Increment if not removed\n          if (node.parentNode) {\n            parentIndex++;\n          }\n        }\n      }\n\n      /**\n       * Parses template content for the given nested `<template>`.\n       *\n       * Nested template info is stored as `templateInfo` in the current node's\n       * `nodeInfo`. `template.content` is removed and stored in `templateInfo`.\n       * It will then be the responsibility of the host to set it back to the\n       * template and for users stamping nested templates to use the\n       * `_contentForTemplate` method to retrieve the content for this template\n       * (an optimization to avoid the cost of cloning nested template content).\n       *\n       * @param {HTMLTemplateElement} node Node to parse (a <template>)\n       * @param {Object} outerTemplateInfo Template metadata for current template\n       *   that includes the template `node`\n       * @param {Object} nodeInfo Node metadata for current template.\n       * @return {boolean} `true` if the visited node added node-specific\n       *   metadata to `nodeInfo`\n       */\n      static _parseTemplateNestedTemplate(node, outerTemplateInfo, nodeInfo) {\n        let templateInfo = this._parseTemplate(node, outerTemplateInfo);\n        let content = templateInfo.content =\n          node.content.ownerDocument.createDocumentFragment();\n        content.appendChild(node.content);\n        nodeInfo.templateInfo = templateInfo;\n        return true;\n      }\n\n      /**\n       * Parses template node attributes and adds node metadata to `nodeInfo`\n       * for nodes of interest.\n       *\n       * @param {Node} node Node to parse\n       * @param {Object} templateInfo Template metadata for current template\n       * @param {Object} nodeInfo Node metadata for current template.\n       * @return {boolean} `true` if the visited node added node-specific\n       *   metadata to `nodeInfo`\n       */\n      static _parseTemplateNodeAttributes(node, templateInfo, nodeInfo) {\n        // Make copy of original attribute list, since the order may change\n        // as attributes are added and removed\n        let noted;\n        let attrs = Array.from(node.attributes);\n        for (let i=attrs.length-1, a; (a=attrs[i]); i--) {\n          noted = this._parseTemplateNodeAttribute(node, templateInfo, nodeInfo, a.name, a.value) || noted;\n        }\n        return noted;\n      }\n\n      /**\n       * Parses a single template node attribute and adds node metadata to\n       * `nodeInfo` for attributes of interest.\n       *\n       * This implementation adds metadata for `on-event=\"handler\"` attributes\n       * and `id` attributes.\n       *\n       * @param {Node} node Node to parse\n       * @param {Object} templateInfo Template metadata for current template\n       * @param {Object} nodeInfo Node metadata for current template.\n       * @param {string} name Attribute name\n       * @param {*} value Attribute value\n       * @return {boolean} `true` if the visited node added node-specific\n       *   metadata to `nodeInfo`\n       */\n      static _parseTemplateNodeAttribute(node, templateInfo, nodeInfo, name, value) {\n        // events (on-*)\n        if (name.slice(0, 3) === 'on-') {\n          node.removeAttribute(name);\n          nodeInfo.events = nodeInfo.events || [];\n          nodeInfo.events.push({\n            name: name.slice(3),\n            value\n          });\n          return true;\n        }\n        // static id\n        else if (name === 'id') {\n          nodeInfo.id = value;\n          return true;\n        }\n      }\n\n      /**\n       * Returns the `content` document fragment for a given template.\n       *\n       * For nested templates, Polymer performs an optimization to cache nested\n       * template content to avoid the cost of cloning deeply nested templates.\n       * This method retrieves the cached content for a given template.\n       *\n       * @param {HTMLTemplateElement} template Template to retrieve `content` for\n       * @return {DocumentFragment} Content fragment\n       */\n      static _contentForTemplate(template) {\n        let templateInfo = template.__templateInfo;\n        return (templateInfo && templateInfo.content) || template.content;\n      }\n\n      /**\n       * Clones the provided template content and returns a document fragment\n       * containing the cloned dom.\n       *\n       * The template is parsed (once and memoized) using this library's\n       * template parsing features, and provides the following value-added\n       * features:\n       * * Adds declarative event listeners for `on-event=\"handler\"` attributes\n       * * Generates an \"id map\" for all nodes with id's under `$` on returned\n       *   document fragment\n       * * Passes template info including `content` back to templates as\n       *   `_templateInfo` (a performance optimization to avoid deep template\n       *   cloning)\n       *\n       * Note that the memoized template parsing process is destructive to the\n       * template: attributes for bindings and declarative event listeners are\n       * removed after being noted in notes, and any nested `<template>.content`\n       * is removed and stored in notes as well.\n       *\n       * @param {HTMLTemplateElement} template Template to stamp\n       * @return {DocumentFragment} Cloned template content\n       */\n      _stampTemplate(template) {\n        // Polyfill support: bootstrap the template if it has not already been\n        if (template && !template.content &&\n            window.HTMLTemplateElement && HTMLTemplateElement.decorate) {\n          HTMLTemplateElement.decorate(template);\n        }\n        let templateInfo = this.constructor._parseTemplate(template);\n        let nodeInfo = templateInfo.nodeInfoList;\n        let content = templateInfo.content || template.content;\n        let dom = document.importNode(content, true);\n        // NOTE: ShadyDom optimization indicating there is an insertion point\n        dom.__noInsertionPoint = !templateInfo.hasInsertionPoint;\n        let nodes = dom.nodeList = new Array(nodeInfo.length);\n        dom.$ = {};\n        for (let i=0, l=nodeInfo.length, info; (i<l) && (info=nodeInfo[i]); i++) {\n          let node = nodes[i] = findTemplateNode(dom, info);\n          applyIdToMap(this, dom.$, node, info);\n          applyTemplateContent(this, node, info);\n          applyEventListener(this, node, info);\n        }\n        return dom;\n      }\n\n      /**\n       * Adds an event listener by method name for the event provided.\n       *\n       * This method generates a handler function that looks up the method\n       * name at handling time.\n       *\n       * @param {Node} node Node to add listener on\n       * @param {string} eventName Name of event\n       * @param {string} methodName Name of method\n       * @param {*=} context Context the method will be called on (defaults\n       *   to `node`)\n       * @return {Function} Generated handler function\n       */\n      _addMethodEventListenerToNode(node, eventName, methodName, context) {\n        context = context || node;\n        let handler = createNodeEventHandler(context, eventName, methodName);\n        this._addEventListenerToNode(node, eventName, handler);\n        return handler;\n      }\n\n      /**\n       * Override point for adding custom or simulated event handling.\n       *\n       * @param {Node} node Node to add event listener to\n       * @param {string} eventName Name of event\n       * @param {Function} handler Listener function to add\n       */\n      _addEventListenerToNode(node, eventName, handler) {\n        node.addEventListener(eventName, handler);\n      }\n\n      /**\n       * Override point for adding custom or simulated event handling.\n       *\n       * @param {Node} node Node to remove event listener from\n       * @param {string} eventName Name of event\n       * @param {Function} handler Listener function to remove\n       */\n      _removeEventListenerFromNode(node, eventName, handler) {\n        node.removeEventListener(eventName, handler);\n      }\n\n    }\n\n    return TemplateStamp;\n\n  });\n\n})();\n\n\n\n\n// WEBPACK FOOTER //\n// ./~/@polymer/polymer/lib/mixins/template-stamp.html","/*__wc__loader*/\nrequire('./boot.html');\n\nrequire('./mixin.html');\n\nrequire('./async.html');\n\n\n(function() {\n  'use strict';\n\n  /** @typedef {{run: function(function(), number=):number, cancel: function(number)}} */\n  let AsyncModule; // eslint-disable-line no-unused-vars\n\n  class Debouncer {\n    constructor() {\n      this._asyncModule = null;\n      this._callback = null;\n      this._timer = null;\n    }\n    /**\n     * Sets the scheduler; that is, a module with the Async interface,\n     * a callback and optional arguments to be passed to the run function\n     * from the async module.\n     *\n     * @param {!AsyncModule} asyncModule Object with Async interface.\n     * @param {function()} callback Callback to run.\n     */\n    setConfig(asyncModule, callback) {\n      this._asyncModule = asyncModule;\n      this._callback = callback;\n      this._timer = this._asyncModule.run(() => {\n        this._timer = null;\n        this._callback()\n      });\n    }\n    /**\n     * Cancels an active debouncer and returns a reference to itself.\n     */\n    cancel() {\n      if (this.isActive()) {\n        this._asyncModule.cancel(this._timer);\n        this._timer = null;\n      }\n    }\n    /**\n     * Flushes an active debouncer and returns a reference to itself.\n     */\n    flush() {\n      if (this.isActive()) {\n        this.cancel();\n        this._callback();\n      }\n    }\n    /**\n     * Returns true if the debouncer is active.\n     *\n     * @return {boolean} True if active.\n     */\n    isActive() {\n      return this._timer != null;\n    }\n  /**\n   * Creates a debouncer if no debouncer is passed as a parameter\n   * or it cancels an active debouncer otherwise. The following\n   * example shows how a debouncer can be called multiple times within a\n   * microtask and \"debounced\" such that the provided callback function is\n   * called once. Add this method to a custom element:\n   *\n   * _debounceWork() {\n   *   this._debounceJob = Polymer.Debouncer.debounce(this._debounceJob,\n   *       Polymer.Async.microTask, () => {\n   *     this._doWork();\n   *   });\n   * }\n   *\n   * If the `_debounceWork` method is called multiple times within the same\n   * microtask, the `_doWork` function will be called only once at the next\n   * microtask checkpoint.\n   *\n   * Note: In testing it is often convenient to avoid asynchrony. To accomplish\n   * this with a debouncer, you can use `Polymer.enqueueDebouncer` and\n   * `Polymer.flush`. For example, extend the above example by adding\n   * `Polymer.enqueueDebouncer(this._debounceJob)` at the end of the\n   * `_debounceWork` method. Then in a test, call `Polymer.flush` to ensure\n   * the debouncer has completed.\n   *\n   * @param {Polymer.Debouncer?} debouncer Debouncer object.\n   * @param {!AsyncModule} asyncModule Object with Async interface\n   * @param {function()} callback Callback to run.\n   * @return {!Debouncer} Returns a debouncer object.\n   */\n    static debounce(debouncer, asyncModule, callback) {\n      if (debouncer instanceof Debouncer) {\n        debouncer.cancel();\n      } else {\n        debouncer = new Debouncer();\n      }\n      debouncer.setConfig(asyncModule, callback);\n      return debouncer;\n    }\n  }\n\n  /**\n   * @memberof Polymer\n   */\n  Polymer.Debouncer = Debouncer;\n})();\n\n\n\n\n// WEBPACK FOOTER //\n// ./~/@polymer/polymer/lib/utils/debounce.html","/*__wc__loader*/\nrequire('./boot.html');\n\n\n(function() {\n  'use strict';\n\n  let debouncerQueue = [];\n\n  /**\n   * Adds a `Polymer.Debouncer` to a list of globally flushable tasks.\n   *\n   * @memberof Polymer\n   * @param {Polymer.Debouncer} debouncer Debouncer to enqueue\n   */\n  Polymer.enqueueDebouncer = function(debouncer) {\n    debouncerQueue.push(debouncer);\n  }\n\n  function flushDebouncers() {\n    const didFlush = Boolean(debouncerQueue.length);\n    while (debouncerQueue.length) {\n      try {\n        debouncerQueue.shift().flush();\n      } catch(e) {\n        setTimeout(() => {\n          throw e;\n        });\n      }\n    }\n    return didFlush;\n  }\n\n  /**\n   * Forces several classes of asynchronously queued tasks to flush:\n   * - Debouncers added via `enqueueDebouncer`\n   * - ShadyDOM distribution\n   *\n   * @memberof Polymer\n   */\n  Polymer.flush = function() {\n    let shadyDOM, debouncers;\n    do {\n      shadyDOM = window.ShadyDOM && ShadyDOM.flush();\n      if (window.ShadyCSS && window.ShadyCSS.ScopingShim) {\n        window.ShadyCSS.ScopingShim.flush();\n      }\n      debouncers = flushDebouncers();\n    } while (shadyDOM || debouncers);\n  }\n\n})();\n\n\n\n\n// WEBPACK FOOTER //\n// ./~/@polymer/polymer/lib/utils/flush.html","/*__wc__loader*/\nrequire('./boot.html');\n\n\n(function() {\n  'use strict';\n\n  /**\n   * Module with utilities for manipulating structured data path strings.\n   *\n   * @namespace\n   * @memberof Polymer\n   * @summary Module with utilities for manipulating structured data path strings.\n   */\n  const Path = {\n\n    /**\n     * Returns true if the given string is a structured data path (has dots).\n     *\n     * Example:\n     *\n     * ```\n     * Polymer.Path.isPath('foo.bar.baz') // true\n     * Polymer.Path.isPath('foo')         // false\n     * ```\n     *\n     * @memberof Polymer.Path\n     * @param {string} path Path string\n     * @return {boolean} True if the string contained one or more dots\n     */\n    isPath: function(path) {\n      return path.indexOf('.') >= 0;\n    },\n\n    /**\n     * Returns the root property name for the given path.\n     *\n     * Example:\n     *\n     * ```\n     * Polymer.Path.root('foo.bar.baz') // 'foo'\n     * Polymer.Path.root('foo')         // 'foo'\n     * ```\n     *\n     * @memberof Polymer.Path\n     * @param {string} path Path string\n     * @return {string} Root property name\n     */\n    root: function(path) {\n      let dotIndex = path.indexOf('.');\n      if (dotIndex === -1) {\n        return path;\n      }\n      return path.slice(0, dotIndex);\n    },\n\n    /**\n     * Given `base` is `foo.bar`, `foo` is an ancestor, `foo.bar` is not\n     * Returns true if the given path is an ancestor of the base path.\n     *\n     * Example:\n     *\n     * ```\n     * Polymer.Path.isAncestor('foo.bar', 'foo')         // true\n     * Polymer.Path.isAncestor('foo.bar', 'foo.bar')     // false\n     * Polymer.Path.isAncestor('foo.bar', 'foo.bar.baz') // false\n     * ```\n     *\n     * @memberof Polymer.Path\n     * @param {string} base Path string to test against.\n     * @param {string} path Path string to test.\n     * @return {boolean} True if `path` is an ancestor of `base`.\n     */\n    isAncestor: function(base, path) {\n      //     base.startsWith(path + '.');\n      return base.indexOf(path + '.') === 0;\n    },\n\n    /**\n     * Given `base` is `foo.bar`, `foo.bar.baz` is an descendant\n     *\n     * Example:\n     *\n     * ```\n     * Polymer.Path.isDescendant('foo.bar', 'foo.bar.baz') // true\n     * Polymer.Path.isDescendant('foo.bar', 'foo.bar')     // false\n     * Polymer.Path.isDescendant('foo.bar', 'foo')         // false\n     * ```\n     *\n     * @memberof Polymer.Path\n     * @param {string} base Path string to test against.\n     * @param {string} path Path string to test.\n     * @return {boolean} True if `path` is a descendant of `base`.\n     */\n    isDescendant: function(base, path) {\n      //     path.startsWith(base + '.');\n      return path.indexOf(base + '.') === 0;\n    },\n\n    /**\n     * Replaces a previous base path with a new base path, preserving the\n     * remainder of the path.\n     *\n     * User must ensure `path` has a prefix of `base`.\n     *\n     * Example:\n     *\n     * ```\n     * Polymer.Path.translate('foo.bar', 'zot' 'foo.bar.baz') // 'zot.baz'\n     * ```\n     *\n     * @memberof Polymer.Path\n     * @param {string} base Current base string to remove\n     * @param {string} newBase New base string to replace with\n     * @param {string} path Path to translate\n     * @return {string} Translated string\n     */\n    translate: function(base, newBase, path) {\n      return newBase + path.slice(base.length);\n    },\n\n    matches: function(base, path) {\n      return (base === path) ||\n             this.isAncestor(base, path) ||\n             this.isDescendant(base, path);\n    },\n\n    /**\n     * Converts array-based paths to flattened path.  String-based paths\n     * are returned as-is.\n     *\n     * Example:\n     *\n     * ```\n     * Polymer.Path.normalize(['foo.bar', 0, 'baz'])  // 'foo.bar.0.baz'\n     * Polymer.Path.normalize('foo.bar.0.baz')        // 'foo.bar.0.baz'\n     * ```\n     *\n     * @memberof Polymer.Path\n     * @param {string | !Array<string|number>} path Input path\n     * @return {string} Flattened path\n     */\n    normalize: function(path) {\n      if (Array.isArray(path)) {\n        let parts = [];\n        for (let i=0; i<path.length; i++) {\n          let args = path[i].toString().split('.');\n          for (let j=0; j<args.length; j++) {\n            parts.push(args[j]);\n          }\n        }\n        return parts.join('.');\n      } else {\n        return path;\n      }\n    },\n\n    /**\n     * Splits a path into an array of property names. Accepts either arrays\n     * of path parts or strings.\n     *\n     * Example:\n     *\n     * ```\n     * Polymer.Path.split(['foo.bar', 0, 'baz'])  // ['foo', 'bar', '0', 'baz']\n     * Polymer.Path.split('foo.bar.0.baz')        // ['foo', 'bar', '0', 'baz']\n     * ```\n     *\n     * @memberof Polymer.Path\n     * @param {string | !Array<string|number>} path Input path\n     * @return {!Array<string>} Array of path parts\n     */\n    split: function(path) {\n      if (Array.isArray(path)) {\n        return this.normalize(path).split('.');\n      }\n      return path.toString().split('.');\n    },\n\n    /**\n     * Reads a value from a path.  If any sub-property in the path is `undefined`,\n     * this method returns `undefined` (will never throw.\n     *\n     * @memberof Polymer.Path\n     * @param {Object} root Object from which to dereference path from\n     * @param {string | !Array<string|number>} path Path to read\n     * @param {Object=} info If an object is provided to `info`, the normalized\n     *  (flattened) path will be set to `info.path`.\n     * @return {*} Value at path, or `undefined` if the path could not be\n     *  fully dereferenced.\n     */\n    get: function(root, path, info) {\n      let prop = root;\n      let parts = this.split(path);\n      // Loop over path parts[0..n-1] and dereference\n      for (let i=0; i<parts.length; i++) {\n        if (!prop) {\n          return;\n        }\n        let part = parts[i];\n        prop = prop[part];\n      }\n      if (info) {\n        info.path = parts.join('.');\n      }\n      return prop;\n    },\n\n    /**\n     * Sets a value to a path.  If any sub-property in the path is `undefined`,\n     * this method will no-op.\n     *\n     * @memberof Polymer.Path\n     * @param {Object} root Object from which to dereference path from\n     * @param {string | !Array<string|number>} path Path to set\n     * @param {*} value Value to set to path\n     * @return {string | undefined} The normalized version of the input path\n     */\n    set: function(root, path, value) {\n      let prop = root;\n      let parts = this.split(path);\n      let last = parts[parts.length-1];\n      if (parts.length > 1) {\n        // Loop over path parts[0..n-2] and dereference\n        for (let i=0; i<parts.length-1; i++) {\n          let part = parts[i];\n          prop = prop[part];\n          if (!prop) {\n            return;\n          }\n        }\n        // Set value to object at end of path\n        prop[last] = value;\n      } else {\n        // Simple property set\n        prop[path] = value;\n      }\n      return parts.join('.');\n    }\n\n  };\n\n  /**\n   * Returns true if the given string is a structured data path (has dots).\n   *\n   * This function is deprecated.  Use `Polymer.Path.isPath` instead.\n   *\n   * Example:\n   *\n   * ```\n   * Polymer.Path.isDeep('foo.bar.baz') // true\n   * Polymer.Path.isDeep('foo')         // false\n   * ```\n   *\n   * @deprecated\n   * @memberof Polymer.Path\n   * @param {string} path Path string\n   * @return {boolean} True if the string contained one or more dots\n   */\n  Path.isDeep = Path.isPath;\n\n  Polymer.Path = Path;\n\n})();\n\n\n\n\n// WEBPACK FOOTER //\n// ./~/@polymer/polymer/lib/utils/path.html","/*__wc__loader*/\nrequire('./resolve-url.html');\n\n\n(function() {\n  'use strict';\n\n  const MODULE_STYLE_LINK_SELECTOR = 'link[rel=import][type~=css]';\n  const INCLUDE_ATTR = 'include';\n\n  function importModule(moduleId) {\n    if (!Polymer.DomModule) {\n      return null;\n    }\n    return Polymer.DomModule.import(moduleId);\n  }\n\n  /**\n   * Module with utilities for collection CSS text from `<templates>`, external\n   * stylesheets, and `dom-module`s.\n   *\n   * @namespace\n   * @memberof Polymer\n   * @summary Module with utilities for collection CSS text from various sources.\n   */\n  const StyleGather = {\n\n    /**\n     * Returns CSS text of styles in a space-separated list of `dom-module`s.\n     *\n     * @memberof Polymer.StyleGather\n     * @param {string} moduleIds List of dom-module id's within which to\n     * search for css.\n     * @return {string} Concatenated CSS content from specified `dom-module`s\n     */\n    cssFromModules(moduleIds) {\n      let modules = moduleIds.trim().split(' ');\n      let cssText = '';\n      for (let i=0; i < modules.length; i++) {\n        cssText += this.cssFromModule(modules[i]);\n      }\n      return cssText;\n    },\n\n    /**\n     * Returns CSS text of styles in a given `dom-module`.  CSS in a `dom-module`\n     * can come either from `<style>`s within the first `<template>`, or else\n     * from one or more `<link rel=\"import\" type=\"css\">` links outside the\n     * template.\n     *\n     * Any `<styles>` processed are removed from their original location.\n     *\n     * @memberof Polymer.StyleGather\n     * @param {string} moduleId dom-module id to gather styles from\n     * @return {string} Concatenated CSS content from specified `dom-module`\n     */\n    cssFromModule(moduleId) {\n      let m = importModule(moduleId);\n      if (m && m._cssText === undefined) {\n        let cssText = '';\n        // include css from the first template in the module\n        let t = m.querySelector('template');\n        if (t) {\n          cssText += this.cssFromTemplate(t, m.assetpath);\n        }\n        // module imports: <link rel=\"import\" type=\"css\">\n        cssText += this.cssFromModuleImports(moduleId);\n        m._cssText = cssText || null;\n      }\n      if (!m) {\n        console.warn('Could not find style data in module named', moduleId);\n      }\n      return m && m._cssText || '';\n    },\n\n    /**\n     * Returns CSS text of `<styles>` within a given template.\n     *\n     * Any `<styles>` processed are removed from their original location.\n     *\n     * @memberof Polymer.StyleGather\n     * @param {HTMLTemplateElement} template Template to gather styles from\n     * @param {string} baseURI Base URI to resolve the URL against\n     * @return {string} Concatenated CSS content from specified template\n     */\n    cssFromTemplate(template, baseURI) {\n      let cssText = '';\n      // if element is a template, get content from its .content\n      let e$ = template.content.querySelectorAll('style');\n      for (let i=0; i < e$.length; i++) {\n        let e = e$[i];\n        // support style sharing by allowing styles to \"include\"\n        // other dom-modules that contain styling\n        let include = e.getAttribute(INCLUDE_ATTR);\n        if (include) {\n          cssText += this.cssFromModules(include);\n        }\n        e.parentNode.removeChild(e);\n        cssText += baseURI ?\n          Polymer.ResolveUrl.resolveCss(e.textContent, baseURI) : e.textContent;\n      }\n      return cssText;\n    },\n\n    /**\n     * Returns CSS text from stylsheets loaded via `<link rel=\"import\" type=\"css\">`\n     * links within the specified `dom-module`.\n     *\n     * @memberof Polymer.StyleGather\n     * @param {string} moduleId Id of `dom-module` to gather CSS from\n     * @return {string} Concatenated CSS content from links in specified `dom-module`\n     */\n    cssFromModuleImports(moduleId) {\n      let cssText = '';\n      let m = importModule(moduleId);\n      if (!m) {\n        return cssText;\n      }\n      let p$ = m.querySelectorAll(MODULE_STYLE_LINK_SELECTOR);\n      for (let i=0; i < p$.length; i++) {\n        let p = p$[i];\n        if (p.import) {\n          let importDoc = p.import;\n          // NOTE: polyfill affordance.\n          // under the HTMLImports polyfill, there will be no 'body',\n          // but the import pseudo-doc can be used directly.\n          let container = importDoc.body ? importDoc.body : importDoc;\n          cssText +=\n            Polymer.ResolveUrl.resolveCss(container.textContent,\n              importDoc.baseURI);\n        }\n      }\n      return cssText;\n    }\n  };\n\n  Polymer.StyleGather = StyleGather;\n})();\n\n\n\n\n// WEBPACK FOOTER //\n// ./~/@polymer/polymer/lib/utils/style-gather.html","/*__wc__loader*/\nrequire('./boot.html');\n\nrequire('../mixins/property-effects.html');\n\nrequire('../mixins/mutable-data.html');\n\n\n  (function() {\n    'use strict';\n\n    // Base class for HTMLTemplateElement extension that has property effects\n    // machinery for propagating host properties to children. This is an ES5\n    // class only because Babel (incorrectly) requires super() in the class\n    // constructor even though no `this` is used and it returns an instance.\n    let newInstance = null;\n    function HTMLTemplateElementExtension() { return newInstance; }\n    HTMLTemplateElementExtension.prototype = Object.create(HTMLTemplateElement.prototype, {\n      constructor: {\n        value: HTMLTemplateElementExtension,\n        writable: true\n      }\n    });\n    const DataTemplate = Polymer.PropertyEffects(HTMLTemplateElementExtension);\n    const MutableDataTemplate = Polymer.MutableData(DataTemplate);\n\n    // Applies a DataTemplate subclass to a <template> instance\n    function upgradeTemplate(template, constructor) {\n      newInstance = template;\n      Object.setPrototypeOf(template, constructor.prototype);\n      new constructor();\n      newInstance = null;\n    }\n\n    // Base class for TemplateInstance's\n    /**\n     * @constructor\n     * @implements {Polymer_PropertyEffects}\n     */\n    const base = Polymer.PropertyEffects(class {});\n    class TemplateInstanceBase extends base {\n      constructor(props) {\n        super();\n        this._configureProperties(props);\n        this.root = this._stampTemplate(this.__dataHost);\n        // Save list of stamped children\n        let children = this.children = [];\n        for (let n = this.root.firstChild; n; n=n.nextSibling) {\n          children.push(n);\n          n.__templatizeInstance = this;\n        }\n        if (this.__templatizeOwner.__hideTemplateChildren__) {\n          this._showHideChildren(true);\n        }\n        // Flush props only when props are passed if instance props exist\n        // or when there isn't instance props.\n        let options = this.__templatizeOptions;\n        if ((props && options.instanceProps) || !options.instanceProps) {\n          this._enableProperties();\n        }\n      }\n      /**\n       * Configure the given `props` by calling `_setPendingProperty`. Also\n       * sets any properties stored in `__hostProps`.\n       * @private\n       * @param {Object} props Object of property name-value pairs to set.\n       */\n      _configureProperties(props) {\n        let options = this.__templatizeOptions;\n        if (props) {\n          for (let iprop in options.instanceProps) {\n            if (iprop in props) {\n              this._setPendingProperty(iprop, props[iprop]);\n            }\n          }\n        }\n        for (let hprop in this.__hostProps) {\n          this._setPendingProperty(hprop, this.__dataHost['_host_' + hprop]);\n        }\n      }\n      /**\n       * Forwards a host property to this instance.  This method should be\n       * called on instances from the `options.forwardHostProp` callback\n       * to propagate changes of host properties to each instance.\n       *\n       * Note this method enqueues the change, which are flushed as a batch.\n       *\n       * @param {string} prop Property or path name\n       * @param {*} value Value of the property to forward\n       */\n      forwardHostProp(prop, value) {\n        if (this._setPendingPropertyOrPath(prop, value, false, true)) {\n          this.__dataHost._enqueueClient(this);\n        }\n      }\n      /**\n       * @override\n       */\n      _addEventListenerToNode(node, eventName, handler) {\n        if (this._methodHost && this.__templatizeOptions.parentModel) {\n          // If this instance should be considered a parent model, decorate\n          // events this template instance as `model`\n          this._methodHost._addEventListenerToNode(node, eventName, (e) => {\n            e.model = this;\n            handler(e);\n          });\n        } else {\n          // Otherwise delegate to the template's host (which could be)\n          // another template instance\n          let templateHost = this.__dataHost.__dataHost;\n          if (templateHost) {\n            templateHost._addEventListenerToNode(node, eventName, handler);\n          }\n        }\n      }\n      /**\n       * Shows or hides the template instance top level child elements. For\n       * text nodes, `textContent` is removed while \"hidden\" and replaced when\n       * \"shown.\"\n       * @param {boolean} hide Set to true to hide the children;\n       * set to false to show them.\n       * @protected\n       */\n      _showHideChildren(hide) {\n        let c = this.children;\n        for (let i=0; i<c.length; i++) {\n          let n = c[i];\n          // Ignore non-changes\n          if (Boolean(hide) != Boolean(n.__hideTemplateChildren__)) {\n            if (n.nodeType === Node.TEXT_NODE) {\n              if (hide) {\n                n.__polymerTextContent__ = n.textContent;\n                n.textContent = '';\n              } else {\n                n.textContent = n.__polymerTextContent__;\n              }\n            } else if (n.style) {\n              if (hide) {\n                n.__polymerDisplay__ = n.style.display;\n                n.style.display = 'none';\n              } else {\n                n.style.display = n.__polymerDisplay__;\n              }\n            }\n          }\n          n.__hideTemplateChildren__ = hide;\n          if (n._showHideChildren) {\n            n._showHideChildren(hide);\n          }\n        }\n      }\n      /**\n       * Overrides default property-effects implementation to intercept\n       * textContent bindings while children are \"hidden\" and cache in\n       * private storage for later retrieval.\n       *\n       * @override\n       */\n      _setUnmanagedPropertyToNode(node, prop, value) {\n        if (node.__hideTemplateChildren__ &&\n            node.nodeType == Node.TEXT_NODE && prop == 'textContent') {\n          node.__polymerTextContent__ = value;\n        } else {\n          super._setUnmanagedPropertyToNode(node, prop, value);\n        }\n      }\n      /**\n       * Find the parent model of this template instance.  The parent model\n       * is either another templatize instance that had option `parentModel: true`,\n       * or else the host element.\n       *\n       * @return {Polymer.PropertyEffectsInterface} The parent model of this instance\n       */\n      get parentModel() {\n        let model = this.__parentModel;\n        if (!model) {\n          let options;\n          model = this\n          do {\n            // A template instance's `__dataHost` is a <template>\n            // `model.__dataHost.__dataHost` is the template's host\n            model = model.__dataHost.__dataHost;\n          } while ((options = model.__templatizeOptions) && !options.parentModel)\n          this.__parentModel = model;\n        }\n        return model;\n      }\n    }\n\n    const MutableTemplateInstanceBase = Polymer.MutableData(TemplateInstanceBase);\n\n    function findMethodHost(template) {\n      // Technically this should be the owner of the outermost template.\n      // In shadow dom, this is always getRootNode().host, but we can\n      // approximate this via cooperation with our dataHost always setting\n      // `_methodHost` as long as there were bindings (or id's) on this\n      // instance causing it to get a dataHost.\n      let templateHost = template.__dataHost;\n      return templateHost && templateHost._methodHost || templateHost;\n    }\n\n    function createTemplatizerClass(template, templateInfo, options) {\n      // Anonymous class created by the templatize\n      /**\n       * @unrestricted\n       */\n      let base = options.mutableData ?\n        MutableTemplateInstanceBase : TemplateInstanceBase;\n      let klass = class extends base { }\n      klass.prototype.__templatizeOptions = options;\n      klass.prototype._bindTemplate(template);\n      addNotifyEffects(klass, template, templateInfo, options);\n      return klass;\n    }\n\n    function addPropagateEffects(template, templateInfo, options) {\n      let userForwardHostProp = options.forwardHostProp;\n      if (userForwardHostProp) {\n        // Provide data API and property effects on memoized template class\n        let klass = templateInfo.templatizeTemplateClass;\n        if (!klass) {\n          let base = options.mutableData ? MutableDataTemplate : DataTemplate;\n          klass = templateInfo.templatizeTemplateClass =\n            class TemplatizedTemplate extends base {}\n          // Add template - >instances effects\n          // and host <- template effects\n          let hostProps = templateInfo.hostProps;\n          for (let prop in hostProps) {\n            klass.prototype._addPropertyEffect('_host_' + prop,\n              klass.prototype.PROPERTY_EFFECT_TYPES.PROPAGATE,\n              {fn: createForwardHostPropEffect(prop, userForwardHostProp)});\n            klass.prototype._createNotifyingProperty('_host_' + prop);\n          }\n        }\n        upgradeTemplate(template, klass);\n        // Mix any pre-bound data into __data; no need to flush this to\n        // instances since they pull from the template at instance-time\n        if (template.__dataProto) {\n          // Note, generally `__dataProto` could be chained, but it's guaranteed\n          // to not be since this is a vanilla template we just added effects to\n          Object.assign(template.__data, template.__dataProto);\n        }\n        // Clear any pending data for performance\n        template.__dataTemp = {};\n        template.__dataPending = null;\n        template.__dataOld = null;\n        template._enableProperties();\n      }\n    }\n\n    function createForwardHostPropEffect(hostProp, userForwardHostProp) {\n      return function forwardHostProp(template, prop, props) {\n        userForwardHostProp.call(template.__templatizeOwner,\n          prop.substring('_host_'.length), props[prop]);\n      }\n    }\n\n    function addNotifyEffects(klass, template, templateInfo, options) {\n      let hostProps = templateInfo.hostProps || {};\n      for (let iprop in options.instanceProps) {\n        delete hostProps[iprop];\n        let userNotifyInstanceProp = options.notifyInstanceProp;\n        if (userNotifyInstanceProp) {\n          klass.prototype._addPropertyEffect(iprop,\n            klass.prototype.PROPERTY_EFFECT_TYPES.NOTIFY,\n            {fn: createNotifyInstancePropEffect(iprop, userNotifyInstanceProp)});\n        }\n      }\n      if (options.forwardHostProp && template.__dataHost) {\n        for (let hprop in hostProps) {\n          klass.prototype._addPropertyEffect(hprop,\n            klass.prototype.PROPERTY_EFFECT_TYPES.NOTIFY,\n            {fn: createNotifyHostPropEffect()})\n        }\n      }\n    }\n\n    function createNotifyInstancePropEffect(instProp, userNotifyInstanceProp) {\n      return function notifyInstanceProp(inst, prop, props) {\n        userNotifyInstanceProp.call(inst.__templatizeOwner,\n          inst, prop, props[prop]);\n      }\n    }\n\n    function createNotifyHostPropEffect() {\n      return function notifyHostProp(inst, prop, props) {\n        inst.__dataHost._setPendingPropertyOrPath('_host_' + prop, props[prop], true, true);\n      }\n    }\n\n    /**\n     * Module for preparing and stamping instances of templates that utilize\n     * Polymer's data-binding and declarative event listener features.\n     *\n     * Example:\n     *\n     *     // Get a template from somewhere, e.g. light DOM\n     *     let template = this.querySelector('template');\n     *     // Prepare the template\n     *     let TemplateClass = Polymer.Templatize.templatize(template);\n     *     // Instance the template with an initial data model\n     *     let instance = new TemplateClass({myProp: 'initial'});\n     *     // Insert the instance's DOM somewhere, e.g. element's shadow DOM\n     *     this.shadowRoot.appendChild(instance.root);\n     *     // Changing a property on the instance will propagate to bindings\n     *     // in the template\n     *     instance.myProp = 'new value';\n     *\n     * The `options` dictionary passed to `templatize` allows for customizing\n     * features of the generated template class, including how outer-scope host\n     * properties should be forwarded into template instances, how any instance\n     * properties added into the template's scope should be notified out to\n     * the host, and whether the instance should be decorated as a \"parent model\"\n     * of any event handlers.\n     *\n     *     // Customze property forwarding and event model decoration\n     *     let TemplateClass = Polymer.Tempaltize.templatize(template, this, {\n     *       parentModel: true,\n     *       instanceProps: {...},\n     *       forwardHostProp(property, value) {...},\n     *       notifyInstanceProp(instance, property, value) {...},\n     *     });\n     *\n     *\n     * @namespace\n     * @memberof Polymer\n     * @summary Module for preparing and stamping instances of templates\n     *   utilizing Polymer templating features.\n     */\n    const Templatize = {\n\n      /**\n       * Returns an anonymous `Polymer.PropertyEffects` class bound to the\n       * `<template>` provided.  Instancing the class will result in the\n       * template being stamped into document fragment stored as the instance's\n       * `root` property, after which it can be appended to the DOM.\n       *\n       * Templates may utilize all Polymer data-binding features as well as\n       * declarative event listeners.  Event listeners and inline computing\n       * functions in the template will be called on the host of the template.\n       *\n       * The constructor returned takes a single argument dictionary of initial\n       * property values to propagate into template bindings.  Additionally\n       * host properties can be forwarded in, and instance properties can be\n       * notified out by providing optional callbacks in the `options` dictionary.\n       *\n       * Valid configuration in `options` are as follows:\n       *\n       * - `forwardHostProp(property, value)`: Called when a property referenced\n       *   in the template changed on the template's host. As this library does\n       *   not retain references to templates instanced by the user, it is the\n       *   templatize owner's responsibility to forward host property changes into\n       *   user-stamped instances.  The `instance.forwardHostProp(property, value)`\n       *    method on the generated class should be called to forward host\n       *   properties into the template to prevent unnecessary property-changed\n       *   notifications. Any properties referenced in the template that are not\n       *   defined in `instanceProps` will be notified up to the template's host\n       *   automatically.\n       * - `instanceProps`: Dictionary of property names that will be added\n       *   to the instance by the templatize owner.  These properties shadow any\n       *   host properties, and changes within the template to these properties\n       *   will result in `notifyInstanceProp` being called.\n       * - `mutableData`: When `true`, the generated class will skip strict\n       *   dirty-checking for objects and arrays (always consider them to be\n       *   \"dirty\").\n       * - `notifyInstanceProp(instance, property, value)`: Called when\n       *   an instance property changes.  Users may choose to call `notifyPath`\n       *   on e.g. the owner to notify the change.\n       * - `parentModel`: When `true`, events handled by declarative event listeners\n       *   (`on-event=\"handler\"`) will be decorated with a `model` property pointing\n       *   to the template instance that stamped it.  It will also be returned\n       *   from `instance.parentModel` in cases where template instance nesting\n       *   causes an inner model to shadow an outer model.\n       *\n       * Note that the class returned from `templatize` is generated only once\n       * for a given `<template>` using `options` from the first call for that\n       * template, and the cached class is returned for all subsequent calls to\n       * `templatize` for that template.  As such, `options` callbacks should not\n       * close over owner-specific properties since only the first `options` is\n       * used; rather, callbacks are called bound to the `owner`, and so context\n       * needed from the callbacks (such as references to `instances` stamped)\n       * should be stored on the `owner` such that they can be retrieved via `this`.\n       *\n       * @memberof Polymer.Templatize\n       * @param {HTMLTemplateElement} template Template to templatize\n       * @param {*} owner Owner of the template instances; any optional callbacks\n       *   will be bound to this owner.\n       * @param {*=} options Options dictionary (see summary for details)\n       * @return {TemplateInstanceBase} Generated class bound to the template\n       *   provided\n       */\n      templatize(template, owner, options) {\n        options = options || {};\n        if (template.__templatizeOwner) {\n          throw new Error('A <template> can only be templatized once');\n        }\n        template.__templatizeOwner = owner;\n        let templateInfo = owner.constructor._parseTemplate(template);\n        // Get memoized base class for the prototypical template, which\n        // includes property effects for binding template & forwarding\n        let baseClass = templateInfo.templatizeInstanceClass;\n        if (!baseClass) {\n          baseClass = createTemplatizerClass(template, templateInfo, options);\n          templateInfo.templatizeInstanceClass = baseClass;\n        }\n        // Host property forwarding must be installed onto template instance\n        addPropagateEffects(template, templateInfo, options);\n        // Subclass base class and add reference for this specific template\n        let klass = class TemplateInstance extends baseClass {};\n        klass.prototype._methodHost = findMethodHost(template);\n        klass.prototype.__dataHost = template;\n        klass.prototype.__templatizeOwner = owner;\n        klass.prototype.__hostProps = templateInfo.hostProps;\n        return klass;\n      },\n\n      /**\n       * Returns the template \"model\" associated with a given element, which\n       * serves as the binding scope for the template instance the element is\n       * contained in. A template model is an instance of\n       * `TemplateInstanceBase`, and should be used to manipulate data\n       * associated with this template instance.\n       *\n       * Example:\n       *\n       *   let model = modelForElement(el);\n       *   if (model.index < 10) {\n       *     model.set('item.checked', true);\n       *   }\n       *\n       * @memberof Polymer.Templatize\n       * @param {HTMLTemplateElement} template The model will be returned for\n       *   elements stamped from this template\n       * @param {HTMLElement} el Element for which to return a template model.\n       * @return {TemplateInstanceBase} Template instance representing the\n       *   binding scope for the element\n       */\n      modelForElement(template, el) {\n        let model;\n        while (el) {\n          // An element with a __templatizeInstance marks the top boundary\n          // of a scope; walk up until we find one, and then ensure that\n          // its __dataHost matches `this`, meaning this dom-repeat stamped it\n          if ((model = el.__templatizeInstance)) {\n            // Found an element stamped by another template; keep walking up\n            // from its __dataHost\n            if (model.__dataHost != template) {\n              el = model.__dataHost;\n            } else {\n              return model;\n            }\n          } else {\n            // Still in a template scope, keep going up until\n            // a __templatizeInstance is found\n            el = el.parentNode;\n          }\n        }\n        return null;\n      }\n    }\n\n    Polymer.Templatize = Templatize;\n\n  })();\n\n\n\n\n\n// WEBPACK FOOTER //\n// ./~/@polymer/polymer/lib/utils/templatize.html","module.exports = function(module) {\r\n\tif(!module.webpackPolyfill) {\r\n\t\tmodule.deprecate = function() {};\r\n\t\tmodule.paths = [];\r\n\t\t// module.parent = undefined by default\r\n\t\tif(!module.children) module.children = [];\r\n\t\tObject.defineProperty(module, \"loaded\", {\r\n\t\t\tenumerable: true,\r\n\t\t\tget: function() {\r\n\t\t\t\treturn module.l;\r\n\t\t\t}\r\n\t\t});\r\n\t\tObject.defineProperty(module, \"id\", {\r\n\t\t\tenumerable: true,\r\n\t\t\tget: function() {\r\n\t\t\t\treturn module.i;\r\n\t\t\t}\r\n\t\t});\r\n\t\tmodule.webpackPolyfill = 1;\r\n\t}\r\n\treturn module;\r\n};\r\n\n\n\n// WEBPACK FOOTER //\n// (webpack)/buildin/module.js"],"sourceRoot":""}